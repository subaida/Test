/**
* @class Kagi2DChart
* @author InfoSoft Global (P) Ltd. www.InfoSoftGlobal.com
* @version 3.0
*
* Copyright (C) InfoSoft Global Pvt. Ltd. 2005-2006
*
* Kagi2DChart chart extends the SingleYAxis2DVerticalChart class to render a
* 2D Kagi Chart.
*/
//Import Chart class
import com.fusioncharts.core.Chart;
//Parent SingleYAxis2DVerticalChart Class
import com.fusioncharts.core.SingleYAxis2DVerticalChart;
//Error class
import com.fusioncharts.helper.FCError;
//Import Logger Class
import com.fusioncharts.helper.Logger;
//Style Object
import com.fusioncharts.core.StyleObject;
//Delegate
import mx.utils.Delegate;
//Extensions
import com.fusioncharts.extensions.ColorExt;
import com.fusioncharts.extensions.StringExt;
import com.fusioncharts.extensions.MathExt;
import com.fusioncharts.extensions.DrawingExt;
class com.fusioncharts.core.charts.Kagi2DChart extends SingleYAxis2DVerticalChart {
	//Version number (if different from super Chart class)
	//private var _version:String = "3.0.0";
	//Instance variables
	//List of chart objects
	private var _arrObjects:Array;
	private var xmlData:XML;
	//Array to store data objects
	private var data:Array;
	//Number of data items
	private var num:Number;
	/**
	* Constructor function. We invoke the super class'
	* constructor and then set the objects for this chart.
	*/
	function Kagi2DChart(targetMC:MovieClip, depth:Number, width:Number, height:Number, x:Number, y:Number, debugMode:Boolean, lang:String, scaleMode:String, registerWithJS:Boolean, DOMId:String) {
		//Invoke the super class constructor
		super (targetMC, depth, width, height, x, y, debugMode, lang, scaleMode, registerWithJS, DOMId);
		//Log additional information to debugger
		//We log version from this class, so that if this class version
		//is different, we can log it
		this.log("Version", _version, Logger.LEVEL.INFO);
		this.log("Chart Type", "Single Series 2D Line Chart", Logger.LEVEL.INFO);
		//List Chart Objects and set them
		_arrObjects = new Array("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "YAXISNAME", "XAXISNAME", "DIVLINES", "VDIVLINES", "YAXISVALUES", "HGRID", "VGRID", "DATALABELS", "DATAVALUES", "TRENDLINES", "TRENDVALUES", "DATAPLOT", "ANCHORS", "TOOLTIP", "VLINES");
		super.setChartObjects(_arrObjects);
		//Initialize the data structure (array) for single series chart
		this.data = new Array();
		//Initialize the number of data elements present
		this.num = 0;
		//Whether negative number present
		this.config.negativePresent = false;
	}
	/**
	* render method is the single call method that does the rendering of chart:
	* - Parsing XML
	* - Calculating values and co-ordinates
	* - Visual layout and rendering
	* - Event handling
	*/
	public function render():Void {
		//Parse the XML Data document
		this.parseXML();
		//Now, if the number of data elements is 0, we show pertinent
		//error.
		if (this.num == 0) {
			tfAppMsg = this.renderAppMessage(_global.getAppMessage("NODATA", this.lang));
			//Add a message to log.
			this.log("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn't any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI><LI>You might be using a Single Series Chart .swf file instead of Multi-series .swf file and providing multi-series data or vice-versa.</LI>", Logger.LEVEL.ERROR);
			//Expose rendered method
			this.exposeChartRendered();
		} else {
			//Detect number scales
			this.detectNumberScales();
			//Calculate the axis limits
			this.calculateAxisLimits();
			//Calculate exact number of div lines
			this.calcDivs();
			//Set Style defaults
			this.setStyleDefaults();
			//Validate trend lines
			this.validateTrendLines();
			//Calculate Points
			this.calculatePoints();
			//Calculate vLine Positions
			this.calcVLinesPos();
			//Calculate trend line positions
			this.calcTrendLinePos();
			//Allot the depths for various charts objects now
			this.allotDepths();
			//Feed macro values
			super.feedMacros();
			//Remove application message
			this.removeAppMessage(this.tfAppMsg);
			//Set tool tip parameter
			this.setToolTipParam();
			//-----Start Visual Rendering Now------//
			//Draw background
			this.drawBackground();
			//Set click handler
			this.drawClickURLHandler();
			//Load background SWF
			this.loadBgSWF();
			//Update timer
			this.timeElapsed = (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.BACKGROUND) : 0;
			//Draw canvas
			this.config.intervals.canvas = setInterval(Delegate.create(this, drawCanvas), this.timeElapsed);
			//Draw headers
			this.config.intervals.headers = setInterval(Delegate.create(this, drawHeaders), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.CANVAS, this.objects.CAPTION, this.objects.SUBCAPTION, this.objects.YAXISNAME, this.objects.XAXISNAME) : 0;
			//Draw div lines
			this.config.intervals.divLines = setInterval(Delegate.create(this, drawDivLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DIVLINES, this.objects.YAXISVALUES) : 0;
			//Vertical div lines
			this.config.intervals.vDivLines = setInterval(Delegate.create(this, drawVDivLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation && (this.params.numVDivLines>0)) ? this.styleM.getMaxAnimationTime(this.objects.VDIVLINES) : 0;
			//Horizontal grid
			this.config.intervals.hGrid = setInterval(Delegate.create(this, drawHGrid), this.timeElapsed);
			//Vertical grid
			this.config.intervals.vGrid = setInterval(Delegate.create(this, drawVGrid), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation && (this.params.showAlternateHGridColor || this.params.showAlternateVGridColor)) ? this.styleM.getMaxAnimationTime(this.objects.HGRID, this.objects.VGRID) : 0;
			//Draw labels
			this.config.intervals.labels = setInterval(Delegate.create(this, drawLabels), this.timeElapsed);
			//Draw line chart
			this.config.intervals.plot = setInterval(Delegate.create(this, drawKagiChart), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation && (this.num>1)) ? this.styleM.getMaxAnimationTime(this.objects.DATALABELS, this.objects.DATAPLOT) : 0;
			//Data Values
			this.config.intervals.dataValues = setInterval(Delegate.create(this, drawValues), this.timeElapsed);
			//Anchors
			this.config.intervals.anchors = setInterval(Delegate.create(this, drawAnchors), this.timeElapsed);
			//Draw trend lines
			this.config.intervals.trend = setInterval(Delegate.create(this, drawTrendLines), this.timeElapsed);
			//Draw vertical div lines
			this.config.intervals.vLine = setInterval(Delegate.create(this, drawVLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.ANCHORS, this.objects.TRENDLINES, this.objects.TRENDVALUES, this.objects.VLINES, this.objects.DATAVALUES) : 0;
			//Dispatch event that the chart has loaded.
			this.config.intervals.renderedEvent = setInterval(Delegate.create(this, exposeChartRendered) , this.timeElapsed);
			//Render context menu
			//We do not put context menu interval as we need the menu to appear
			//right from start of the play.			
			this.setContextMenu();
		}
	}
	/**
	* returnDataAsObject method creates an object out of the parameters
	* passed to this method. The idea is that we store each data point
	* as an object with multiple (flexible) properties. So, we do not
	* use a predefined class structure. Instead we use a generic object.
	*	@param	label		Label of the data.
	*	@param	value		Value for the data.
	*	@param	color		Hex Color code.
	*	@param	alpha		Alpha of the line
	*	@param	toolText	Tool tip text (if specified).
	*	@param	link		Link (if any) for the data.
	*	@param	showLabel	Flag to show/hide label for this data.
	*	@param	showValue	Flag to show/hide value for this data.
	*	@param	isDashed	Flag whether the line would be dashed.
	*	@param	anchorSides				Number of sides of the anchor.
	*	@param	anchorRadius			Radius of the anchor (in pixels).
	*	@param	anchorBorderColor		Border color of the anchor.
	*	@param	anchorBorderThickness	Border thickness of the anchor.
	*	@param	anchorBgColor			Background color of the anchor.
	*	@param	anchorAlpha				Alpha of the anchor.
	*	@param	anchorBgAlpha			Background (fill) alpha of the anchor.
	*	@returns			An object encapsulating all these properies.
	*/
	private function returnDataAsObject(label:String, value:Number, color:String, alpha:Number, toolText:String, link:String, showLabel:Number, showValue:Number, isDashed:Boolean, anchorSides:Number, anchorRadius:Number, anchorBorderColor:String, anchorBorderThickness:Number, anchorBgColor:String, anchorAlpha:Number, anchorBgAlpha:Number):Object {
		//Create a container
		var dataObj:Object = new Object();
		//Store the values
		dataObj.label = label;
		dataObj.value = value;
		//Extract and save colors, ratio, alpha as array so that we do not have to parse later.
		dataObj.color = color;
		dataObj.alpha = alpha;
		dataObj.toolText = toolText;
		dataObj.link = link;
		dataObj.showLabel = (showLabel == 1) ? true : false;
		dataObj.showValue = (showValue == 1) ? true : false;
		dataObj.dashed = isDashed;
		//Anchor properties
		dataObj.anchorSides = anchorSides;
		dataObj.anchorRadius = anchorRadius;
		dataObj.anchorBorderColor = anchorBorderColor;
		dataObj.anchorBorderThickness = anchorBorderThickness;
		dataObj.anchorBgColor = anchorBgColor;
		dataObj.anchorAlpha = anchorAlpha;
		dataObj.anchorBgAlpha = anchorBgAlpha;
		//If the given number is not a valid number or it's missing
		//set appropriate flags for this data point
		dataObj.isDefined = ((dataObj.alpha == 0) || isNaN(value)) ? false : true;
		//Other parameters
		//X & Y Position of data point
		dataObj.x = 0;
		dataObj.y = 0;
		//X & Y Position of value tb
		dataObj.valTBX = 0;
		dataObj.valTBY = 0;
		//Return the container
		return dataObj;
	}
	/**
	* parseXML method parses the XML data, sets defaults and validates
	* the attributes before storing them to data storage objects.
	*/
	private function parseXML():Void {
		//Get the element nodes
		var arrDocElement:Array = this.xmlData.childNodes;
		//Loop variable
		var i:Number;
		var j:Number;
		//Look for <graph> element
		for (i=0; i<arrDocElement.length; i++) {
			//If it's a <graph> element, proceed.
			//Do case in-sensitive mathcing by changing to upper case
			if (arrDocElement[i].nodeName.toUpperCase() == "GRAPH" || arrDocElement[i].nodeName.toUpperCase() == "CHART") {
				//Extract attributes of <graph> element
				this.parseAttributes(arrDocElement[i]);
				//Now, get the child nodes - first level nodes
				//Level 1 nodes can be - CATEGORIES, DATASET, TRENDLINES, STYLES etc.
				var arrLevel1Nodes:Array = arrDocElement[i].childNodes;
				var setNode:XMLNode;
				//Iterate through all level 1 nodes.
				for (j=0; j<arrLevel1Nodes.length; j++) {
					//If it's Data nodes
					if (arrLevel1Nodes[j].nodeName.toUpperCase() == "SET") {
						//Set Node. So extract the data.
						//First, updated counter
						this.num++;
						//Get reference to node.
						setNode = arrLevel1Nodes[j];
						//Get attributes
						var atts:Array;
						atts = this.getAttributesArray(setNode);
						//Extract values.
						var setName:String = getFV(atts["label"], atts["name"], "");
						//Now, get value.
						var setValue:Number = this.getSetValue(atts["value"]);
						//to avoid undefined/empty/blank values irrelevant for the chart
						if (setValue != undefined && setValue != null && setValue != '' && !isNaN(Number(setValue))) {
							//We do NOT unescape the link, as this will be done
							//in invokeLink method for the links that user clicks.
							var setLink:String = getFV(atts["link"], "");
							var setToolText:String = getFV(atts["tooltext"], atts["hovertext"]);
							var setColor:String = getFV(atts["color"], this.params.lineColor);
							var setAlpha:Number = getFN(atts["alpha"], this.params.lineAlpha);
							var setShowLabel:Number = getFN(atts["showlabel"], atts["showname"], this.params.showLabels);
							var setShowValue:Number = getFN(atts["showvalue"], this.params.showValues);
							var setDashed:Boolean = toBoolean(getFN(atts["dashed"], this.params.lineDashed));
							//Anchor properties for individual set
							var setAnchorSides:Number = getFN(atts["anchorsides"], this.params.anchorSides);
							var setAnchorRadius:Number = getFN(atts["anchorradius"], this.params.anchorRadius);
							var setAnchorBorderColor:String = formatColor(getFV(atts["anchorbordercolor"], this.params.anchorBorderColor));
							var setAnchorBorderThickness:Number = getFN(atts["anchorborderthickness"], this.params.anchorBorderThickness);
							var setAnchorBgColor:String = formatColor(getFV(atts["anchorbgcolor"], this.params.anchorBgColor));
							var setAnchorAlpha:Number = getFN(atts["anchoralpha"], this.params.anchorAlpha);
							var setAnchorBgAlpha:Number = getFN(atts["anchorbgalpha"], this.params.anchorBgAlpha);
							//Store all these attributes as object.						
							this.data[this.num] = this.returnDataAsObject(setName, setValue, setColor, setAlpha, setToolText, setLink, setShowLabel, setShowValue, setDashed, setAnchorSides, setAnchorRadius, setAnchorBorderColor, setAnchorBorderThickness, setAnchorBgColor, setAnchorAlpha, setAnchorBgAlpha);
						} else {
							this.num--;
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "VLINE") {
						//Vertical axis division Node - extract child nodes
						var vLineNode:XMLNode = arrLevel1Nodes[j];
						//Parse and store
						this.parseVLineNode(vLineNode, this.num);
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "STYLES") {
						//Styles Node - extract child nodes
						var arrStyleNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the style nodes to extract style information
						super.parseStyleXML(arrStyleNodes);
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "TRENDLINES") {
						//Trend lines node
						var arrTrendNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the trend line nodes
						super.parseTrendLineXML(arrTrendNodes);
					}
				}
			}
		}
		//Delete all temporary objects used for parsing XML Data document
		delete setNode;
		delete arrDocElement;
		delete arrLevel1Nodes;
	}
	/**
	* parseAttributes method parses the attributes and stores them in
	* chart storage objects.
	* Starting ActionScript 2, the parsing of XML attributes have also
	* become case-sensitive. However, prior versions of FusionCharts
	* supported case-insensitive attributes. So we need to parse all
	* attributes as case-insensitive to maintain backward compatibility.
	* To do so, we first extract all attributes from XML, convert it into
	* lower case and then store it in an array. Later, we extract value from
	* this array.
	* @param	graphElement	XML Node containing the <graph> element
	*							and it's attributes
	*/
	private function parseAttributes(graphElement:XMLNode):Void {
		//Array to store the attributes
		var atts:Array = this.getAttributesArray(graphElement);
		//NOW IT'S VERY NECCESARY THAT WHEN WE REFERENCE THIS ARRAY
		//TO GET AN ATTRIBUTE VALUE, WE SHOULD PROVIDE THE ATTRIBUTE
		//NAME IN LOWER CASE. ELSE, UNDEFINED VALUE WOULD SHOW UP.
		//Extract attributes pertinent to this chart
		//Which palette to use?
		this.params.palette = getFN(atts["palette"], 1);
		//Whether to show about FusionCharts Menu Item - by default set to on
		this.params.showFCMenuItem = toBoolean(getFN (atts ["showfcmenuitem"] , 1));
		// ---------- PADDING AND SPACING RELATED ATTRIBUTES ----------- //
		//captionPadding = Space between caption/subcaption and canvas start Y
		this.params.captionPadding = getFN(atts["captionpadding"], 10);
		//Canvas Padding is the space between the canvas left/right border
		//and first/last data point
		this.params.canvasPadding = getFN(atts["canvaspadding"], 15);
		//Padding for x-axis name - to the right
		this.params.xAxisNamePadding = getFN(atts["xaxisnamepadding"], 5);
		//Padding for y-axis name - from top
		this.params.yAxisNamePadding = getFN(atts["yaxisnamepadding"], 5);
		//Y-Axis Values padding - Horizontal space between the axis edge and
		//y-axis values or trend line values (on left/right side).
		this.params.yAxisValuesPadding = getFN(atts["yaxisvaluespadding"], 2);
		//Label padding - Vertical space between the labels and canvas end position
		this.params.labelPadding = getFN(atts["labelpadding"], atts["labelspadding"], 3);
		//Value padding - vertical space between the anchors and start of value textboxes
		this.params.valuePadding = getFN(atts["valuepadding"], 2);
		//Chart Margins - Empty space at the 4 sides
		this.params.chartLeftMargin = getFN(atts["chartleftmargin"], 15);
		this.params.chartRightMargin = getFN(atts["chartrightmargin"], 15);
		this.params.chartTopMargin = getFN(atts["charttopmargin"], 15);
		this.params.chartBottomMargin = getFN(atts["chartbottommargin"], 15);
		// -------------------------- HEADERS ------------------------- //
		//Chart Caption and sub Caption
		this.params.caption = getFV(atts["caption"], "");
		this.params.subCaption = getFV(atts["subcaption"], "");
		//X and Y Axis Name
		this.params.xAxisName = getFV(atts["xaxisname"], "");
		this.params.yAxisName = getFV(atts["yaxisname"], "");
		//Adaptive yMin - if set to true, the y min will be based on the values 
		//provided. It won't be set to 0 in case of all positive values
		this.params.setAdaptiveYMin = toBoolean(getFN(atts["setadaptiveymin"], 1));
		// --------------------- CONFIGURATION ------------------------- //
		//The upper and lower limits of y and x axis
		this.params.yAxisMinValue = atts["yaxisminvalue"];
		this.params.yAxisMaxValue = atts["yaxismaxvalue"];
		//Whether to set animation for entire chart.
		this.params.animation = toBoolean(getFN(atts["animation"], 1));
		//Whether to set the default chart animation
		this.params.defaultAnimation = toBoolean(getFN(atts["defaultanimation"], 1));
		//Configuration to set whether to show the labels   
		this.params.showLabels = toBoolean(getFN(atts["showlabels"], atts["shownames"], 1));
		//Label Display Mode - WRAP, STAGGER, ROTATE or NONE
		this.params.labelDisplay = getFV(atts["labeldisplay"], "WRAP");
		//Remove spaces and capitalize
		this.params.labelDisplay = StringExt.removeSpaces(this.params.labelDisplay);
		this.params.labelDisplay = this.params.labelDisplay.toUpperCase();
		//Option to show vertical x-axis labels
		this.params.rotateLabels = getFV(atts["rotatelabels"], atts["rotatenames"]);
		//Whether to slant label (if rotated)
		this.params.slantLabels = toBoolean(getFN(atts["slantlabels"], atts["slantlabel"], 0));
		//Angle of rotation based on slanting
		this.config.labelAngle = (this.params.slantLabels == true) ? 315 : 270;
		//If rotateLabels has been explicitly specified, we assign ROTATE value to this.params.labelDisplay
		this.params.labelDisplay = (this.params.rotateLabels == "1") ? "ROTATE" : this.params.labelDisplay;
		//Step value for labels - i.e., show all labels or skip every x label
		this.params.labelStep = int(getFN(atts["labelstep"], 1));
		//Cannot be less than 1
		this.params.labelStep = (this.params.labelStep<1) ? 1 : this.params.labelStep;
		//Number of stagger lines
		this.params.staggerLines = int(getFN(atts["staggerlines"], 2));
		//Cannot be less than 2
		this.params.staggerLines = (this.params.staggerLines<2) ? 2 : this.params.staggerLines;
		//Configuration whether to show data values
		this.params.showValues = toBoolean(getFN(atts["showvalues"], 1));
		//Whether to rotate values
		this.params.rotateValues = toBoolean(getFN(atts["rotatevalues"], 0));
		//Option to show/hide y-axis values
		this.params.showYAxisValues = getFN(atts["showyaxisvalues"], atts["showyaxisvalue"], 1);
		this.params.showLimits = toBoolean(getFN(atts["showlimits"], this.params.showYAxisValues));
		this.params.showDivLineValues = toBoolean(getFN(atts["showdivlinevalue"], atts["showdivlinevalues"], this.params.showYAxisValues));
		//Y-axis value step- i.e., show all y-axis or skip every x(th) value
		this.params.yAxisValuesStep = int(getFN(atts["yaxisvaluesstep"], atts["yaxisvaluestep"], 1));
		//Cannot be less than 1
		this.params.yAxisValuesStep = (this.params.yAxisValuesStep<1) ? 1 : this.params.yAxisValuesStep;
		//Whether to automatically adjust div lines
		this.params.adjustDiv = toBoolean(getFN(atts["adjustdiv"], 1));
		//Whether to rotate y-axis name
		this.params.rotateYAxisName = toBoolean(getFN(atts["rotateyaxisname"], 1));
		//Max width to be alloted to y-axis name - No defaults, as it's calculated later.
		this.params.yAxisNameWidth = atts["yaxisnamewidth"];
		//Click URL
		this.params.clickURL = getFV(atts["clickurl"], "");
		//-------------------------- KAGI ----------------------------------//
		//the value which determines whether to make a horizontal shift to deal with the next point
		this.params.reversalValue = getFN(atts["reversalvalue"], -1);
		//the percentage of the range of values, which determines whether to make a horizontal shift to deal with the next point
		this.params.reversalPercentage = getFN(atts["reversalpercentage"], 5);
		//the maximum horizontal shift in percentage of the available canvas width
		this.params.maxHShiftPercent = getFN(atts["maxhshiftpercent"], 10);
		//color of line denoting rally
		this.params.rallyColor = formatColor(getFV(atts["rallycolor"], 'FF0000'));
		//color of line denoting decline
		this.params.declineColor = formatColor(getFV(atts["declinecolor"], '0000FF'));
		//thickness of line denoting rally
		this.params.rallyThickness = getFN(atts["rallythickness"], 2);
		//thickness of line denoting decline
		this.params.declineThickness = getFN(atts["declinethickness"], 2);
		// ------------------------- COSMETICS -----------------------------//
		//Background properties - Gradient
		this.params.bgColor = getFV(atts["bgcolor"], this.defColors.get2DBgColor(this.params.palette));
		this.params.bgAlpha = getFV(atts["bgalpha"], this.defColors.get2DBgAlpha(this.params.palette));
		this.params.bgRatio = getFV(atts["bgratio"], this.defColors.get2DBgRatio(this.params.palette));
		this.params.bgAngle = getFV(atts["bgangle"], this.defColors.get2DBgAngle(this.params.palette));
		//Border Properties of chart
		this.params.showBorder = toBoolean(getFN(atts["showborder"], 1));
		this.params.borderColor = formatColor(getFV(atts["bordercolor"], this.defColors.get2DBorderColor(this.params.palette)));
		this.params.borderThickness = getFN(atts["borderthickness"], 1);
		this.params.borderAlpha = getFN(atts["borderalpha"], this.defColors.get2DBorderAlpha(this.params.palette));
		//Background swf
		this.params.bgSWF = getFV(atts["bgswf"], "");
		this.params.bgSWFAlpha = getFN(atts["bgswfalpha"], 100);
		//Canvas background properties - Gradient
		this.params.canvasBgColor = getFV(atts["canvasbgcolor"], this.defColors.get2DCanvasBgColor(this.params.palette));
		this.params.canvasBgAlpha = getFV(atts["canvasbgalpha"], this.defColors.get2DCanvasBgAlpha(this.params.palette));
		this.params.canvasBgRatio = getFV(atts["canvasbgratio"], this.defColors.get2DCanvasBgRatio(this.params.palette));
		this.params.canvasBgAngle = getFV(atts["canvasbgangle"], this.defColors.get2DCanvasBgAngle(this.params.palette));
		//Canvas Border properties
		this.params.canvasBorderColor = formatColor(getFV(atts["canvasbordercolor"], this.defColors.get2DCanvasBorderColor(this.params.palette)));
		this.params.canvasBorderThickness = getFN(atts["canvasborderthickness"], 2);
		this.params.canvasBorderAlpha = getFN(atts["canvasborderalpha"], this.defColors.get2DCanvasBorderAlpha(this.params.palette));
		//Plot is dashed
		this.params.lineDashed = toBoolean(getFN(atts["linedashed"], 0));
		//Dash Properties
		this.params.lineDashLen = getFN(atts["linedashlen"], 5);
		this.params.lineDashGap = getFN(atts["linedashgap"], 4);
		//Horizontal grid division Lines - Number, color, thickness & alpha
		//Necessarily need a default value for numDivLines.
		this.params.numDivLines = getFN(atts["numdivlines"], 4);
		this.params.divLineColor = formatColor(getFV(atts["divlinecolor"], this.defColors.get2DDivLineColor(this.params.palette)));
		this.params.divLineThickness = getFN(atts["divlinethickness"], 1);
		this.params.divLineAlpha = getFN(atts["divlinealpha"], this.defColors.get2DDivLineAlpha(this.params.palette));
		this.params.divLineIsDashed = toBoolean(getFN(atts["divlineisdashed"], 0));
		this.params.divLineDashLen = getFN(atts["divlinedashlen"], 4);
		this.params.divLineDashGap = getFN(atts["divlinedashgap"], 2);
		//Vertical div lines		
		this.params.numVDivLines = getFN(atts["numvdivlines"], 0);
		this.params.vDivLineColor = formatColor(getFV(atts["vdivlinecolor"], this.params.divLineColor));
		this.params.vDivLineThickness = getFN(atts["vdivlinethickness"], this.params.divLineThickness);
		this.params.vDivLineAlpha = getFN(atts["vdivlinealpha"], this.params.divLineAlpha);
		this.params.vDivLineIsDashed = toBoolean(getFN(atts["vdivlineisdashed"], this.params.divLineIsDashed));
		this.params.vDivLineDashLen = getFN(atts["vdivlinedashlen"], this.params.divLineDashLen);
		this.params.vDivLineDashGap = getFN(atts["vdivlinedashgap"], this.params.divLineDashGap);
		//Zero Plane properties
		this.params.showZeroPlane = toBoolean(getFN(atts["showzeroplane"], 1));
		this.params.zeroPlaneColor = formatColor(getFV(atts["zeroplanecolor"], this.params.divLineColor));
		this.params.zeroPlaneThickness = getFN(atts["zeroplanethickness"], 1);
		this.params.zeroPlaneAlpha = getFN(atts["zeroplanealpha"], this.params.divLineAlpha);
		//Alternating grid colors
		this.params.showAlternateHGridColor = toBoolean(getFN(atts["showalternatehgridcolor"], 1));
		this.params.alternateHGridColor = formatColor(getFV(atts["alternatehgridcolor"], this.defColors.get2DAltHGridColor(this.params.palette)));
		this.params.alternateHGridAlpha = getFN(atts["alternatehgridalpha"], this.defColors.get2DAltHGridAlpha(this.params.palette));
		this.params.showAlternateVGridColor = toBoolean(getFN(atts["showalternatevgridcolor"], 0));
		this.params.alternateVGridColor = formatColor(getFV(atts["alternatevgridcolor"], this.defColors.get2DAltVGridColor(this.params.palette)));
		this.params.alternateVGridAlpha = getFN(atts["alternatevgridalpha"], this.defColors.get2DAltVGridAlpha(this.params.palette));
		//Line Properties
		this.params.lineColor = formatColor(getFV(atts["linecolor"], this.defColors.get2DPlotFillColor(this.params.palette)));
		this.params.lineThickness = getFN(atts["linethickness"], 4);
		this.params.lineAlpha = getFN(atts["linealpha"], 100);
		//Shadow properties
		this.params.showShadow = toBoolean(getFN(atts["showshadow"], 1));
		//Anchor Properties
		this.params.drawAnchors = toBoolean(getFN(atts["drawanchors"], atts["showanchors"], 1));
		this.params.anchorSides = getFN(atts["anchorsides"], 10);
		this.params.anchorRadius = getFN(atts["anchorradius"], 3);
		this.params.anchorBorderColor = formatColor(getFV(atts["anchorbordercolor"], this.params.lineColor));
		this.params.anchorBorderThickness = getFN(atts["anchorborderthickness"], 1);
		this.params.anchorBgColor = formatColor(getFV(atts["anchorbgcolor"], this.defColors.get2DAnchorBgColor(this.params.palette)));
		this.params.anchorAlpha = getFN(atts["anchoralpha"], 100);
		this.params.anchorBgAlpha = getFN(atts["anchorbgalpha"], this.params.anchorAlpha);
		//Tool Tip - Show/Hide, Background Color, Border Color, Separator Character
		this.params.showToolTip = toBoolean(getFN(atts["showtooltip"], atts["showhovercap"], 1));
		this.params.toolTipBgColor = formatColor(getFV(atts["tooltipbgcolor"], atts["hovercapbgcolor"], atts["hovercapbg"], this.defColors.get2DToolTipBgColor(this.params.palette)));
		this.params.toolTipBorderColor = formatColor(getFV(atts["tooltipbordercolor"], atts["hovercapbordercolor"], atts["hovercapborder"], this.defColors.get2DToolTipBorderColor(this.params.palette)));
		this.params.toolTipSepChar = getFV(atts["tooltipsepchar"], atts["hovercapsepchar"], ", ");
		//Font Properties
		this.params.baseFont = getFV(atts["basefont"], "Verdana");
		this.params.baseFontSize = getFN(atts["basefontsize"], 10);
		this.params.baseFontColor = formatColor(getFV(atts["basefontcolor"], this.defColors.get2DBaseFontColor(this.params.palette)));
		this.params.outCnvBaseFont = getFV(atts["outcnvbasefont"], this.params.baseFont);
		this.params.outCnvBaseFontSize = getFN(atts["outcnvbasefontsize"], this.params.baseFontSize);
		this.params.outCnvBaseFontColor = formatColor(getFV(atts["outcnvbasefontcolor"], this.params.baseFontColor));
		// ------------------------- NUMBER FORMATTING ---------------------------- //
		//Option whether the format the number (using Commas)
		this.params.formatNumber = toBoolean(getFN(atts["formatnumber"], 1));
		//Option to format number scale
		this.params.formatNumberScale = toBoolean(getFN(atts["formatnumberscale"], 1));
		//Number Scales
		this.params.defaultNumberScale = getFV(atts["defaultnumberscale"], "");
		this.params.numberScaleUnit = getFV(atts["numberscaleunit"], "K,M");
		this.params.numberScaleValue = getFV(atts["numberscalevalue"], "1000,1000");
		//Number prefix and suffix
		this.params.numberPrefix = getFV(atts["numberprefix"], "");
		this.params.numberSuffix = getFV(atts["numbersuffix"], "");
		//Decimal Separator Character
		this.params.decimalSeparator = getFV(atts["decimalseparator"], ".");
		//Thousand Separator Character
		this.params.thousandSeparator = getFV(atts["thousandseparator"], ",");
		//Input decimal separator and thousand separator. In some european countries,
		//commas are used as decimal separators and dots as thousand separators. In XML,
		//if the user specifies such values, it will give a error while converting to
		//number. So, we accept the input decimal and thousand separator from user, so that
		//we can covert it accordingly into the required format.
		this.params.inDecimalSeparator = getFV(atts["indecimalseparator"], "");
		this.params.inThousandSeparator = getFV(atts["inthousandseparator"], "");
		//Decimal Precision (number of decimal places to be rounded to)
		this.params.decimals = getFV(atts["decimals"], atts["decimalprecision"]);
		//Force Decimal Padding
		this.params.forceDecimals = toBoolean(getFN(atts["forcedecimals"], 0));
		//y-Axis values decimals
		this.params.yAxisValueDecimals = getFV(atts["yaxisvaluedecimals"], atts["yaxisvaluesdecimals"], atts["divlinedecimalprecision"], atts["limitsdecimalprecision"]);
		// ---------------------- Image Saving ------------------------------//
		this.params.imageSave = toBoolean (getFN (atts ["imagesave"] , 0));
		this.params.imageSaveURL = getFV (atts ["imagesaveurl"] , "");
		this.params.imageSaveDialogColor = formatColor (getFV (atts ["imagesavedialogcolor"] , "E2E2E2"));
		this.params.imageSaveDialogFontColor = formatColor (getFV (atts ["imagesavedialogfontcolor"] , "666666"));
	}
	/**
	 * getMaxDataValue method gets the maximum y-axis data value present
	 * in the data.
	 *	@returns	The maximum value present in the data provided.
	*/
	private function getMaxDataValue():Number {
		var maxValue:Number;
		var firstNumberFound:Boolean = false;
		var i:Number;
		for (i=1; i<=this.num; i++) {
			//By default assume the first non-null number to be maximum
			if (firstNumberFound == false) {
				if (this.data[i].isDefined == true) {
					//Set the flag that "We've found first non-null number".
					firstNumberFound = true;
					//Also assume this value to be maximum.
					maxValue = this.data[i].value;
				}
			} else {
				//If the first number has been found and the current data is defined, compare
				if (this.data[i].isDefined) {
					//Store the greater number
					maxValue = (this.data[i].value>maxValue) ? this.data[i].value : maxValue;
				}
			}
		}
		return maxValue;
	}
	/**
	 * getMinDataValue method gets the minimum y-axis data value present
	 * in the data
	 *	@reurns		The minimum value present in data
	*/
	private function getMinDataValue():Number {
		var minValue:Number;
		var firstNumberFound:Boolean = false;
		var i:Number;
		for (i=1; i<=this.num; i++) {
			//By default assume the first non-null number to be minimum
			if (firstNumberFound == false) {
				if (this.data[i].isDefined == true) {
					//Set the flag that "We've found first non-null number".
					firstNumberFound = true;
					//Also assume this value to be minimum.
					minValue = this.data[i].value;
				}
			} else {
				//If the first number has been found and the current data is defined, compare
				if (this.data[i].isDefined) {
					//Store the lesser number					
					minValue = (this.data[i].value<minValue) ? this.data[i].value : minValue;
				}
			}
		}
		return minValue;
	}
	/**
	* calculateAxisLimits method sets the axis limits for the chart.
	* It gets the minimum and maximum value specified in data and
	* based on that it calls super.getAxisLimits();
	*/
	private function calculateAxisLimits():Void {
		this.getAxisLimits(this.getMaxDataValue(), this.getMinDataValue(), false, !this.params.setAdaptiveYMin);
	}
	/**
	* setStyleDefaults method sets the default values for styles or
	* extracts information from the attributes and stores them into
	* style objects.
	*/
	private function setStyleDefaults():Void {
		//Default font object for Caption
		//-----------------------------------------------------------------//
		var captionFont = new StyleObject();
		captionFont.name = "_SdCaptionFont";
		captionFont.align = "center";
		captionFont.valign = "top";
		captionFont.bold = "1";
		captionFont.font = this.params.outCnvBaseFont;
		captionFont.size = this.params.outCnvBaseFontSize;
		captionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.CAPTION, captionFont, this.styleM.TYPE.FONT, null);
		delete captionFont;
		//-----------------------------------------------------------------//
		//Default font object for SubCaption
		//-----------------------------------------------------------------//
		var subCaptionFont = new StyleObject();
		subCaptionFont.name = "_SdSubCaptionFont";
		subCaptionFont.align = "center";
		subCaptionFont.valign = "top";
		subCaptionFont.bold = "1";
		subCaptionFont.font = this.params.outCnvBaseFont;
		subCaptionFont.size = this.params.outCnvBaseFontSize;
		subCaptionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.SUBCAPTION, subCaptionFont, this.styleM.TYPE.FONT, null);
		delete subCaptionFont;
		//-----------------------------------------------------------------//
		//Default font object for YAxisName
		//-----------------------------------------------------------------//
		var yAxisNameFont = new StyleObject();
		yAxisNameFont.name = "_SdYAxisNameFont";
		yAxisNameFont.align = "center";
		yAxisNameFont.valign = "middle";
		yAxisNameFont.bold = "1";
		yAxisNameFont.font = this.params.outCnvBaseFont;
		yAxisNameFont.size = this.params.outCnvBaseFontSize;
		yAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.YAXISNAME, yAxisNameFont, this.styleM.TYPE.FONT, null);
		delete yAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for XAxisName
		//-----------------------------------------------------------------//
		var xAxisNameFont = new StyleObject();
		xAxisNameFont.name = "_SdXAxisNameFont";
		xAxisNameFont.align = "center";
		xAxisNameFont.valign = "middle";
		xAxisNameFont.bold = "1";
		xAxisNameFont.font = this.params.outCnvBaseFont;
		xAxisNameFont.size = this.params.outCnvBaseFontSize;
		xAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.XAXISNAME, xAxisNameFont, this.styleM.TYPE.FONT, null);
		delete xAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for trend lines
		//-----------------------------------------------------------------//
		var trendFont = new StyleObject();
		trendFont.name = "_SdTrendFontFont";
		trendFont.font = this.params.outCnvBaseFont;
		trendFont.size = this.params.outCnvBaseFontSize;
		trendFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TRENDLINES, trendFont, this.styleM.TYPE.FONT, null);
		delete trendFont;
		//-----------------------------------------------------------------//
		//Default font object for yAxisValues
		//-----------------------------------------------------------------//
		var yAxisValuesFont = new StyleObject();
		yAxisValuesFont.name = "_SdYAxisValuesFont";
		yAxisValuesFont.align = "right";
		yAxisValuesFont.valign = "middle";
		yAxisValuesFont.font = this.params.outCnvBaseFont;
		yAxisValuesFont.size = this.params.outCnvBaseFontSize;
		yAxisValuesFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.YAXISVALUES, yAxisValuesFont, this.styleM.TYPE.FONT, null);
		delete yAxisValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for DataLabels
		//-----------------------------------------------------------------//
		var dataLabelsFont = new StyleObject();
		dataLabelsFont.name = "_SdDataLabelsFont";
		dataLabelsFont.align = "center";
		dataLabelsFont.valign = "bottom";
		dataLabelsFont.font = this.params.outCnvBaseFont;
		dataLabelsFont.size = this.params.outCnvBaseFontSize;
		dataLabelsFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.DATALABELS, dataLabelsFont, this.styleM.TYPE.FONT, null);
		delete dataLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for DataValues
		//-----------------------------------------------------------------//
		var dataValuesFont = new StyleObject();
		dataValuesFont.name = "_SdDataValuesFont";
		dataValuesFont.align = "center";
		dataValuesFont.valign = "middle";
		dataValuesFont.font = this.params.baseFont;
		dataValuesFont.size = this.params.baseFontSize;
		dataValuesFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.DATAVALUES, dataValuesFont, this.styleM.TYPE.FONT, null);
		delete dataValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for ToolTip
		//-----------------------------------------------------------------//
		var toolTipFont = new StyleObject();
		toolTipFont.name = "_SdToolTipFont";
		toolTipFont.font = this.params.baseFont;
		toolTipFont.size = this.params.baseFontSize;
		toolTipFont.color = this.params.baseFontColor;
		toolTipFont.bgcolor = this.params.toolTipBgColor;
		toolTipFont.bordercolor = this.params.toolTipBorderColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TOOLTIP, toolTipFont, this.styleM.TYPE.FONT, null);
		delete toolTipFont;
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for DataPlot
		//-----------------------------------------------------------------//
		if (this.params.showShadow) {
			var dataPlotShadow = new StyleObject();
			dataPlotShadow.name = "_SdDataPlotShadow";
			dataPlotShadow.angle = 45;
			//Over-ride         
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			delete dataPlotShadow;
		}
		//-----------------------------------------------------------------//                                                                                                                          
		//Default Animation object for DataPlot (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation) {
			//We need three animation objects.
			//1. XScale for data plot						
			var dataPlotAnim = new StyleObject();
			dataPlotAnim.name = "_SdDataPlotAnimXScale";
			dataPlotAnim.param = "_xscale";
			dataPlotAnim.easing = "regular";
			dataPlotAnim.wait = 0;
			dataPlotAnim.start = 0;
			dataPlotAnim.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotAnim, this.styleM.TYPE.ANIMATION, "_xscale");
			delete dataPlotAnim;
			//2. YScale for data plot
			var dataPlotAnimY = new StyleObject();
			dataPlotAnimY.name = "_SdDataPlotAnimYScale";
			dataPlotAnimY.param = "_yscale";
			dataPlotAnimY.easing = "regular";
			dataPlotAnimY.wait = 0.7;
			dataPlotAnimY.start = 0.1;
			dataPlotAnimY.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotAnimY, this.styleM.TYPE.ANIMATION, "_yscale");
			delete dataPlotAnimY;
			//3. Alpha effect for anchors				
			var anchorsAnim = new StyleObject();
			anchorsAnim.name = "_SdDataAnchorAnim";
			anchorsAnim.param = "_alpha";
			anchorsAnim.easing = "regular";
			anchorsAnim.wait = 0;
			anchorsAnim.start = 0;
			anchorsAnim.duration = 0.5;
			//Over-ride
			this.styleM.overrideStyle(this.objects.ANCHORS, anchorsAnim, this.styleM.TYPE.ANIMATION, "_alpha");
			delete anchorsAnim;
		}
		//-----------------------------------------------------------------//                                                                                                                              
	}
	/**
	 * calcVLinesPos method calculates the x position for the various
	 * vLines defined. Also, it validates them.
	*/
	private function calcVLinesPos() {
		var i:Number;
		//Iterate through all the vLines
		for (i=1; i<=numVLines; i++) {
			//If the vLine is after 1st data and before last data
			if (this.vLines[i].index>0 && this.vLines[i].index<this.num) {
				//Set it's x position
				this.vLines[i].x = this.data[this.vLines[i].index].x+(this.data[this.vLines[i].index+1].x-this.data[this.vLines[i].index].x)/2;
			} else {
				//Invalidate it
				this.vLines[i].isValid = false;
			}
		}
	}
	/**
	* calculatePoints method calculates the various points on the chart.
	*/
	private function calculatePoints() {
		//Loop variable
		var i:Number;
		//Always keep to a decimal precision of minimum 2 if the number 
		//scale is defined, as we've just checked for decimal precision of numbers
		//and not the numbers against number scale. So, even if they do not need yield a 
		//decimal, we keep 2, as we do not force decimals on numbers.
		if (this.config.numberScaleDefined == true) {
			maxDecimals = (maxDecimals>2) ? maxDecimals : 2;
		}
		//Get proper value for decimals                                                                                                                              
		this.params.decimals = Number(getFV(this.params.decimals, maxDecimals));
		//Decimal Precision cannot be less than 0 - so adjust it
		if (this.params.decimals<0) {
			this.params.decimals = 0;
		}
		//Get proper value for yAxisValueDecimals           
		this.params.yAxisValueDecimals = Number(getFV(this.params.yAxisValueDecimals, this.params.decimals));
		//Format all the numbers on the chart and store their display values
		//We format and store here itself, so that later, whenever needed,
		//we just access displayValue instead of formatting once again.
		//Also set tool tip text values
		var toolText:String;
		for (i=1; i<=this.num; i++) {
			//Format and store
			this.data[i].displayValue = formatNumber(this.data[i].value, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
			//Tool tip text
			//If labels have been defined
			toolText = (this.data[i].label != "") ? (this.data[i].label+this.params.toolTipSepChar) : "";
			toolText = toolText+this.data[i].displayValue;
			this.data[i].toolText = getFV(this.data[i].toolText, toolText);
		}
		//Based on label step, set showLabel of each data point as required.
		//Visible label count
		var visibleCount:Number = 0;
		var finalVisibleCount:Number = 0;
		//
		//We now need to calculate the available Width on the canvas.
		//Available width = total Chart width minus the list below
		// - Left and Right Margin
		// - yAxisName (if to be shown)
		// - yAxisValues
		// - Trend line display values (both left side and right side).
		var canvasWidth:Number = this.width-(this.params.chartLeftMargin+this.params.chartRightMargin);
		//Set canvas startX
		var canvasStartX:Number = this.params.chartLeftMargin;
		//Now, if y-axis name is to be shown, simulate it and get the width
		if (this.params.yAxisName != "") {
			//Get style object
			var yAxisNameStyle:Object = this.styleM.getTextStyle(this.objects.YAXISNAME);
			if (this.params.rotateYAxisName) {
				//Set embedded font - as we need to rotate
				yAxisNameStyle.font = _embeddedFont;
				//Un-bold and un-italicize
				yAxisNameStyle.bold = false;
				yAxisNameStyle.italic = false;
				//Create text field to get width
				var yAxisNameObj:Object = createText(true, this.params.yAxisName, this.tfTestMC, 1, testTFX, testTFY, 90, yAxisNameStyle, false, 0, 0);
				//Accomodate width and padding
				canvasStartX = canvasStartX+yAxisNameObj.width+this.params.yAxisNamePadding;
				canvasWidth = canvasWidth-yAxisNameObj.width-this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.yAxisName = returnDataAsElement(0, 0, yAxisNameObj.width, yAxisNameObj.height);
			} else {
				//If the y-axis name is not to be rotated
				//Calculate the width of the text if in full horizontal mode
				//Create text field to get width
				var yAxisNameObj:Object = createText(true, this.params.yAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, yAxisNameStyle, false, 0, 0);
				//Get a value for this.params.yAxisNameWidth
				this.params.yAxisNameWidth = Number(getFV(this.params.yAxisNameWidth, yAxisNameObj.width));
				//Get the lesser of the width (to avoid un-necessary space)				
				this.params.yAxisNameWidth = Math.min(this.params.yAxisNameWidth, yAxisNameObj.width);
				//Accomodate width and padding
				canvasStartX = canvasStartX+this.params.yAxisNameWidth+this.params.yAxisNamePadding;
				canvasWidth = canvasWidth-this.params.yAxisNameWidth-this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.yAxisName = returnDataAsElement(0, 0, this.params.yAxisNameWidth, yAxisNameObj.height);
			}
			delete yAxisNameStyle;
			delete yAxisNameObj;
		}
		//Accomodate width for y-axis values. Now, y-axis values conists of two parts                                                                                                                                   
		//(for backward compatibility) - limits (upper and lower) and div line values.
		//So, we'll have to individually run through both of them.
		var yAxisValMaxWidth:Number = 0;
		var divLineObj:Object;
		var divStyle:Object = this.styleM.getTextStyle(this.objects.YAXISVALUES);
		//Iterate through all the div line values
		for (i=1; i<this.divLines.length; i++) {
			//If div line value is to be shown
			if (this.divLines[i].showValue) {
				//If it's the first or last div Line (limits), and it's to be shown
				if ((i == 1) || (i == this.divLines.length-1)) {
					if (this.params.showLimits) {
						//Get the width of the text
						divLineObj = createText(true, this.divLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width>yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
					}
				} else {
					//It's a div interval - div line
					//So, check if we've to show div line values
					if (this.params.showDivLineValues) {
						//Get the width of the text
						divLineObj = createText(true, this.divLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width>yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
					}
				}
			}
		}
		delete divLineObj;
		//Also iterate through all trend lines whose values are to be shown on
		//left side of the canvas.
		//Get style object
		var trendStyle:Object = this.styleM.getTextStyle(this.objects.TRENDVALUES);
		var trendObj:Object;
		for (i=1; i<=this.numTrendLines; i++) {
			if (this.trendLines[i].isValid == true && this.trendLines[i].valueOnRight == false) {
				//If it's a valid trend line and value is to be shown on left
				//Get the width of the text
				trendObj = createText(true, this.trendLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				yAxisValMaxWidth = (trendObj.width>yAxisValMaxWidth) ? (trendObj.width) : (yAxisValMaxWidth);
			}
		}
		//Accomodate for y-axis/left-trend line values text width
		if (yAxisValMaxWidth>0) {
			canvasStartX = canvasStartX+yAxisValMaxWidth+this.params.yAxisValuesPadding;
			canvasWidth = canvasWidth-yAxisValMaxWidth-this.params.yAxisValuesPadding;
		}
		var trendRightWidth:Number = 0;
		//Now, also check for trend line values that fall on right
		for (i=1; i<=this.numTrendLines; i++) {
			if (this.trendLines[i].isValid == true && this.trendLines[i].valueOnRight == true) {
				//If it's a valid trend line and value is to be shown on right
				//Get the width of the text
				trendObj = createText(true, this.trendLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				trendRightWidth = (trendObj.width>trendRightWidth) ? (trendObj.width) : (trendRightWidth);
			}
		}
		delete trendObj;
		//Accomodate trend right text width
		if (trendRightWidth>0) {
			canvasWidth = canvasWidth-trendRightWidth-this.params.yAxisValuesPadding;
		}
		//Round them off finally to avoid distorted pixels                                                                                                                              
		canvasStartX = int(canvasStartX);
		canvasWidth = int(canvasWidth);
		//We finally have canvas Width and canvas Start X
		//-----------------------------------------------------------------------------------//
		//Now, we need to calculate the available Height on the canvas.
		//Available height = total Chart height minus the list below
		// - Chart Top and Bottom Margins
		// - Space for Caption, Sub Caption and caption padding
		// - Height of data labels
		// - xAxisName
		//Initialize canvasHeight to total height minus margins
		var canvasHeight:Number = this.height-(this.params.chartTopMargin+this.params.chartBottomMargin);
		//Set canvasStartY
		var canvasStartY:Number = this.params.chartTopMargin;
		//Now, if we've to show caption
		if (this.params.caption != "") {
			//Create text field to get height
			var captionObj:Object = createText(true, this.params.caption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.CAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+captionObj.height;
			canvasHeight = canvasHeight-captionObj.height;
			//Create element for caption - to store width & height
			this.elements.caption = returnDataAsElement(0, 0, captionObj.width, captionObj.height);
			delete captionObj;
		}
		//Now, if we've to show sub-caption                                                                                                                                   
		if (this.params.subCaption != "") {
			//Create text field to get height
			var subCaptionObj:Object = createText(true, this.params.subCaption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.SUBCAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+subCaptionObj.height;
			canvasHeight = canvasHeight-subCaptionObj.height;
			//Create element for sub caption - to store height
			this.elements.subCaption = returnDataAsElement(0, 0, subCaptionObj.width, subCaptionObj.height);
			delete subCaptionObj;
		}
		//Now, if either caption or sub-caption was shown, we also need to adjust caption padding                                                                                                                                   
		if (this.params.caption != "" || this.params.subCaption != "") {
			//Account for padding
			canvasStartY = canvasStartY+this.params.captionPadding;
			canvasHeight = canvasHeight-this.params.captionPadding;
		}
		//------------------------ K A G I    S P E C I F I C --------------------------------------//           
		//to find the range of values in the chart for use in calculating reversal value by percentage (optional)
		var valueMax:Number = Number.MIN_VALUE;
		var valueMin:Number = Number.MAX_VALUE;
		var valueData:Number;
		//looping to get the maximum and minimum of the plot values
		for (var i = 1; i<=this.num; i++) {
			valueData = this.data[i].value;
			valueMax = (valueMax<valueData) ? valueData : valueMax;
			valueMin = (valueMin>valueData) ? valueData : valueMin;
		}
		//setting the reversal value
		this.config.reversalValue = (this.params.reversalValue != -1) ? this.params.reversalValue : this.params.reversalPercentage*(valueMax-valueMin)/100;
		//storing in local variable
		var reversalValue:Number = this.config.reversalValue;
		//storing in local variable, the value of the maximum permissible for horizontal shift
		var maxHShiftPercent:Number = this.params.maxHShiftPercent;
		// boolean local variables declared
		var isRally:Boolean, isMovingUp:Boolean, isShift:Boolean, isRallyInitialised:Boolean;
		// number local variables declared
		var dataValue:Number, lastDataValue:Number, nextDataValue:Number, shiftLength:Number, shiftCounter:Number;
		var lastLow:Number, lastHigh:Number, lastPlotValue:Number, plotValue:Number;
		// string local variables declared
		var vAlign:String, align:String;
		// initialised to one to avoid zero dividing the width of the canvas (as the case may be) to get the xShiftLength
		shiftCounter = 1;
		//initialised by the first data value
		lastPlotValue = this.data[1].value;
		//first vertical point for shift is yet to be obtained
		isRallyInitialised = false;
		// local array created to retain the showLabel settings due xml
		var arrShowLabelId:Array = new Array();
		//looping over the full dataset
		for (var i:Number = 1; i<=this.num; i++) {
			//showLabel boolean value retained
			arrShowLabelId[i] = this.data[i].showLabel;
		}
		var insRef = this;
		//local function to set anchor and value visibility of unwanted points, after the first point
		//is found to draw vertical kagi line
		var setShowLabel:Function = function (id:Number, _isRally:Boolean) {
			//initial data value
			var data1Value:Number = insRef.data[1].value;
			//final (w.r.t. initial kagi movement) data value
			var dataFValue:Number = insRef.data[id].value;
			//looping to check for unwanted points
			for (var r:Number = 2; r<id; ++r) {
				//value of point under check
				var dataXValue:Number = insRef.data[r].value;
				//if current trend is rally
				if (_isRally) {
					if (dataXValue<=data1Value) {
						insRef.data[r].isDefined = false;
					}
					//else current trend is decline
				} else {
					if (dataXValue>=data1Value) {
						insRef.data[r].isDefined = false;
					}
				}
			}
			//setting alignment of value for the first data
			insRef.data[1].vAlign = (_isRally) ? 'bottom' : 'top';
			insRef.data[1].align = 'center';
		};
		//iterating to set values of properties in this.data for each respective point (main algorithm of KagiChart)
		//loop counter starts from 2 since data for plot 1 is unique
		for (var i:Number = 2; i<=this.num; i++) {
			//Few properties in this.data[i] is set to default values initially and will be conditionally changed.
			//set for all for now and will be retained for non-extreme (ie. maxima/minima) data only
			this.data[i].vAlign = 'middle';
			this.data[i].align = 'right';
			this.data[i].showLabel = false;
			//initialised to null each time
			plotValue = null;
			//data value of plot under current loop
			dataValue = this.data[i].value;
			//data value of previous plot
			lastDataValue = this.data[i-1].value;
			//data value of next plot
			nextDataValue = this.data[i+1].value;
			//if current plot is yet render the trend,then care is taken to make few initial assumptions as algorithm starts with it
			if (!isRallyInitialised) {
				//if current plot is higher than the last plotted one (first data) by significant amount
				if (dataValue>lastPlotValue && Math.abs(lastPlotValue-dataValue)>reversalValue) {
					//is assumed to be true
					isRally = true;
					//value of last low point of swing (assumed)
					lastLow = lastPlotValue;
					//none assumed
					lastHigh = null;
					//kagi rising
					isMovingUp = true;
					//first vertical point for shift is obtained
					isRallyInitialised = true;
					//call of local function to set visibility false for anchors and values of unwanted points
					setShowLabel(i, isRally);
					//if current plot is lower than the last plotted one (first data) by significant amount
				} else if (dataValue<lastPlotValue && Math.abs(lastPlotValue-dataValue)>reversalValue) {
					//is assumed to be false
					isRally = false;
					//none assumed
					lastLow = null;
					//value of last high point of swing (assumed)
					lastHigh = lastPlotValue;
					//kagi falling
					isMovingUp = false;
					//first vertical point for shift is obtained
					isRallyInitialised = true;
					//call of local function to set visibility false for anchors and values of unwanted points
					setShowLabel(i, isRally);
					// else, point under loop is not significant to draw the first vertical kagi line to
				} else {
					//is set to null
					isRally = null;
					//vertical shifting direction is set to null
					isMovingUp = null;
					//first vertical point for shift is yet to be obtained
					isRallyInitialised = false;
				}
				//trend property for plot 1 is set 
				this.data[i-1].isRally = isRally;
				if (isRally != null) {
					//to get the initial horizontal line in trend color (in case this.data[1].value = this.data[2].value = ... so on or not)
					this.data[1].isRally = isRally;
				}
				//else, for plot 3 and above, only trend is evaluated                 
			} else {
				//setting trends by concept of Kagi Chart
				if (dataValue<lastLow && isRally) {
					isRally = false;
				} else if (dataValue>lastHigh && !isRally) {
					isRally = true;
				}
				//else isRally remains unchanged
			}
			//setting in this.data for the plot
			this.data[i].isRally = isRally;
			//to check for having horizontal shift or not, we need to use the pertinent value
			if ((isMovingUp && dataValue<lastPlotValue) || (isMovingUp == false && dataValue>lastPlotValue)) {
				plotValue = lastPlotValue;
			}
			//to find if there is a horizontal shift associated with this plot                                                               
			var checkValue:Number = (plotValue) ? plotValue : dataValue;
			//if the line is static till now
			if (isMovingUp == null) {
				isShift = null;
				//if the line is rising
			} else if (isMovingUp) {
				isShift = (checkValue>nextDataValue && Math.abs(checkValue-nextDataValue)>=reversalValue) ? true : false;
				//else if the line is falling
			} else {
				isShift = (checkValue<nextDataValue && Math.abs(checkValue-nextDataValue)>=reversalValue) ? true : false;
			}
			//updating counter to have to total number of horizontal shifts in the total plot.This is vital for calculation
			//of the length of each horizontal shifts.
			shiftCounter += (isShift) ? 1 : 0;
			//To get the last extremes preceding the current point and setting the vertical/horizontal
			//alignment of the value to be shown for it.
			if (this.data[i-1].isShift) {
				if (isMovingUp) {
					lastLow = lastPlotValue;
					vAlign = 'bottom';
				} else if (!isMovingUp) {
					lastHigh = lastPlotValue;
					vAlign = 'top';
				}
				align = 'center';
				//looping to get the actual plot corresponding to the maxima/minima and setting label properties for the same
				for (var t:Number = i; t>1; t--) {
					if (this.data[t].value == lastPlotValue) {
						this.data[t].vAlign = vAlign;
						this.data[t].align = align;
						this.data[t].showLabel = true;
						//extreme obtained and thus stop looping
						break;
					}
				}
			}
			//if there is a horizontal shift, then                                                                          
			if (isShift) {
				//updating the flag by reversing the boolean value of the flag itself
				isMovingUp = (!isMovingUp);
				//setting in this.data for the plot, to be used for drawing the graph
				this.data[i].isShift = true;
				//updating last plotting value
				lastPlotValue = checkValue;
				//if current data value is ahead w.r.t. the status of 'isMovingUp'
			} else if ((isMovingUp && dataValue>lastPlotValue) || (isMovingUp == false && dataValue<lastPlotValue)) {
				//updating last plotting value
				lastPlotValue = dataValue;
				//if cuurent data value is to be skipped for plotting
			} else {
				//setting the value to be plotted (virtually drawing pen stays still due to this)
				plotValue = lastPlotValue;
			}
			//plotValue assigned is either defined or set to null
			this.data[i].plotValue = plotValue;
			//few local variables are bundled together in an object to be used later-on to work around a Catch-22 problem
			this.data[i].objParams = {isRally:isRally, lastHigh:lastHigh, lastLow:lastLow, isRallyInitialised:isRallyInitialised};
		}
		//label of first data should never show up
		this.data[1].showLabel = false;
		//label of last data should always show up
		this.data[this.num].showLabel = true;
		//checking for labels not to be shown (for only those to be shown by default ... extremes)
		for (var i:Number = 1; i<=this.num; i++) {
			if (this.data[i].showLabel) {
				this.data[i].showLabel = arrShowLabelId[i];
			}
		}
		//the maximum number of the labels that can be shown which is equal to the number of vertical kagi lines in the chart
		finalVisibleCount = shiftCounter;
		//--------------------------------------------------------------------------------------//
		//Now, if data labels are to be shown, we need to account for their heights                                                                                                                        
		//Data labels can be rendered in 3 ways:
		//1. Normal - no staggering - no wrapping - no rotation
		//2. Wrapped - no staggering - no rotation
		//3. Staggered - no wrapping - no rotation
		//4. Rotated - no staggering - no wrapping
		//Placeholder to store max height
		this.config.maxLabelHeight = 0;
		this.config.labelAreaHeight = 0;
		var labelObj:Object;
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
		if (this.params.labelDisplay == "ROTATE") {
			//Case 4: If the labels are rotated, we iterate through all the string labels
			//provided to us and get the height and store max.
			for (i=1; i<=this.num; i++) {
				//If the label is to be shown
				if (this.data[i].showLabel) {
					//Set style bold/italic to false and font to embedded font
					labelStyleObj.font = _embeddedFont;
					labelStyleObj.bold = false;
					labelStyleObj.italic = false;
					//Create text box and get height
					labelObj = createText(true, this.data[i].label, this.tfTestMC, 1, testTFX, testTFY, this.config.labelAngle, labelStyleObj, false, 0, 0);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else if (this.params.labelDisplay == "WRAP") {
			//Case 2 (WRAP): Create all the labels on the chart. Set width as
			//totalAvailableWidth/finalVisibleCount.
			//Set max height as 50% of available canvas height at this point of time. Find all
			//and select the max one.
			var maxLabelWidth:Number = ((canvasWidth-(2*this.params.canvasPadding))/finalVisibleCount);
			var maxLabelHeight:Number = (canvasHeight/2);
			//Store it in config for later usage
			this.config.wrapLabelWidth = maxLabelWidth;
			this.config.wrapLabelHeight = maxLabelHeight;
			for (i=1; i<=this.num; i++) {
				//If the label is to be shown
				if (this.data[i].showLabel) {
					//Create text box and get height
					labelObj = createText(true, this.data[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, true, maxLabelWidth, maxLabelHeight);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else {
			//Case 1,3: Normal or Staggered Label
			//We iterate through all the labels, and if any of them has &lt or < (HTML marker)
			//embedded in them, we add them to the array, as for them, we'll need to individually
			//create and see the text height. Also, the first element in the array - we set as
			//ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=....
			//Create array to store labels.
			var strLabels:Array = new Array();
			strLabels.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=/*-+~`");
			//Now, iterate through all the labels and for those visible labels, whcih have < sign,
			//add it to array.
			for (i=1; i<=this.num; i++) {
				//If the label is to be shown
				if (this.data[i].showLabel) {
					if ((this.data[i].label.indexOf("&lt;")>-1) || (this.data[i].label.indexOf("<")>-1)) {
						strLabels.push(this.data[i].label);
					}
				}
			}
			//Now, we've the array for which we've to check height (for each element).
			for (i=0; i<strLabels.length; i++) {
				//Create text box and get height
				labelObj = createText(true, this.data[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, false, 0, 0);
				//Store the larger
				this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
			}
			//We now have the max label height. If it's staggered, then store accordingly, else
			//simple mode
			if (this.params.labelDisplay == "STAGGER") {
				//Multiply max label height by stagger lines.
				this.config.labelAreaHeight = this.params.staggerLines*this.config.maxLabelHeight;
			} else {
				this.config.labelAreaHeight = this.config.maxLabelHeight;
			}
		}
		if (this.config.labelAreaHeight>0) {
			//Deduct the calculated label height from canvas height
			canvasHeight = canvasHeight-this.config.labelAreaHeight-this.params.labelPadding;
		}
		//Delete objects                                                                                                                                 
		delete labelObj;
		delete labelStyleObj;
		//Accomodate space for xAxisName (if to be shown);
		if (this.params.xAxisName != "") {
			//Create text field to get height
			var xAxisNameObj:Object = createText(true, this.params.xAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.XAXISNAME), false, 0, 0);
			//Store the height
			canvasHeight = canvasHeight-xAxisNameObj.height-this.params.xAxisNamePadding;
			//Object to store width and height of xAxisName
			this.elements.xAxisName = returnDataAsElement(0, 0, xAxisNameObj.width, xAxisNameObj.height);
			delete xAxisNameObj;
		}
		//We now finally have canvas start Y and canvas height                                                                                                                                   
		//Create an element to represent the canvas now.
		this.elements.canvas = returnDataAsElement(canvasStartX, canvasStartY, canvasWidth, canvasHeight);
		//We now need to calculate the position of lines on the chart.
		//Now, calculate the width between two points on chart
		var interPointWidth:Number = (this.elements.canvas.w-(2*this.params.canvasPadding))/(this.num-1);
		//------------------------ K A G I    S P E C I F I C --------------------------------------// 
		//working around the Catch-22 problem by this looping
		for (var i:Number = 2; i<=this.num; i++) {
			//getting the previously bundled up properties in local variables
			isRally = this.data[i].objParams.isRally;
			lastHigh = this.data[i].objParams.lastHigh;
			lastLow = this.data[i].objParams.lastLow;
			isRallyInitialised = this.data[i].objParams.isRallyInitialised;
			//to find if there is a change in trend towards the current plot
			if (this.data[i-1].isRally != this.data[i].isRally && isRallyInitialised) {
				//setting in this.data for the plot, to be used for setting the color/thickness the graph segments
				this.data[i].isChanged = true;
				//to get the pixel position of the transtion point and storing in this.data for the plot
				if (isRally) {
					this.data[i].ty = this.getAxisPosition(lastHigh, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
				} else {
					this.data[i].ty = this.getAxisPosition(lastLow, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
				}
				//if there is no change in trend
			} else {
				//setting in this.data for the plot
				this.data[i].isChanged = false;
			}
		}
		//calculating the actual width of the canvas available for plotting the graph
		var effectiveCanvasWidth:Number = this.elements.canvas.w-2*this.params.canvasPadding;
		//calculating the length of the horizontal shifts overriding the default as the case may be
		this.config.xShiftLength = Math.min(effectiveCanvasWidth/shiftCounter, maxHShiftPercent*effectiveCanvasWidth/100);
		//initial drawing pen's abscissa
		var xLine:Number = this.elements.canvas.x+this.params.canvasPadding+this.config.xShiftLength/2;
		//Now, store the positions of the plots
		for (i=1; i<=this.num; i++) {
			//getting appropiate value for the current plot point
			plotValue = (this.data[i].plotValue != null) ? this.data[i].plotValue : this.data[i].value;
			//Set the y position
			this.data[i].y = this.getAxisPosition(plotValue, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
			//Store value textbox y position
			this.data[i].valTBY = this.getAxisPosition(this.data[i].value, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
			//ordinate of the anchor
			this.data[i].anchorY = this.data[i].valTBY;
			//abscissa of the point on the kagi line
			this.data[i].x = xLine;
			//if there is a horizontal shift, then abscissa of the kagi line and as such all points on it shifts to the right by a slab more
			if (this.data[i].isShift) {
				xLine += this.config.xShiftLength;
			}
		}
		//to find the coordinate centre of all the plot points to be used in initial animation
		var yMax:Number = Number.MIN_VALUE;
		var yMin:Number = Number.MAX_VALUE;
		var xMax:Number, xMin:Number, dataY:Number;
		//looping to get the maximum and minimum of the plot ordinates
		for (var i = 1; i<=this.num; i++) {
			dataY = this.data[i].y;
			yMax = (yMax<dataY) ? dataY : yMax;
			yMin = (yMin>dataY) ? dataY : yMin;
		}
		//minimum plot abscissa
		xMin = this.data[1].x;
		//maximum plot abscissa
		xMax = this.data[this.num].x;
		//storing in config
		this.config.centerY = (yMin+yMax)/2;
		this.config.centerX = (xMin+xMax)/2;
	}
	/**
	 * allotDepths method allots the depths for various chart objects
	 * to be rendered. We do this before hand, so that we can later just
	 * go on rendering chart objects, without swapping.
	*/
	private function allotDepths():Void {
		//Background
		this.dm.reserveDepths("BACKGROUND", 1);
		//Click URL Handler
		this.dm.reserveDepths("CLICKURLHANDLER", 1);
		//Background SWF
		this.dm.reserveDepths("BGSWF", 1);
		//Canvas
		this.dm.reserveDepths("CANVAS", 1);
		//If vertical grid is to be shown
		if (this.params.showAlternateVGridColor) {
			this.dm.reserveDepths("VGRID", Math.ceil((this.params.numVDivLines+1)/2));
		}
		//If horizontal grid is to be shown                                                                                                                              
		if (this.params.showAlternateHGridColor) {
			this.dm.reserveDepths("HGRID", Math.ceil((this.divLines.length+1)/2));
		}
		//Vertical Div Lines                                                                                                                              
		this.dm.reserveDepths("VDIVLINES", this.params.numVDivLines);
		//Div Lines and their labels
		this.dm.reserveDepths("DIVLINES", (this.divLines.length*2));
		//Zero Plane
		this.dm.reserveDepths("ZEROPLANE", 2);
		//Caption
		this.dm.reserveDepths("CAPTION", 1);
		//Sub-caption
		this.dm.reserveDepths("SUBCAPTION", 1);
		//X-Axis Name
		this.dm.reserveDepths("XAXISNAME", 1);
		//Y-Axis Name
		this.dm.reserveDepths("YAXISNAME", 1);
		//Trend lines below plot (lines and their labels)
		this.dm.reserveDepths("TRENDLINESBELOW", this.numTrendLinesBelow);
		this.dm.reserveDepths("TRENDVALUESBELOW", this.numTrendLinesBelow);
		//Data Labels
		this.dm.reserveDepths("DATALABELS", this.num);
		//Line Chart
		this.dm.reserveDepths("DATAPLOT", 1);
		//Vertical div lines
		this.dm.reserveDepths("VLINES", this.numVLines);
		//Canvas Border
		this.dm.reserveDepths("CANVASBORDER", 1);
		//Anchors
		this.dm.reserveDepths("ANCHORS", this.num);
		//Trend lines below plot (lines and their labels)
		this.dm.reserveDepths("TRENDLINESABOVE", (this.numTrendLines-this.numTrendLinesBelow));
		this.dm.reserveDepths("TRENDVALUESABOVE", (this.numTrendLines-this.numTrendLinesBelow));
		//Data Values
		this.dm.reserveDepths("DATAVALUES", this.num);
	}
	//--------------- VISUAL RENDERING METHODS -------------------------//
	/**
	 * drawKagiChart method draws the lines on the chart
	*/
	private function drawKagiChart():Void {
		/** 
		 * The movie clip structure for a kagi chart would be :
		 * |- Holder
		 * |- |- Chart
		 * We create child movie clip as we need to animate xscale
		 * and y scale. So, we need to position Chart Movie clip at 0,0
		 * inside holder movie clip and then readjust Holder movie clip's
		 * X and Y Position as per chart's canvas.
		*/
		var lineColor:Number, lineThickness:Number, yLine:Number, xLine:Number, xLineIni:Number;
		//storing line cosmetics in local variables
		var rallyColor:Number = parseInt(this.params.rallyColor, 16);
		var declineColor:Number = parseInt(this.params.declineColor, 16);
		var rallyThickness:Number = this.params.rallyThickness;
		var declineThickness:Number = this.params.declineThickness;
		//Create holder movie clip
		var holderMC:MovieClip = this.cMC.createEmptyMovieClip("ChartHolder", this.dm.getDepth("DATAPLOT"));
		//for central alignment of the mc w.r.t. registration point
		holderMC._x += this.config.centerX;
		holderMC._y += this.config.centerY;
		//Create chart movie clip inside holder movie clip
		var chartMC:MovieClip = holderMC.createEmptyMovieClip("Chart", 1);
		//for central alignment of the mc w.r.t. registration point
		chartMC._x -= this.config.centerX;
		chartMC._y -= this.config.centerY;
		//----------------------------------------------------------------//
		//setting line cosmetics for chart initialisation 
		lineColor = (this.data[1].isRally) ? rallyColor : declineColor;
		lineThickness = (this.data[1].isRally) ? rallyThickness : declineThickness;
		chartMC.lineStyle(lineThickness, lineColor, 100);
		//coordinates of the initial point
		xLine = this.elements.canvas.x+this.params.canvasPadding+this.config.xShiftLength/2;
		yLine = this.data[1].y;
		//drawing starts with an initial half horizontal-shift
		chartMC.moveTo(this.elements.canvas.x+this.params.canvasPadding, yLine);
		chartMC.lineTo(xLine, yLine);
		//looping to draw the plots
		for (var i = 1; i<this.num; i++) {
			chartMC.moveTo(xLine, yLine);
			//if there is a shift corresponding to this point
			if (this.data[i].isShift) {
				//getting line cosmetics
				lineColor = (this.data[i].isRally) ? rallyColor : declineColor;
				lineThickness = (this.data[i].isRally) ? rallyThickness : declineThickness;
				//setting line cosmetics
				chartMC.lineStyle(lineThickness, lineColor, 100);
				//retaining xLine value
				xLineIni = xLine;
				//updating xLine value
				xLine += this.config.xShiftLength;
				yLine = this.data[i].y;
				//if line to be drawn need to be dashed
				if (this.data[i+1].dashed) {
					//Draw a dashed line
					DrawingExt.dashTo(chartMC, xLineIni, yLine, xLine, yLine, this.params.lineDashLen, this.params.lineDashGap);
					//else, draw a simple continous line
				} else {
					chartMC.lineTo(xLine, yLine);
				}
			}
			//if there is a change in trend between the current and the next points    
			if (this.data[i+1].isChanged) {
				//getting line cosmetics
				lineColor = (this.data[i].isRally) ? rallyColor : declineColor;
				lineThickness = (this.data[i].isRally) ? rallyThickness : declineThickness;
				//setting line cosmetics
				chartMC.lineStyle(lineThickness, lineColor, 100);
				//if line to be drawn need to be dashed
				if (this.data[i+1].dashed) {
					//Draw a dashed line
					DrawingExt.dashTo(chartMC, xLine, yLine, xLine, this.data[i+1].ty, this.params.lineDashLen, this.params.lineDashGap);
					//else, draw a simple continous line
				} else {
					chartMC.lineTo(xLine, this.data[i+1].ty);
				}
				//updating the local variable with the latest line ordinate
				yLine = this.data[i+1].ty;
			}
			//getting line cosmetics    
			lineColor = (this.data[i+1].isRally) ? rallyColor : declineColor;
			lineThickness = (this.data[i+1].isRally) ? rallyThickness : declineThickness;
			//setting line cosmetics
			chartMC.lineStyle(lineThickness, lineColor, 100);
			//if line to be drawn need to be dashed
			if (this.data[i+1].dashed) {
				//Draw a dashed line
				DrawingExt.dashTo(chartMC, xLine, yLine, xLine, this.data[i+1].y, this.params.lineDashLen, this.params.lineDashGap);
				//else, draw a simple continous line
			} else {
				chartMC.lineTo(xLine, this.data[i+1].y);
			}
			//updating value
			yLine = this.data[i+1].y;
		}
		//Apply filter
		this.styleM.applyFilters(holderMC, this.objects.DATAPLOT);
		//Apply animation
		if (this.params.animation) {
			this.styleM.applyAnimation(holderMC, this.objects.DATAPLOT, this.macro, holderMC._x, 0, holderMC._y, 0, 100, 100, 100, null);
		}
		//----------------------------------------------------------------//                              
		//Clear interval    
		clearInterval(this.config.intervals.plot);
	}
	/**
	* drawHeaders method renders the following on the chart:
	* CAPTION, SUBCAPTION, XAXISNAME, YAXISNAME
	*/
	private function drawHeaders() {
		//Render caption
		if (this.params.caption != "") {
			var captionStyleObj:Object = this.styleM.getTextStyle(this.objects.CAPTION);
			captionStyleObj.align = "center";
			captionStyleObj.vAlign = "bottom";
			var captionObj:Object = createText(false, this.params.caption, this.cMC, this.dm.getDepth("CAPTION"), this.elements.canvas.x+(this.elements.canvas.w/2), this.params.chartTopMargin, 0, captionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(captionObj.tf, this.objects.CAPTION, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.caption.w/2), 0, this.params.chartTopMargin, 0, 100, null, null, null);
			}
			//Apply filters                                                                                                                                   
			this.styleM.applyFilters(captionObj.tf, this.objects.CAPTION);
			//Delete
			delete captionObj;
			delete captionStyleObj;
		}
		//Render sub caption                                                                                                                                   
		if (this.params.subCaption != "") {
			var subCaptionStyleObj:Object = this.styleM.getTextStyle(this.objects.SUBCAPTION);
			subCaptionStyleObj.align = "center";
			subCaptionStyleObj.vAlign = "top";
			var subCaptionObj:Object = createText(false, this.params.subCaption, this.cMC, this.dm.getDepth("SUBCAPTION"), this.elements.canvas.x+(this.elements.canvas.w/2), this.elements.canvas.y-this.params.captionPadding, 0, subCaptionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(subCaptionObj.tf, this.objects.SUBCAPTION, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.subCaption.w/2), 0, this.elements.canvas.y-this.params.captionPadding-this.elements.subCaption.h, 0, 100, null, null, null);
			}
			//Apply filters                                                                                                                                   
			this.styleM.applyFilters(subCaptionObj.tf, this.objects.SUBCAPTION);
			//Delete
			delete subCaptionObj;
			delete subCaptionStyleObj;
		}
		//Render x-axis name                                                                                                                                   
		if (this.params.xAxisName != "") {
			var xAxisNameStyleObj:Object = this.styleM.getTextStyle(this.objects.XAXISNAME);
			xAxisNameStyleObj.align = "center";
			xAxisNameStyleObj.vAlign = "bottom";
			var xAxisNameObj:Object = createText(false, this.params.xAxisName, this.cMC, this.dm.getDepth("XAXISNAME"), this.elements.canvas.x+(this.elements.canvas.w/2), this.elements.canvas.toY+this.params.labelPadding+this.config.labelAreaHeight+this.params.xAxisNamePadding, 0, xAxisNameStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(xAxisNameObj.tf, this.objects.XAXISNAME, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.subCaption.w/2), 0, this.elements.canvas.toY+this.config.labelAreaHeight+this.params.xAxisNamePadding, 0, 100, null, null, null);
			}
			//Apply filters                                                                                                                                   
			this.styleM.applyFilters(xAxisNameObj.tf, this.objects.XAXISNAME);
			//Delete
			delete xAxisNameObj;
			delete xAxisNameStyleObj;
		}
		//Render y-axis name                                                                                                                                   
		if (this.params.yAxisName != "") {
			var yAxisNameStyleObj:Object = this.styleM.getTextStyle(this.objects.YAXISNAME);
			//Set alignment parameters
			yAxisNameStyleObj.align = "left";
			yAxisNameStyleObj.vAlign = "middle";
			//If the name is to be rotated
			if (this.params.rotateYAxisName) {
				//Set font as the embedded font
				yAxisNameStyleObj.font = _embeddedFont;
				//Set bold/italic to false.
				yAxisNameStyleObj.bold = false;
				yAxisNameStyleObj.italic = false;
				var yAxisNameObj:Object = createText(false, this.params.yAxisName, this.cMC, this.dm.getDepth("YAXISNAME"), this.params.chartLeftMargin, this.elements.canvas.y+(this.elements.canvas.h/2), 270, yAxisNameStyleObj, false, 0, 0);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.params.chartLeftMargin, 0, this.elements.canvas.y+(this.elements.canvas.h/2)+(this.elements.yAxisName.h/2), 0, 100, null, null, null);
				}
			} else {
				//We show horizontal name
				//Adding 1 to this.params.yAxisNameWidth and then passing to avoid line breaks				
				var yAxisNameObj:Object = createText(false, this.params.yAxisName, this.cMC, this.dm.getDepth("YAXISNAME"), this.params.chartLeftMargin, this.elements.canvas.y+(this.elements.canvas.h/2), 0, yAxisNameStyleObj, true, this.params.yAxisNameWidth+1, this.elements.canvas.h);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.params.chartLeftMargin, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}
			//Apply filters     
			this.styleM.applyFilters(yAxisNameObj.tf, this.objects.YAXISNAME);
			//Delete
			delete yAxisNameObj;
			delete yAxisNameStyleObj;
		}
		//Clear Interval                                                                                                                                   
		clearInterval(this.config.intervals.headers);
	}
	/**
	* drawLabels method draws the x-axis labels based on the oarameters.
	*/
	private function drawLabels() {
		var labelObj:Object;
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
		var labelYShift:Number;
		var staggerCycle:Number = 0;
		var staggerAddFn:Number = 1;
		var depth:Number = this.dm.getDepth("DATALABELS");
		var i:Number;
		for (i=1; i<=this.num; i++) {
			//If the label is to be shown
			if (this.data[i].showLabel) {
				if (this.params.labelDisplay == "ROTATE") {
					//Set style bold/italic to false and font to embedded font
					labelStyleObj.font = _embeddedFont;
					labelStyleObj.bold = false;
					labelStyleObj.italic = false;
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Create text box and get height
					labelObj = createText(false, this.data[i].label, this.cMC, depth, this.data[i].x, this.elements.canvas.toY+this.params.labelPadding, this.config.labelAngle, labelStyleObj, false, 0, 0);
				} else if (this.params.labelDisplay == "WRAP") {
					//Case 2 (WRAP)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText(false, this.data[i].label, this.cMC, depth, this.data[i].x, this.elements.canvas.toY+this.params.labelPadding, 0, labelStyleObj, true, this.config.wrapLabelWidth, this.config.wrapLabelHeight);
				} else if (this.params.labelDisplay == "STAGGER") {
					//Case 3 (Stagger)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Need to get cyclic position for staggered textboxes
					//Matrix formed is of 2*this.params.staggerLines - 2 rows
					var pos:Number = i%(2*this.params.staggerLines-2);
					//Last element needs to be reset
					pos = (pos == 0) ? (2*this.params.staggerLines-2) : pos;
					//Cyclic iteration
					pos = (pos>this.params.staggerLines) ? (this.params.staggerLines-(pos%this.params.staggerLines)) : pos;
					//Get position to 0 base
					pos--;
					//Shift accordingly
					var labelYShift:Number = this.config.maxLabelHeight*pos;
					labelObj = createText(false, this.data[i].label, this.cMC, depth, this.data[i].x, this.elements.canvas.toY+this.params.labelPadding+labelYShift, 0, labelStyleObj, false, 0, 0);
				} else {
					//Render normal label
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText(false, this.data[i].label, this.cMC, depth, this.data[i].x, this.elements.canvas.toY+this.params.labelPadding, 0, labelStyleObj, false, 0, 0);
				}
				//Apply filter
				this.styleM.applyFilters(labelObj.tf, this.objects.DATALABELS);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(labelObj.tf, this.objects.DATALABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
				}
				//Increase depth                                                      
				depth++;
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.labels);
	}
	/**
	 * drawAnchors method draws the anchors on the chart
	*/
	private function drawAnchors():Void {
		//If the anchors are to be drawn
		if (this.params.drawAnchors) {
			//Variables
			var anchorMC:MovieClip;
			var depth:Number = this.dm.getDepth("ANCHORS");
			var i:Number;
			//Create function storage containers for Delegate functions
			var fnRollOver:Function, fnClick:Function;
			//Iterate through all columns
			for (i=1; i<=this.num; i++) {
				//If defined
				if (this.data[i].isDefined) {
					//Create an empty movie clip for this anchor
					anchorMC = this.cMC.createEmptyMovieClip("Anchor_"+i, depth);
					//Set the line style and fill
					anchorMC.lineStyle(this.data[i].anchorBorderThickness, parseInt(this.data[i].anchorBorderColor, 16), 100);
					anchorMC.beginFill(parseInt(this.data[i].anchorBgColor, 16), this.data[i].anchorBgAlpha);
					//Draw the polygon
					DrawingExt.drawPoly(anchorMC, 0, 0, this.data[i].anchorSides, this.data[i].anchorRadius, 90);
					//Set the x and y Position
					anchorMC._x = this.data[i].x;
					anchorMC._y = this.data[i].anchorY;
					//Set the alpha of entire anchor
					anchorMC._alpha = this.data[i].anchorAlpha;
					//Apply animation
					if (this.params.animation) {
						this.styleM.applyAnimation(anchorMC, this.objects.ANCHORS, this.macro, anchorMC._x, 0, anchorMC._y, 0, this.data[i].anchorAlpha, 100, 100, null);
					}
					//Apply filters                                                         
					this.styleM.applyFilters(anchorMC, this.objects.ANCHORS);
					//Event handlers for tool tip
					if (this.params.showToolTip) {
						//Create Delegate for roll over function columnOnRollOver
						fnRollOver = Delegate.create(this, dataOnRollOver);
						//Set the index
						fnRollOver.index = i;
						//Assing the delegates to movie clip handler
						anchorMC.onRollOver = fnRollOver;
						//Set roll out and mouse move too.
						anchorMC.onRollOut = anchorMC.onReleaseOutside=Delegate.create(this, dataOnRollOut);
					}
					//Click handler for links - only if link for this anchor has been defined and click URL                                                    
					//has not been defined.
					if (this.data[i].link != "" && this.data[i].link != undefined && this.params.clickURL == "") {
						//Create delegate function
						fnClick = Delegate.create(this, dataOnClick);
						//Set index
						fnClick.index = i;
						//Assign
						anchorMC.onRelease = fnClick;
					} else {
						//Do not use hand cursor
						anchorMC.useHandCursor = (this.params.clickURL == "") ? false : true;
					}
					//Increase depth
					depth++;
				}
			}
		}
		//Clear interval                                                    
		clearInterval(this.config.intervals.anchors);
	}
	/**
	 * drawValues method draws the values on the chart.
	*/
	private function drawValues():Void {
		//Get value text style
		var valueStyleObj:Object = this.styleM.getTextStyle(this.objects.DATAVALUES);
		//Individual properties
		var isBold:Boolean = valueStyleObj.bold;
		var isItalic:Boolean = valueStyleObj.italic;
		var font:String = valueStyleObj.font;
		var angle:Number = 0;
		//Container object
		var valueObj:MovieClip;
		//Depth
		var depth:Number = this.dm.getDepth("DATAVALUES");
		//Loop var
		var i:Number;
		var xPos:Number, yPos:Number;
		var align:String, vAlign:String;
		////Iterate through all points
		for (i=1; i<=this.num; i++) {
			//If defined and value is to be shown
			if (this.data[i].isDefined && this.data[i].showValue) {
				xPos = this.data[i].x;
				//Get the y position based on next data's position				
				if (this.data[i].vAlign == 'top') {
					yPos = this.data[i].valTBY-this.params.valuePadding;
				} else if (this.data[i].vAlign == 'bottom') {
					yPos = this.data[i].valTBY+this.params.valuePadding;
				} else {
					xPos -= this.data[i].anchorRadius/2;
					yPos = this.data[i].valTBY;
				}
				//Convey alignment to rendering object
				valueStyleObj.align = this.data[i].align;
				valueStyleObj.vAlign = this.data[i].vAlign;
				//Now, if the labels are to be rotated
				if (this.params.rotateValues) {
					valueStyleObj.bold = false;
					valueStyleObj.italic = false;
					valueStyleObj.font = _embeddedFont;
					angle = 270;
				} else {
					//Normal horizontal label - Store original properties
					valueStyleObj.bold = isBold;
					valueStyleObj.italic = isItalic;
					valueStyleObj.font = font;
					angle = 0;
				}
				valueObj = createText(false, this.data[i].displayValue, this.cMC, depth, xPos, yPos, angle, valueStyleObj, false, 0, 0);
				//Apply filter                             
				this.styleM.applyFilters(valueObj.tf, this.objects.DATAVALUES);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(valueObj.tf, this.objects.DATAVALUES, this.macro, valueObj.tf._x, 0, valueObj.tf._y, 0, 100, null, null, null);
				}
				//Increase depth                                                            
				depth++;
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.dataValues);
	}
	/**
	 * drawVDivLines method draws the vertical div lines on the chart
	*/
	private function drawVDivLines():Void {
		var yPos:Number;
		var depth:Number = this.dm.getDepth("VDIVLINES");
		//Movie clip container
		var vDivLineMC:MovieClip;
		//Get the horizontal spacing between two vertical div lines
		//We have to accomodate the canvas padding here.
		var horSpace:Number = (this.elements.canvas.w-(2*this.params.canvasPadding))/(this.params.numVDivLines+1);
		//Get x position - add left side canvas padding
		var xPos:Number = this.elements.canvas.x+this.params.canvasPadding;
		var i:Number;
		for (i=1; i<=this.params.numVDivLines; i++) {
			//Get x position
			xPos = xPos+horSpace;
			//Create the movie clip			
			vDivLineMC = this.cMC.createEmptyMovieClip("vDivLine_"+i, depth);
			//Draw the line
			vDivLineMC.lineStyle(this.params.vDivLineThickness, parseInt(this.params.vDivLineColor, 16), this.params.vDivLineAlpha);
			if (this.params.vDivLineIsDashed) {
				//Dashed line
				DrawingExt.dashTo(vDivLineMC, 0, -this.elements.canvas.h/2, 0, this.elements.canvas.h/2, this.params.vDivLineDashLen, this.params.vDivLineDashGap);
			} else {
				//Draw the line keeping 0,0 as registration point
				vDivLineMC.moveTo(0, -this.elements.canvas.h/2);
				//Normal line
				vDivLineMC.lineTo(0, this.elements.canvas.h/2);
			}
			//Re-position the div line to required place
			vDivLineMC._x = xPos;
			vDivLineMC._y = this.elements.canvas.y+(this.elements.canvas.h/2);
			//Apply animation and filter effects to vertical div line
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(vDivLineMC, this.objects.VDIVLINES, this.macro, vDivLineMC._x, 0, null, 0, 100, null, 100, null);
			}
			//Apply filters                                                                                                                                                                                                                         
			this.styleM.applyFilters(vDivLineMC, this.objects.VDIVLINES);
			//Increment depth
			depth++;
		}
		//Clear interval
		clearInterval(this.config.intervals.vDivLines);
	}
	/**
	 * drawHGrid method draws the horizontal grid background color	 
	*/
	private function drawVGrid():Void {
		//If we're required to draw vertical grid color
		//and numVDivLines > 1
		if (this.params.showAlternateVGridColor && this.params.numVDivLines>1) {
			//Movie clip container
			var gridMC:MovieClip;
			//Loop variable
			var i:Number;
			//Get depth
			var depth:Number = this.dm.getDepth("VGRID");
			//X Position
			var xPos:Number, xPosEnd:Number;
			var width:Number;
			//Get the horizontal spacing between two vertical div lines
			//We have to accomodate the canvas padding here.
			var horSpace:Number = (this.elements.canvas.w-(2*this.params.canvasPadding))/(this.params.numVDivLines+1);
			for (i=1; i<=this.params.numVDivLines+1; i=i+2) {
				//Get x Position
				xPos = this.elements.canvas.x+(i-1)*horSpace+this.params.canvasPadding;
				//Get x end position
				xPosEnd = xPos+horSpace;
				//If it's first div line, deduct canvas padding from left
				xPos = (i == 1) ? (xPos-this.params.canvasPadding) : xPos;
				//If it's last div line, then we need to add canvas padding to end
				xPosEnd = (i == this.params.numVDivLines+1) ? (xPosEnd+this.params.canvasPadding) : (xPosEnd);
				//Get the width of the grid.
				width = xPosEnd-xPos;
				//Create the movie clip
				gridMC = this.cMC.createEmptyMovieClip("VGridBg_"+i, depth);
				//Set line style to null
				gridMC.lineStyle();
				//Set fill color
				gridMC.moveTo(-(width/2), -(this.elements.canvas.h/2));
				gridMC.beginFill(parseInt(this.params.alternateVGridColor, 16), this.params.alternateVGridAlpha);
				//Draw rectangle
				gridMC.lineTo(width/2, -(this.elements.canvas.h/2));
				gridMC.lineTo(width/2, this.elements.canvas.h/2);
				gridMC.lineTo(-(width/2), this.elements.canvas.h/2);
				gridMC.lineTo(-(width/2), -(this.elements.canvas.h/2));
				//End Fill
				gridMC.endFill();
				//Place it in right location
				gridMC._x = xPosEnd-(width/2);
				gridMC._y = this.elements.canvas.y+this.elements.canvas.h/2;
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(gridMC, this.objects.VGRID, this.macro, gridMC._x, 0, null, 0, 100, 100, 100, null);
				}
				//Apply filters                                                                                                                                                                                                                          
				this.styleM.applyFilters(gridMC, this.objects.VGRID);
				//Increase depth
				depth++;
			}
		}
		//Clear interval                                                                                                                               
		clearInterval(this.config.intervals.vGrid);
	}
	/**
	 * setContextMenu method sets the context menu for the chart.
	 * For this chart, the context items are "Print Chart".
	*/
	private function setContextMenu():Void {
		var chartMenu:ContextMenu = new ContextMenu();
		chartMenu.hideBuiltInItems();
		//Create a print chart contenxt menu item
		var printCMI:ContextMenuItem = new ContextMenuItem("Print Chart", Delegate.create(this, printChart));
		//Push print item.
		chartMenu.customItems.push(printCMI);
		if (this.params.imageSave){
			//Add the export to image option
			chartMenu.customItems.push(super.returnImageSaveMenuItem());		
		}
		if (this.params.showFCMenuItem){
			//Push "About FusionCharts" Menu Item
			chartMenu.customItems.push(super.returnAbtMenuItem());		
		}
		//Assign the menu to cMC movie clip
		this.cMC.menu = chartMenu;
	}
	// -------------------- EVENT HANDLERS --------------------//
	/**
	 * dataOnRollOver is the delegat-ed event handler method that'll
	 * be invoked when the user rolls his mouse over an anchor. 
	 * This function is invoked, only if the tool tip is to be shown.
	 * Here, we show the tool tip.
	*/
	private function dataOnRollOver():Void {
		//Index of data is stored in arguments.caller.index
		var index:Number = arguments.caller.index;
		//Set tool tip text
		this.tTip.setText(this.data[index].toolText);
		//Show the tool tip
		this.tTip.show();
	}
	/**
	 * dataOnRollOut method is invoked when the mouse rolls out
	 * of anchor. We just hide the tool tip here.
	*/
	private function dataOnRollOut():Void {
		//Hide the tool tip
		this.tTip.hide();
	}
	/**
	 * dataOnClick is invoked when the user clicks on a anchor (if link
	 * has been defined). We invoke the required link.														  
	*/
	private function dataOnClick():Void {
		//Index of column is stored in arguments.caller.index
		var index:Number = arguments.caller.index;
		//Invoke the link
		super.invokeLink(this.data[index].link);
	}
	/**
	 * reInit method re-initializes the chart. This method is basically called
	 * when the user changes chart data through JavaScript. In that case, we need
	 * to re-initialize the chart, set new XML data and again render.
	*/
	public function reInit():Void {
		//Invoke super class's reInit
		super.reInit();
		//Now initialize things that are pertinent to this class
		//but not defined in super class.
		//Re-set num to 0
		this.num = 0;
		//Re-create data array
		this.data = new Array();
		//Whether negative number present
		this.config.negativePresent = false;
	}
}
