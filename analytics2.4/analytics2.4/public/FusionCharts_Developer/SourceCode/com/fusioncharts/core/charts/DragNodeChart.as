/**
* @class DragNodeChart
* @author InfoSoft Global (P) Ltd. www.InfoSoftGlobal.com
* @version 3.0
*
* Copyright (C) InfoSoft Global Pvt. Ltd. 2005-2006
*
* DragNodeChart chart extends the XYPlotChart class to render a
* draggable node chart.
*/
//Import Chart class
import com.fusioncharts.core.Chart;
//Parent XYPlotChart Class
import com.fusioncharts.core.XYPlotChart;
//Error class
import com.fusioncharts.helper.FCError;
//Import Logger Class
import com.fusioncharts.helper.Logger;
//Import Chart Object
import com.fusioncharts.core.chartobjects.DragNode;
import com.fusioncharts.core.chartobjects.EditNode;
import com.fusioncharts.core.chartobjects.NodeConnector;
//Style Object
import com.fusioncharts.core.StyleObject;
//Button
import com.fusioncharts.helper.FCButton;
//Delegate
import mx.utils.Delegate;
import flash.external.ExternalInterface;
//Legend Class
import com.fusioncharts.helper.Legend;
//Extensions
import com.fusioncharts.extensions.StringExt;
//Drop Shadow filter
import flash.filters.DropShadowFilter;
//Class
class com.fusioncharts.core.charts.DragNodeChart extends XYPlotChart {
	//Version number (if different from super Chart class)
	//private var _version:String = "3.0.0";
	//Instance variables
	//List of chart objects
	private var _arrObjects:Array;
	private var xmlData:XML;
	private var connectors:Array;
	//Num Connector
	private var numConnector:Number;
	//Listener Object for the Node - when deleted
	private var nodeDelListener:Object;
	//Listener Object for the Node - when Added
	private var nodeUpdateListener:Object;	
	private var nodeCancelListener:Object;	
	//Listener Object for the Connector - when Deleted
	private var connectorDelListener:Object;	
	//Listener Object for the Connector - when Added
	private var connectorAddListener:Object;	
	//Drag Cursor
	private var dragCursorMC:MovieClip;
	/**
	* Constructor function. We invoke the super class'
	* constructor and then set the objects for this chart.
	*/
	function DragNodeChart(targetMC:MovieClip, depth:Number, width:Number, height:Number, x:Number, y:Number, debugMode:Boolean, lang:String, scaleMode:String, registerWithJS:Boolean, DOMId:String) {
		//Invoke the super class constructor
		super (targetMC, depth, width, height, x, y, debugMode, lang, scaleMode, registerWithJS, DOMId);
		//Log additional information to debugger
		//We log version from this class, so that if this class version
		//is different, we can log it
		this.log("Version", _version, Logger.LEVEL.INFO);
		this.log("Chart Type", "DragNode Chart", Logger.LEVEL.INFO);
		//List Chart Objects and set them
		_arrObjects = new Array("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "YAXISNAME", "XAXISNAME", "DIVLINES", "VLINES", "YAXISVALUES", "HGRID", "DATALABELS", "CONNECTORLABELS", "TRENDLINES", "VTRENDLINES", "VTRENDVALUES", "TRENDVALUES", "CONNECTOR", "DATAPLOT", "TOOLTIP", "LEGEND");
		super.setChartObjects(_arrObjects);
		//Initialize Connector
		this.connectors = new Array();
		this.numConnector = 0;
		//Configuration whether links have been defined - by default assume no.
		this.config.linksDefined = false;
		//Enable/Disable for link and drag
		this.config.enableDrag = false;
		this.config.enableLinks = false;
		//Depth Counter for the Nodes
		this.config.depthCounter = 0;
		//Initialize the node listener
		nodeDelListener = new Object();
		//Initialize the node listener		
		nodeUpdateListener = new Object();
		nodeCancelListener = new Object();
		//Initialize the Connector listener		
		connectorDelListener = new Object();
		//Initialize the Connector listener		
		connectorAddListener= new Object();
		//Listeners
		this.config.stkListener = new Array();
		this.config.stkListenerLength = 0;
		if (targetMC._registerWithJS==true){
			//Register the returnXML method of chart 
			ExternalInterface.addCallback("getXMLData", this, returnXML);
			//Register the setThreshold method of chart 
			ExternalInterface.addCallback("setThreshold", this, setThreshold);
		}
	}
	/**
	* render method is the single call method that does the rendering of chart:
	* - Parsing XML
	* - Calculating values and co-ordinates
	* - Visual layout and rendering
	* - Event handling
	*/
	public function render():Void {
		//Parse the XML Data document
		this.parseXML();
		//Now, if the number of data elements is 0, we show pertinent
		//error.
		if (this.numDS == 0) {
			tfAppMsg = this.renderAppMessage(_global.getAppMessage("NODATA", this.lang));
			//Add a message to log.
			this.log("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn't any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI><LI>You might be using a Single Series Chart .swf file instead of Multi-series .swf file and providing multi-series data or vice-versa.</LI>", Logger.LEVEL.ERROR);
			//Expose rendered method
			this.exposeChartRendered();
		} else {
			//Detect number scales
			this.detectNumberScales();
			//Calculate the axis limits
			this.calculateAxisLimits();
			//Calculate exact number of div lines
			this.calcDivs();
			//Set Style defaults
			this.setStyleDefaults();
			//Validate trend lines
			this.validateTrendLines();
			//Allot the depths for various charts objects now
			this.allotDepths();
			//Calculate Canvas Co-ordinates
			this.calcCanvasCoords();
			//Calculate Points
			this.calculatePoints();
			//Calculate trend line positions
			this.calcTrendLinePos();
			//Feed macro values
			super.feedMacros();
			//Remove application message
			this.removeAppMessage(this.tfAppMsg);
			//Set tool tip parameter
			this.setToolTipParam();
			//-----Start Visual Rendering Now------//
			//Draw background
			this.drawBackground();
			//Set click handler
			this.drawClickURLHandler();
			//Load background SWF
			this.loadBgSWF();
			//Update timer
			this.timeElapsed = (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.BACKGROUND) : 0;
			//Draw canvas
			this.config.intervals.canvas = setInterval(Delegate.create(this, drawCanvas), this.timeElapsed);
			//Draw headers
			this.config.intervals.headers = setInterval(Delegate.create(this, drawHeaders), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.CANVAS, this.objects.CAPTION, this.objects.SUBCAPTION, this.objects.YAXISNAME, this.objects.XAXISNAME) : 0;
			//Draw div lines
			this.config.intervals.divLines = setInterval(Delegate.create(this, drawDivLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DIVLINES, this.objects.YAXISVALUES) : 0;
			//Horizontal grid
			this.config.intervals.hGrid = setInterval(Delegate.create(this, drawHGrid), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation && (this.params.showAlternateHGridColor) ? this.styleM.getMaxAnimationTime(this.objects.HGRID) : 0);
			//Vertical lines
			this.config.intervals.vLine = setInterval(Delegate.create(this, drawVLines), this.timeElapsed);
			//Draw trend lines
			this.config.intervals.vTrend = setInterval(Delegate.create(this, drawVTrendLines), this.timeElapsed);
			this.config.intervals.trend = setInterval(Delegate.create(this, drawTrendLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.VLINES, this.objects.TRENDLINES, this.objects.VTRENDLINES, this.objects.TRENDVALUES) : 0;
			//Draw labels
			this.config.intervals.labels = setInterval(Delegate.create(this, drawLabels), this.timeElapsed);
			//Legend
			this.config.intervals.legend = setInterval(Delegate.create(this, drawLegend), this.timeElapsed);
			//Draw the form button if it is required
			if(this.params.showFormBtn) {
				//Draw and show the form button
				this.config.intervals.formBtn = setInterval(Delegate.create(this, drawFormBtn), this.timeElapsed);
			}
			//Update timer
			this.timeElapsed += (this.params.animation && this.styleM.getMaxAnimationTime(this.objects.DATALABELS, this.objects.LEGEND));
			//Connectors  
			this.config.intervals.connectors = setInterval(Delegate.create(this, drawConnectors), this.timeElapsed);
			//Nodes              
			this.config.intervals.nodes = setInterval(Delegate.create(this, drawNodeChart), this.timeElapsed);
			//Dispatch event that the chart has loaded.
			this.config.intervals.renderedEvent = setInterval(Delegate.create(this, exposeChartRendered) , this.timeElapsed);
			//Render context menu
			//We do not put context menu interval as we need the menu to appear
			//right from start of the play.			
			this.setContextMenu();
			//Draw the drag Cursor Once
			this.drawDragCursor();
		}
	}
	/**
	* returnDataAsObject method creates an object out of the parameters
	* passed to this method. The idea is that we store each data point
	* as an object with multiple (flexible) properties. So, we do not
	* use a predefined class structure. Instead we use a generic object.
	*	@param	id			id of the data-item for identification.
	*	@param	xv			x-Value for the data.
	*	@param	yv			y-Value for the data.
	*	@param	w			width for the data.
	*	@param	h			height for the data.
	*	@param	r			radius of the node
	*	@param	numSides	number of sides for the node.
	*	@param	shape		shape to draw as the node figure.
	*	@param	label		Label for the data
	*   @param 	isDraggable	Set the dragging option for the data item.
	*	@param	toolText	Tool tip text (if specified).
	*	@param	link		Link (if any) for the data.
	*	@param	color		color of the specific node
	*	@param	alpha		alpha of the specific node
	*	@param	imageNode	Boolean value to specify whether we need image in the node or not.
	*	@param	Url			Link for the image.
	*	@param	imageHeight	height of the image
	*	@param	imageWidth	width of the image
	*	@param	imageAlign	alignment of the image with respect to the Node
	*	@param	labelAlign	alignment of the label with respect to the Node
	*	@returns			An object encapsulating all these properies.
	*/
	private function returnDataAsObject(id:String, xv:Number, yv:Number, w:Number, h:Number, r:Number, numSides:Number, shape:String, label:String, isDraggable:Boolean, toolText:String, link:String, color:String, alpha:Number, imageNode:Boolean, Url:String, imageHeight:Number, imageWidth:Number, imageAlign:String, labelAlign:String):Object {
		//Create a container
		var dataObj:Object = new Object();
		//Store the values
		dataObj.id = id;
		dataObj.label = label;
		dataObj.xv = xv;
		dataObj.yv = yv;
		dataObj.updatedXV = xv;
		dataObj.updatedYV = yv;
		dataObj.w = w;
		dataObj.h = h;
		dataObj.r = r;
		dataObj.numSides = numSides;
		dataObj.shape = shape.toUpperCase();
		dataObj.name = label;
		dataObj.isDraggable = isDraggable;
		dataObj.toolText = toolText;
		dataObj.link = link;
		dataObj.imageNode = imageNode;
		dataObj.imageUrl = Url;
		dataObj.imageHeight = imageHeight;
		dataObj.imageWidth =imageWidth;
		dataObj.imageAlign = imageAlign;
		dataObj.labelAlign =labelAlign;
		//If the given number is not a valid number or it's missing
		//set appropriate flags for this data point
		dataObj.isDefined = (isNaN(xv) || isNaN(yv) || isNaN(w) || isNaN(h)) ? false : true;
		//Other parameters
		//X & Y Position of data point
		dataObj.x = 0;
		dataObj.y = 0;
		//X & Y Position of value tb
		dataObj.valTBX = 0;
		dataObj.valTBY = 0;
		//cosmetic properties
		dataObj.color = color;
		dataObj.alpha = alpha;
		//Return the container
		return dataObj;
	}
	/**
	 * returnDataAsCat method returns data of a <category> element as
	 * an object
	 *	@param	label		Label of the category.
	 *	@param	xv			X-value of the category
	 *	@param	showLabel	Whether to show the label of this category.
	 *	@param	toolText	Tool-text for the category
	 *	@param	showLine	Whether to show vertical line
	 *	@param	lineDashed	Whether vertical line is dashed
	 *	@returns			A container object with the given properties
	*/
	private function returnDataAsCat(label:String, xv:Number, showLabel:Number, toolText:String, showLine:Boolean, lineDashed:Boolean):Object {
		//Create container object
		var catObj:Object = new Object();
		catObj.label = label;
		catObj.xv = xv;
		catObj.showLabel = ((showLabel == 1) && (label != undefined) && (label != null) && (label != "")) ? true : false;
		catObj.toolText = toolText;
		catObj.showLine = showLine;
		catObj.lineDashed = lineDashed;
		//X and Y Position
		catObj.x = 0;
		catObj.y = 0;
		//Valid
		catObj.isValid = true;
		//Return container
		return catObj;
	}
	/**
	 * returnDataAsCon method returns data of a <connector> element as
	 * an object
	 *	@param	label		Label of the category.
	 *	@param	from		from indicates Dataitem index to which it connects from.
	 *	@param	to			to indicates Dataitem index to which it connects to.
	 *	@param	color		line color of the connector
	 *	@param	alpha		line alpha of the connector
	 *	@param	dashed		whether the line is dashed
	 *	@param	dashGap		dash gap for the connector
	 *	@param	dashLen		dash length for the connector
	 *	@param	arrowAtStart	whether the arrow is required at the start of connector
	 *	@param	arrowAtEnd	whether the arrow is required at the end of connector
	 *	@param	conStrength	Numeric value to indicate strengthness of the connector
	 *	@returns			A container object with the given properties
	*/
	private function returnDataAsCon(label:String, from:String, to:String, color:String, alpha:Number, dashed:Boolean, dashGap:Number, dashLen:Number, arrowAtStart:Boolean, arrowAtEnd:Boolean, strength:Number):Object {
		//Create container object
		var conObj:Object = new Object();
		conObj.label = label;
		conObj.from = from;
		conObj.to = to;
		conObj.color = color;
		conObj.alpha = alpha;
		conObj.dashed = ((dashed == 1)) ? true : false;
		conObj.dashGap = dashGap;
		conObj.dashLen = dashLen;
		conObj.arrowAtStart = arrowAtStart;
		conObj.arrowAtEnd = arrowAtEnd;
		conObj.strength = strength;
		//X and Y Position
		conObj.fromX = 0;
		conObj.fromY = 0;
		conObj.toX = 0;
		conObj.toY = 0;
		//Valid
		conObj.isApplicable = true;
		//Return container
		return conObj;
	}
	/**
	* parseXML method parses the XML data, sets defaults and validates
	* the attributes before storing them to data storage objects.
	*/
	private function parseXML():Void {
		//Get the element nodes
		var arrDocElement:Array = this.xmlData.childNodes;
		//Loop variable
		var i:Number;
		var j:Number;
		var k:Number;
		//Look for <graph> element
		for (i=0; i<arrDocElement.length; i++) {
			//If it's a <graph> element, proceed.
			//Do case in-sensitive mathcing by changing to upper case
			if (arrDocElement[i].nodeName.toUpperCase() == "GRAPH" || arrDocElement[i].nodeName.toUpperCase() == "CHART") {
				//Extract attributes of <graph> element
				this.parseAttributes(arrDocElement[i]);
				//Now, get the child nodes - first level nodes
				//Level 1 nodes can be - CATEGORIES, DATASET, TRENDLINES, STYLES etc.
				var arrLevel1Nodes:Array = arrDocElement[i].childNodes;
				var setNode:XMLNode;
				//Iterate through all level 1 nodes.
				for (j=0; j<arrLevel1Nodes.length; j++) {
					if (arrLevel1Nodes[j].nodeName.toUpperCase() == "CATEGORIES") {
						//Categories Node. 
						var categoriesNode:XMLNode = arrLevel1Nodes[j];
						//Convert attributes to array
						var categoriesAtt:Array = this.getAttributesArray(categoriesNode);
						//Extract attributes of this node.
						this.params.catFont = getFV(categoriesAtt["font"], this.params.outCnvBaseFont);
						this.params.catFontSize = getFN(categoriesAtt["fontsize"], this.params.outCnvBaseFontSize);
						this.params.catFontColor = formatColor(getFV(categoriesAtt["fontcolor"], this.params.outCnvBaseFontColor));
						//Category vertical lines
						this.params.catVerticalLineColor = formatColor(getFV(categoriesAtt["verticallinecolor"], this.defColors.get2DDivLineColor(this.params.palette)));
						this.params.catVerticalLineThickness = getFN(categoriesAtt["verticallinethickness"], 1);
						this.params.catVerticalLineAlpha = getFN(categoriesAtt["verticallinealpha"], this.defColors.get2DDivLineAlpha(this.params.palette));
						this.params.catVerticalLineDashed = toBoolean(getFN(categoriesAtt["verticallinedashed"], 0));
						this.params.catVerticalLineDashLen = getFN(categoriesAtt["verticallinedashlen"], 4);
						this.params.catVerticalLineDashGap = getFN(categoriesAtt["verticallinedashgap"], 2);
						//Get reference to child node.
						var arrLevel2Nodes:Array = arrLevel1Nodes[j].childNodes;
						//Iterate through all child-nodes of CATEGORIES element
						//and search for CATEGORY or VLINE node
						for (k=0; k<arrLevel2Nodes.length; k++) {
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "CATEGORY") {
								//Category Node. 
								//Update counter
								this.numCat++;
								//Extract attributes
								var categoryNode:XMLNode = arrLevel2Nodes[k];
								var categoryAtt:Array = this.getAttributesArray(categoryNode);
								//Category label.
								var catLabel:String = getFV(categoryAtt["label"], categoryAtt["name"], "");
								//X-value
								var catX:Number = this.getSetValue(categoryAtt["x"]);
								var catShowLabel:Number = getFN(categoryAtt["showlabel"], categoryAtt["showname"], this.params.showLabels);
								var catToolText:String = getFV(categoryAtt["tooltext"], categoryAtt["hovertext"], catLabel);
								var catShowLine:Boolean = toBoolean(getFN(categoryAtt["showverticalline"], categoryAtt["sl"], 0));
								var catLineDashed:Boolean = toBoolean(getFN(categoryAtt["linedashed"], this.params.catVerticalLineDashed));
								//If x value for category has has not been provided, we won't add it
								if (isNaN(catX)) {
									this.numCat--;
								} else {
									//Store it in data container.
									this.categories[this.numCat] = this.returnDataAsCat(catLabel, catX, catShowLabel, catToolText, catShowLine, catLineDashed);
								}
							}
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "DATASET") {
						//Increment
						this.numDS++;
						//Dataset node.
						var dataSetNode:XMLNode = arrLevel1Nodes[j];
						//Get attributes array
						var dsAtts:Array = this.getAttributesArray(dataSetNode);
						//Create storage object in dataset array
						this.dataset[this.numDS] = new Object();
						//Store attributes
						this.dataset[this.numDS].id = getFV(dsAtts["id"], this.numDS);
						this.dataset[this.numDS].seriesName = getFV(dsAtts["seriesname"], "");
						this.dataset[this.numDS].color = formatColor(getFV(dsAtts["color"], this.defColors.getColor()));
						this.dataset[this.numDS].alpha = getFN(dsAtts["plotfillalpha"], dsAtts["nodeFillAlpha"], this.params.plotFillAlpha);
						this.dataset[this.numDS].includeInLegend = toBoolean(getFN(dsAtts["includeinlegend"], 1));
						//Data set plot properties
						this.dataset[this.numDS].showPlotBorder = toBoolean(getFN(dsAtts["showplotborder"], this.params.showPlotBorder));
						this.dataset[this.numDS].plotBorderColor = formatColor(getFV(dsAtts["plotbordercolor"], dsAtts["nodebordercolor"], this.params.plotBorderColor));
						this.dataset[this.numDS].plotBorderThickness = getFN(dsAtts["plotborderthickness"], dsAtts["nodeborderthickness"], this.params.plotBorderThickness);
						this.dataset[this.numDS].plotBorderAlpha = (this.dataset[this.numDS].showPlotBorder) ? getFN(dsAtts["plotborderalpha"], dsAtts["nodeborderalpha"], this.params.plotBorderAlpha) : 0;
						//Drag Border properties
						this.dataset[this.numDS].allowDrag = toBoolean(getFN(dsAtts["allowdrag"], "1"));
						//Create data array under it.
						this.dataset[this.numDS].data = new Array();
						//Get reference to child node.
						var arrLevel2Nodes:Array = arrLevel1Nodes[j].childNodes;
						//Iterate through all child-nodes of DATASET element
						//and search for SET node
						//Counter
						var setCount:Number = 0;
						for (k=0; k<arrLevel2Nodes.length; k++) {
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "SET") {
								//Set Node. So extract the data.
								//Update counter
								setCount++;
								//Get reference to node.
								setNode = arrLevel2Nodes[k];
								//Get attributes
								var atts:Array;
								atts = this.getAttributesArray(setNode);
								//Now, get values.
								var setId:String = getFV(atts["id"], this.dataset[this.numDS].id+ "_" +setCount);
								var setXV:Number = getFN(this.getSetValue(atts["x"]), setCount);
								var setYV:Number = this.getSetValue(atts["y"]);
								var setWidth:Number = getFN(atts["width"], 10);
								var setHeight:Number = getFN(atts["height"], 10);
								var setRadius:Number = getFN(atts["radius"], 10);
								var setNumSides:Number = getFN(atts["numsides"], 4);
								var setShape:String = getFV(atts["shape"], "RECTANGLE");
								//If not required shape then set it to rectangle
								if(setShape.toUpperCase() != "CIRCLE" && setShape.toUpperCase() != "POLYGON" && setShape.toUpperCase() != "RECTANGLE") {
									setShape = "RECTANGLE";
								}
								//We do NOT unescape the link, as this will be done
								//in invokeLink method for the links that user clicks.
								var setLink:String = getFV(atts["link"], "");
								// flag to be used to enable links for user interaction, initially and to keep the same option in the context menu
								this.config.linksDefined = (setLink.length>1) ? true : this.config.linksDefined;
								var setColor:String = getFV(atts["color"], this.dataset[this.numDS].color);
								var setAlpha:Number = getFN(atts["alpha"], this.dataset[this.numDS].alpha);
								var setName:String = getFV(atts["name"], atts["label"], " ");
								var setToolText:String = getFV(atts["tooltext"], atts["hovertext"], atts["name"]);
								//Image Node definition
								var setImageNode:Boolean = toBoolean(getFN(atts["imagenode"], 0));
								var setURL:String = getFV(atts["imageurl"], "");
								var setImageHeight:Number = getFN(atts["imageheight"], -1);
								var setImageWidth:Number = getFN(atts["imagewidth"], -1);
								var setImageAlign:String = getFV(atts["imagealign"], "top");
								var setLabelAlign:String = getFV(atts["labelalign"], "top");
								var setAllowDrag:Boolean = toBoolean(getFN(atts["allowdrag"], this.dataset[this.numDS].allowDrag));
								//Store all these attributes as object.						
								this.dataset[this.numDS].data[setCount] = this.returnDataAsObject(setId, setXV, setYV, setWidth, setHeight, setRadius, setNumSides, setShape, setName, setAllowDrag, setToolText, setLink, setColor, setAlpha, setImageNode, setURL, setImageHeight, setImageWidth, setImageAlign, setLabelAlign);
								//Create a connector list array
								this.dataset[this.numDS].data[setCount].conList = new Array();
								//Array which holds the data id which is not connected to each data item
								this.dataset[this.numDS].data[setCount].dataNotConnected = new Array();
							}
						}
						//Update global counter
						this.dataset[this.numDS].num = setCount;
						if (setCount>this.num) {
							this.num = setCount;
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "CONNECTORS") {
						//Connectors Node. 
						var connectorsNode:XMLNode = arrLevel1Nodes[j];
						//Convert attributes to array
						var connectorsAtt:Array = this.getAttributesArray(connectorsNode);
						//Get reference to child node.
						var arrLevel2Nodes:Array = arrLevel1Nodes[j].childNodes;
						//Extract attributes of this node.
						this.params.stdThickness = getFN(connectorsAtt["stdthickness"], 1);
						this.params.conColor = formatColor(getFV(connectorsAtt["color"], "FF5904"));
						this.params.conAlpha = getFN(connectorsAtt["alpha"], 100);
						this.params.conDashGap = getFN(connectorsAtt["dashgap"], 5);
						this.params.conDashLen = getFN(connectorsAtt["dashlen"], 5);
						this.params.conDashed = toBoolean(getFN(connectorsAtt["dashed"], 0));
						this.params.arrowAtStart = toBoolean(getFN(connectorAtt["arrowatstart"], 1));
						this.params.arrowAtEnd = toBoolean(getFN(connectorAtt["arrowatend"], 1));
						this.params.conStrength = getFN(connectorAtt["strength"], 1);
						//Iterate through all child-nodes of Connectors element
						//and search for Connectors
						for (k=0; k<arrLevel2Nodes.length; k++) {
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "CONNECTOR") {
								//Connectors Node. 
								//Update counter
								this.numConnector++;
								//Extract attributes
								var connectorNode:XMLNode = arrLevel2Nodes[k];
								var connectorAtt:Array = this.getAttributesArray(connectorNode);
								//From To value
								var connectorFrom:String = getFV(connectorAtt["from"],"");
								var connectorTo:String = getFV(connectorAtt["to"],"");
								if (connectorFrom != "" && connectorFrom != null && connectorTo != "" && connectorTo != null) {
									//connector label.
									var connectorLabel:String = getFV(connectorAtt["label"], connectorAtt["name"], "");
									var conColor:String = getFV(connectorAtt["color"], this.params.conColor);
									var conAlpha:Number = getFN(connectorAtt["alpha"], this.params.conAlpha);
									var conLineDashed:Boolean = toBoolean(getFN(connectorAtt["dashed"], this.params.conDashed));
									var conDashGap:Number = getFN(connectorAtt["dashgap"], this.params.conDashGap);
									var conDashLen:Number = getFN(connectorAtt["dashlen"], this.params.conDashLen);
									var arrowAtStart:Boolean = toBoolean(getFN(connectorAtt["arrowatstart"], this.params.arrowAtStart));
									var arrowAtEnd:Boolean = toBoolean(getFN(connectorAtt["arrowatend"], this.params.arrowAtEnd));
									var conStrength:Number = getFN(connectorAtt["strength"], this.params.conStrength);
									//Store it in data container.
									this.connectors[this.numConnector] = this.returnDataAsCon(connectorLabel, connectorFrom, connectorTo, conColor, conAlpha, conLineDashed, conDashGap, conDashLen, arrowAtStart, arrowAtEnd, conStrength);
								}
							}
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "STYLES") {
						//Styles Node - extract child nodes
						var arrStyleNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the style nodes to extract style information
						super.parseStyleXML(arrStyleNodes);
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "HTRENDLINES" || arrLevel1Nodes[j].nodeName.toUpperCase() == "TRENDLINES") {
						//Trend lines node
						var arrTrendNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the trend line nodes
						super.parseHTrendLineXML(arrTrendNodes);
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "VTRENDLINES") {
						//Vertical Trend lines node
						var arrTrendNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the trend line nodes
						super.parseVTrendLineXML(arrTrendNodes);
					}
				}
			}
		}
		//Delete all temporary objects used for parsing XML Data document
		delete setNode;
		delete arrDocElement;
		delete arrLevel1Nodes;
		delete arrLevel2Nodes;
	}
	/**
	* parseAttributes method parses the attributes and stores them in
	* chart storage objects.
	* Starting ActionScript 2, the parsing of XML attributes have also
	* become case-sensitive. However, prior versions of FusionCharts
	* supported case-insensitive attributes. So we need to parse all
	* attributes as case-insensitive to maintain backward compatibility.
	* To do so, we first extract all attributes from XML, convert it into
	* lower case and then store it in an array. Later, we extract value from
	* this array.
	* @param	graphElement	XML Node containing the <graph> element
	*							and it's attributes
	*/
	private function parseAttributes(graphElement:XMLNode):Void {
		//Array to store the attributes
		var atts:Array = this.getAttributesArray(graphElement);
		//NOW IT'S VERY NECCESARY THAT WHEN WE REFERENCE THIS ARRAY
		//TO GET AN ATTRIBUTE VALUE, WE SHOULD PROVIDE THE ATTRIBUTE
		//NAME IN LOWER CASE. ELSE, UNDEFINED VALUE WOULD SHOW UP.
		//Extract attributes pertinent to this chart
		//Which palette to use?
		this.params.palette = getFN(atts["palette"], 1);
		//Whether to show about FusionCharts Menu Item - by default set to on
		this.params.showFCMenuItem = toBoolean(getFN (atts ["showfcmenuitem"] , 1));
		// ---------- PADDING AND SPACING RELATED ATTRIBUTES ----------- //
		//captionPadding = Space between caption/subcaption and canvas start Y
		this.params.captionPadding = getFN(atts["captionpadding"], 10);
		//Padding for x-axis name - to the right
		this.params.xAxisNamePadding = getFN(atts["xaxisnamepadding"], 5);
		//Padding for y-axis name - from top
		this.params.yAxisNamePadding = getFN(atts["yaxisnamepadding"], 5);
		//Y-Axis Values padding - Horizontal space between the axis edge and
		//y-axis values or trend line values (on left/right side).
		this.params.yAxisValuesPadding = getFN(atts["yaxisvaluespadding"], 2);
		//Label padding - Vertical space between the labels and canvas end position
		this.params.labelPadding = getFN(atts["labelpadding"], atts["labelspadding"], 3);
		//Padding of legend from right/bottom side of canvas
		this.params.legendPadding = getFN(atts["legendpadding"], 6);
		//Chart Margins - Empty space at the 4 sides
		this.params.chartLeftMargin = getFN(atts["chartleftmargin"], 15);
		this.params.chartRightMargin = getFN(atts["chartrightmargin"], 15);
		this.params.chartTopMargin = getFN(atts["charttopmargin"], 15);
		this.params.chartBottomMargin = getFN(atts["chartbottommargin"], 15);
		// -------------------------- HEADERS ------------------------- //
		//Chart Caption and sub Caption
		this.params.caption = getFV(atts["caption"], "");
		this.params.subCaption = getFV(atts["subcaption"], "");
		//X and Y Axis Name
		this.params.xAxisName = getFV(atts["xaxisname"], "");
		this.params.yAxisName = getFV(atts["yaxisname"], "");
		//Adaptive yMin - if set to true, the y min will be based on the values 
		//provided. It won't be set to 0 in case of all positive values
		this.params.setAdaptiveYMin = toBoolean(getFN(atts["setadaptiveymin"], 0));
		// --------------------- CONFIGURATION ------------------------- //
		//The upper and lower limits of y and x axis
		this.params.yAxisMinValue = atts["yaxisminvalue"];
		this.params.yAxisMaxValue = atts["yaxismaxvalue"];
		//X-axis
		this.params.xAxisMinValue = atts["xaxisminvalue"];
		this.params.xAxisMaxValue = atts["xaxismaxvalue"];
		//Whether to set animation for entire chart.
		this.params.animation = toBoolean(getFN(atts["animation"], 1));
		//Whether to set the default chart animation
		this.params.defaultAnimation = toBoolean(getFN(atts["defaultanimation"], 1));
		//Configuration to set whether to show the labels   
		this.params.showLabels = toBoolean(getFN(atts["showlabels"], atts["shownames"], 0));
		//Label Display Mode - WRAP, STAGGER, ROTATE or NONE
		this.params.labelDisplay = getFV(atts["labeldisplay"], "WRAP");
		//Remove spaces and capitalize
		this.params.labelDisplay = StringExt.removeSpaces(this.params.labelDisplay);
		this.params.labelDisplay = this.params.labelDisplay.toUpperCase();
		//Option to show vertical x-axis labels
		this.params.rotateLabels = getFV(atts["rotatelabels"], atts["rotatenames"]);
		//Whether to slant label (if rotated)
		this.params.slantLabels = toBoolean(getFN(atts["slantlabels"], atts["slantlabel"], 0));
		//Angle of rotation based on slanting
		this.config.labelAngle = (this.params.slantLabels == true) ? 315 : 270;
		//If rotateLabels has been explicitly specified, we assign ROTATE value to this.params.labelDisplay
		this.params.labelDisplay = (this.params.rotateLabels == "1") ? "ROTATE" : this.params.labelDisplay;
		//Step value for labels - i.e., show all labels or skip every x label
		this.params.labelStep = int(getFN(atts["labelstep"], 1));
		//Cannot be less than 1
		this.params.labelStep = (this.params.labelStep<1) ? 1 : this.params.labelStep;
		//Number of stagger lines
		this.params.staggerLines = int(getFN(atts["staggerlines"], 2));
		//Cannot be less than 2
		this.params.staggerLines = (this.params.staggerLines<2) ? 2 : this.params.staggerLines;
		//Option to show/hide y-axis values
		this.params.showYAxisValues = getFN(atts["showyaxisvalues"], atts["showyaxisvalue"], 0);
		this.params.showLimits = toBoolean(getFN(atts["showlimits"], this.params.showYAxisValues));
		this.params.showDivLineValues = toBoolean(getFN(atts["showdivlinevalue"], atts["showdivlinevalues"], this.params.showYAxisValues));
		//Y-axis value step- i.e., show all y-axis or skip every x(th) value
		this.params.yAxisValuesStep = int(getFN(atts["yaxisvaluesstep"], atts["yaxisvaluestep"], 1));
		//Cannot be less than 1
		this.params.yAxisValuesStep = (this.params.yAxisValuesStep<1) ? 1 : this.params.yAxisValuesStep;
		//Whether to automatically adjust div lines
		this.params.adjustDiv = toBoolean(getFN(atts["adjustdiv"], 1));
		//Whether to rotate y-axis name
		this.params.rotateYAxisName = toBoolean(getFN(atts["rotateyaxisname"], 1));
		//Max width to be alloted to y-axis name - No defaults, as it's calculated later.
		this.params.yAxisNameWidth = atts["yaxisnamewidth"];
		//Click URL
		this.params.clickURL = getFV(atts["clickurl"], "");
		//View or Edit mode
		this.params.viewMode = toBoolean(getFN(atts["viewmode"], 1));
		//Show/Hide Link Mode
		this.params.enableLink = toBoolean(getFN(atts["enablelink"], 0));
		//Form Actions
		this.params.showFormBtn = toBoolean(getFN(atts["showformbtn"], 1));
		this.params.formBtnWidth = getFN(atts["formbtnwidth"], 80);
		this.params.formBtnTitle = getFV(atts["formbtntitle"], "Submit");
		this.params.formBtnBorderColor = getFV(atts["formbtnbordercolor"], "CBCBCB");
		this.params.formBtnBgColor = getFV(atts["formbtnbgcolor"], "FFFFFF");
		this.params.formAction = getFV(atts["formaction"], "");
		this.params.formTarget = getFV(atts["formtarget"], "_self");
		this.params.formMethod = getFV(atts["formmethod"], "POST");
		this.params.formBtnBgColor = getFV(atts["formbtnbgcolor"], "FFFFFF");
		this.params.btnPadding  = getFN(atts["btnpadding"], 5);
		this.params.btnTextColor = getFV(atts["btntextcolor"], "000000");
		// ------------------------- COSMETICS -----------------------------//
		//Background properties - Gradient
		this.params.bgColor = getFV(atts["bgcolor"], this.defColors.get2DBgColor(this.params.palette));
		this.params.bgAlpha = getFV(atts["bgalpha"], this.defColors.get2DBgAlpha(this.params.palette));
		this.params.bgRatio = getFV(atts["bgratio"], this.defColors.get2DBgRatio(this.params.palette));
		this.params.bgAngle = getFV(atts["bgangle"], this.defColors.get2DBgAngle(this.params.palette));
		//Border Properties of chart
		this.params.showBorder = toBoolean(getFN(atts["showborder"], 1));
		this.params.borderColor = formatColor(getFV(atts["bordercolor"], this.defColors.get2DBorderColor(this.params.palette)));
		this.params.borderThickness = getFN(atts["borderthickness"], 1);
		this.params.borderAlpha = getFN(atts["borderalpha"], this.defColors.get2DBorderAlpha(this.params.palette));
		//Background swf
		this.params.bgSWF = getFV(atts["bgswf"], "");
		this.params.bgSWFAlpha = getFN(atts["bgswfalpha"], 100);
		//Canvas background properties - Gradient
		this.params.canvasBgColor = getFV(atts["canvasbgcolor"], this.defColors.get2DCanvasBgColor(this.params.palette));
		this.params.canvasBgAlpha = getFV(atts["canvasbgalpha"], this.defColors.get2DCanvasBgAlpha(this.params.palette));
		this.params.canvasBgRatio = getFV(atts["canvasbgratio"], this.defColors.get2DCanvasBgRatio(this.params.palette));
		this.params.canvasBgAngle = getFV(atts["canvasbgangle"], this.defColors.get2DCanvasBgAngle(this.params.palette));
		//Canvas Border properties
		this.params.canvasBorderColor = formatColor(getFV(atts["canvasbordercolor"], this.defColors.get2DCanvasBorderColor(this.params.palette)));
		this.params.canvasBorderThickness = getFN(atts["canvasborderthickness"], 2);
		this.params.canvasBorderAlpha = getFN(atts["canvasborderalpha"], this.defColors.get2DCanvasBorderAlpha(this.params.palette));
		//Legend properties		
		this.params.showLegend = toBoolean(getFN(atts["showlegend"], 0));
		//Alignment position
		this.params.legendPosition = getFV(atts["legendposition"], "BOTTOM");
		//Legend position can be either RIGHT or BOTTOM -Check for it
		this.params.legendPosition = (this.params.legendPosition.toUpperCase() == "RIGHT") ? "RIGHT" : "BOTTOM";
		this.params.legendCaption = getFV(atts ["legendcaption"] , "");
		this.params.legendMarkerCircle = toBoolean(getFN(atts ["legendmarkercircle"] , 0));
		this.params.legendBorderColor = formatColor(getFV(atts["legendbordercolor"], this.defColors.get2DLegendBorderColor(this.params.palette)));
		this.params.legendBorderThickness = getFN(atts["legendborderthickness"], 1);
		this.params.legendBorderAlpha = getFN(atts["legendborderalpha"], 100);
		this.params.legendBgColor = getFV(atts["legendbgcolor"], this.defColors.get2DLegendBgColor(this.params.palette));
		this.params.legendBgAlpha = getFN(atts["legendbgalpha"], 100);
		this.params.legendShadow = toBoolean(getFN(atts["legendshadow"], 1));
		this.params.legendAllowDrag = toBoolean(getFN(atts["legendallowdrag"], 0));
		this.params.legendScrollBgColor = formatColor(getFV(atts["legendscrollbgcolor"], "CCCCCC"));
		this.params.legendScrollBarColor = formatColor(getFV(atts["legendscrollbarcolor"], this.params.legendBorderColor));
		this.params.legendScrollBtnColor = formatColor(getFV(atts["legendscrollbtncolor"], this.params.legendBorderColor));
		//Horizontal grid division Lines - Number, color, thickness & alpha
		//Necessarily need a default value for numDivLines.
		this.params.numDivLines = getFN(atts["numdivlines"], 0);
		this.params.divLineColor = formatColor(getFV(atts["divlinecolor"], this.defColors.get2DDivLineColor(this.params.palette)));
		this.params.divLineThickness = getFN(atts["divlinethickness"], 1);
		this.params.divLineAlpha = getFN(atts["divlinealpha"], this.defColors.get2DDivLineAlpha(this.params.palette));
		this.params.divLineIsDashed = toBoolean(getFN(atts["divlineisdashed"], 0));
		this.params.divLineDashLen = getFN(atts["divlinedashlen"], 4);
		this.params.divLineDashGap = getFN(atts["divlinedashgap"], 2);
		//Zero Plane properties
		this.params.showZeroPlane = toBoolean(getFN(atts["showzeroplane"], 1));
		this.params.zeroPlaneColor = formatColor(getFV(atts["zeroplanecolor"], this.params.divLineColor));
		this.params.zeroPlaneThickness = getFN(atts["zeroplanethickness"], 1);
		this.params.zeroPlaneAlpha = getFN(atts["zeroplanealpha"], this.params.divLineAlpha);
		//Alternating grid colors
		this.params.showAlternateHGridColor = toBoolean(getFN(atts["showalternatehgridcolor"], 1));
		this.params.alternateHGridColor = formatColor(getFV(atts["alternatehgridcolor"], this.defColors.get2DAltHGridColor(this.params.palette)));
		this.params.alternateHGridAlpha = getFN(atts["alternatehgridalpha"], this.defColors.get2DAltHGridAlpha(this.params.palette));
		//Tool Tip - Show/Hide, Background Color, Border Color, Separator Character
		this.params.showToolTip = toBoolean(getFN(atts["showtooltip"], atts["showhovercap"], 1));
		this.params.seriesNameInToolTip = toBoolean(getFN(atts["seriesnameintooltip"], 1));
		this.params.toolTipBgColor = formatColor(getFV(atts["tooltipbgcolor"], atts["hovercapbgcolor"], atts["hovercapbg"], this.defColors.get2DToolTipBgColor(this.params.palette)));
		this.params.toolTipBorderColor = formatColor(getFV(atts["tooltipbordercolor"], atts["hovercapbordercolor"], atts["hovercapborder"], this.defColors.get2DToolTipBorderColor(this.params.palette)));
		this.params.toolTipSepChar = getFV(atts["tooltipsepchar"], atts["hovercapsepchar"], ", ");
		//Font Properties
		this.params.baseFont = getFV(atts["basefont"], "Verdana");
		this.params.baseFontSize = getFN(atts["basefontsize"], 10);
		this.params.baseFontColor = formatColor(getFV(atts["basefontcolor"], this.defColors.get2DBaseFontColor(this.params.palette)));
		this.params.outCnvBaseFont = getFV(atts["outcnvbasefont"], this.params.baseFont);
		this.params.outCnvBaseFontSize = getFN(atts["outcnvbasefontsize"], this.params.baseFontSize);
		this.params.outCnvBaseFontColor = formatColor(getFV(atts["outcnvbasefontcolor"], this.params.baseFontColor));
		//Plot Properties
		this.params.plotFillAlpha = getFN(atts["plotfillalpha"], 100);
		this.params.showPlotBorder = getFN(atts["showplotborder"], 1);
		this.params.plotBorderColor = formatColor(getFV(atts["plotbordercolor"], "666666"));
		this.params.plotBorderThickness = getFN(atts["plotborderthickness"], 1);
		this.params.plotBorderAlpha = getFN(atts["plotborderalpha"], 95);
		//Node Properties
		this.params.use3DLighting = toBoolean(getFN(atts["use3dlighting"], atts["is3d"], 0));
		this.params.nodeScale = Math.abs(getFN(atts["nodescale"], 1));
		this.params.negativeColor = formatColor(getFV(atts["negativecolor"], "ff0000"));
		// ------------------------- NUMBER FORMATTING ---------------------------- //
		//Option whether the format the number (using Commas)
		this.params.formatNumber = getFN(atts["formatnumber"], 1);
		//Option to format number scale
		this.params.formatNumberScale = getFN(atts["formatnumberscale"], 1);
		//Number Scales
		this.params.defaultNumberScale = getFV(atts["defaultnumberscale"], "");
		this.params.numberScaleUnit = getFV(atts["numberscaleunit"], "K,M");
		this.params.numberScaleValue = getFV(atts["numberscalevalue"], "1000,1000");
		//Number prefix and suffix
		//TODO: Escape them
		this.params.numberPrefix = getFV(atts["numberprefix"], "");
		this.params.numberSuffix = getFV(atts["numbersuffix"], "");
		//Decimal Separator Character
		this.params.decimalSeparator = getFV(atts["decimalseparator"], ".");
		//Thousand Separator Character
		this.params.thousandSeparator = getFV(atts["thousandseparator"], ",");
		//Input decimal separator and thousand separator. In some european countries,
		//commas are used as decimal separators and dots as thousand separators. In XML,
		//if the user specifies such values, it will give a error while converting to
		//number. So, we accept the input decimal and thousand separator from user, so that
		//we can covert it accordingly into the required format.
		this.params.inDecimalSeparator = getFV(atts["indecimalseparator"], "");
		this.params.inThousandSeparator = getFV(atts["inthousandseparator"], "");
		//Decimal Precision (number of decimal places to be rounded to)
		this.params.decimals = getFV(atts["decimals"], atts["decimalprecision"]);
		//Force Decimal Padding
		this.params.forceDecimals = toBoolean(getFN(atts["forcedecimals"], 0));
		//y-Axis values decimals
		this.params.yAxisValueDecimals = getFV(atts["yaxisvaluedecimals"], atts["yaxisvaluesdecimals"], atts["divlinedecimalprecision"], atts["limitsdecimalprecision"]);
		// ---------------------- Image Saving ------------------------------//
		this.params.imageSave = toBoolean (getFN (atts ["imagesave"] , 0));
		this.params.imageSaveURL = getFV (atts ["imagesaveurl"] , "");
		this.params.imageSaveDialogColor = formatColor (getFV (atts ["imagesavedialogcolor"] , "E2E2E2"));
		this.params.imageSaveDialogFontColor = formatColor (getFV (atts ["imagesavedialogfontcolor"] , "666666"));
	}
	/**
	* calculateAxisLimits method sets the axis limits for the chart.
	* It gets the minimum and maximum value specified in data and
	* based on that it calls super.getAxisLimits();
	*/
	private function calculateAxisLimits():Void {
		//Calculate for x-axis
		this.getXAxisLimits(this.getMaxXDataValue(), this.getMinXDataValue());
		//Calculate for y-axis
		this.getYAxisLimits(this.getMaxYDataValue(), this.getMinYDataValue(), false, !this.params.setAdaptiveYMin);
	}
	/**
	* setStyleDefaults method sets the default values for styles or
	* extracts information from the attributes and stores them into
	* style objects.
	*/
	private function setStyleDefaults():Void {
		//Default font object for Caption
		//-----------------------------------------------------------------//
		var captionFont = new StyleObject();
		captionFont.name = "_SdCaptionFont";
		captionFont.align = "center";
		captionFont.valign = "top";
		captionFont.bold = "1";
		captionFont.font = this.params.outCnvBaseFont;
		captionFont.size = this.params.outCnvBaseFontSize;
		captionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.CAPTION, captionFont, this.styleM.TYPE.FONT, null);
		delete captionFont;
		//-----------------------------------------------------------------//
		//Default font object for SubCaption
		//-----------------------------------------------------------------//
		var subCaptionFont = new StyleObject();
		subCaptionFont.name = "_SdSubCaptionFont";
		subCaptionFont.align = "center";
		subCaptionFont.valign = "top";
		subCaptionFont.bold = "1";
		subCaptionFont.font = this.params.outCnvBaseFont;
		subCaptionFont.size = this.params.outCnvBaseFontSize;
		subCaptionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.SUBCAPTION, subCaptionFont, this.styleM.TYPE.FONT, null);
		delete subCaptionFont;
		//-----------------------------------------------------------------//
		//Default font object for YAxisName
		//-----------------------------------------------------------------//
		var yAxisNameFont = new StyleObject();
		yAxisNameFont.name = "_SdYAxisNameFont";
		yAxisNameFont.align = "center";
		yAxisNameFont.valign = "middle";
		yAxisNameFont.bold = "1";
		yAxisNameFont.font = this.params.outCnvBaseFont;
		yAxisNameFont.size = this.params.outCnvBaseFontSize;
		yAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.YAXISNAME, yAxisNameFont, this.styleM.TYPE.FONT, null);
		delete yAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for XAxisName
		//-----------------------------------------------------------------//
		var xAxisNameFont = new StyleObject();
		xAxisNameFont.name = "_SdXAxisNameFont";
		xAxisNameFont.align = "center";
		xAxisNameFont.valign = "middle";
		xAxisNameFont.bold = "1";
		xAxisNameFont.font = this.params.outCnvBaseFont;
		xAxisNameFont.size = this.params.outCnvBaseFontSize;
		xAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.XAXISNAME, xAxisNameFont, this.styleM.TYPE.FONT, null);
		delete xAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for trend lines
		//-----------------------------------------------------------------//
		var trendFont = new StyleObject();
		trendFont.name = "_SdTrendFontFont";
		trendFont.font = this.params.outCnvBaseFont;
		trendFont.size = this.params.outCnvBaseFontSize;
		trendFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TRENDVALUES, trendFont, this.styleM.TYPE.FONT, null);
		this.styleM.overrideStyle(this.objects.VTRENDVALUES, trendFont, this.styleM.TYPE.FONT, null);
		delete trendFont;
		//-----------------------------------------------------------------//
		//Default font object for yAxisValues
		//-----------------------------------------------------------------//
		var yAxisValuesFont = new StyleObject();
		yAxisValuesFont.name = "_SdYAxisValuesFont";
		yAxisValuesFont.align = "right";
		yAxisValuesFont.valign = "middle";
		yAxisValuesFont.font = this.params.outCnvBaseFont;
		yAxisValuesFont.size = this.params.outCnvBaseFontSize;
		yAxisValuesFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.YAXISVALUES, yAxisValuesFont, this.styleM.TYPE.FONT, null);
		delete yAxisValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for DataLabels
		//-----------------------------------------------------------------//
		var dataLabelsFont = new StyleObject();
		dataLabelsFont.name = "_SdDataLabelsFont";
		dataLabelsFont.align = "center";
		dataLabelsFont.valign = "middle";
		dataLabelsFont.font = this.params.catFont;
		dataLabelsFont.size = this.params.catFontSize;
		dataLabelsFont.color = this.params.catFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.DATALABELS, dataLabelsFont, this.styleM.TYPE.FONT, null);
		delete dataLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for Connectors
		//-----------------------------------------------------------------//
		var connectorsLabelsFont = new StyleObject();
		connectorsLabelsFont.name = "_SdConnectorLabelsFont";
		connectorsLabelsFont.align = "center";
		connectorsLabelsFont.valign = "middle";
		connectorsLabelsFont.font = this.params.catFont;
		connectorsLabelsFont.size = this.params.catFontSize;
		connectorsLabelsFont.color = this.params.catFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.CONNECTORLABELS, connectorsLabelsFont, this.styleM.TYPE.FONT, null);
		delete connectorsLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for Legend
		//-----------------------------------------------------------------//
		var legendFont = new StyleObject();
		legendFont.name = "_SdLegendFont";
		legendFont.font = this.params.outCnvBaseFont;
		legendFont.size = this.params.outCnvBaseFontSize;
		legendFont.color = this.params.outCnvBaseFontColor;
		legendFont.ishtml = 1;
		legendFont.leftmargin = 3;
		//Over-ride
		this.styleM.overrideStyle(this.objects.LEGEND, legendFont, this.styleM.TYPE.FONT, null);
		delete legendFont;
		//-----------------------------------------------------------------//
		//Default font object for ToolTip
		//-----------------------------------------------------------------//
		var toolTipFont = new StyleObject();
		toolTipFont.name = "_SdToolTipFont";
		toolTipFont.font = this.params.baseFont;
		toolTipFont.size = this.params.baseFontSize;
		toolTipFont.color = this.params.baseFontColor;
		toolTipFont.bgcolor = this.params.toolTipBgColor;
		toolTipFont.bordercolor = this.params.toolTipBorderColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TOOLTIP, toolTipFont, this.styleM.TYPE.FONT, null);
		delete toolTipFont;
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for Legend
		//-----------------------------------------------------------------//
		if (this.params.legendShadow) {
			var legendShadow = new StyleObject();
			legendShadow.name = "_SdLegendShadow";
			legendShadow.distance = 2;
			legendShadow.angle = 45;
			legendShadow.alpha = 90;
			//Over-ride     
			this.styleM.overrideStyle(this.objects.LEGEND, legendShadow, this.styleM.TYPE.SHADOW, null);
			delete legendShadow;
		}
		//-----------------------------------------------------------------//                                                  
		//Default Animation object for DataConnector (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation) {
			//We need two animation objects.
			//1. XScale for Connectors
			var dataConAnim = new StyleObject();
			dataConAnim.name = "_SdDataConnectorAnimXScale";
			dataConAnim.param = "_xscale";
			dataConAnim.easing = "regular";
			dataConAnim.wait = 0;
			dataConAnim.start = 0;
			dataConAnim.duration = 1.2;
			//Over-ride
			this.styleM.overrideStyle(this.objects.CONNECTOR, dataConAnim, this.styleM.TYPE.ANIMATION, "_xscale");
			delete dataConAnim;
			//2. YScale for Connectors
			var dataConAnimY = new StyleObject();
			dataConAnimY.name = "_SdDataConnectorAnimYScale";
			dataConAnimY.param = "_yscale";
			dataConAnimY.easing = "regular";
			dataConAnimY.start = 0;
			dataConAnimY.duration = 1.2;
			//Over-ride
			this.styleM.overrideStyle(this.objects.CONNECTOR, dataConAnimY, this.styleM.TYPE.ANIMATION, "_yscale");
			delete dataConAnimY;
		}
		//-----------------------------------------------------------------//                                                  
		//Default Animation object for DataPlot (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation) {
			//We need animation objects.
			//1. Alpha effect for Nodes				
			var nodesAnim = new StyleObject();
			nodesAnim.name = "_SdDataNodeAnim";
			nodesAnim.param = "_alpha";
			nodesAnim.easing = "regular";
			nodesAnim.wait = 0;
			nodesAnim.start = 0;
			nodesAnim.duration = 0.5;
			//Over-ride
			this.styleM.overrideStyle(this.objects.DATAPLOT, nodesAnim, this.styleM.TYPE.ANIMATION, "_alpha");
			delete nodesAnim;
		}
		//-----------------------------------------------------------------//                                                      
	}
	/**
	* checkConnectors method checks each connector.
	*/
	private function checkConnectors() {
		//Loop Variable
		var i:Number;
		var j:Number;
		//Check for any duplicacy 
		for (i=1; i<=this.numConnector; i++) {
			//Check for same From and to value for any connector definition
			if(this.connectors[i].from == this.connectors[i].to ) {
				// we neglect this connector and send a warning to logger
				//Add a message to the log.
				this.log ("WARNING", "Invalid connector definition", Logger.LEVEL.ERROR);
				//Remove it from the connectors array
				this.connectors.splice(i, 1);
				//decrease the counter
				this.numConnector--;
				continue;
			}
			for (j=1; j<=this.numConnector; j++) {
				//If i!= j
				if(i!=j) {
					if(this.connectors[i].from == this.connectors[j].from && this.connectors[i].to == this.connectors[j].to ) {
						// we neglect this connector and send a warning to logger
						//Add a message to the log.
						this.log ("WARNING", "Duplicate connector definitions (" + this.connectors[i].from + "," + this.connectors[i].to + ") found. You can connect two nodes only once.", Logger.LEVEL.ERROR);
						//Remove it from the connectors array
						this.connectors.splice(j, 1);
						//decrease the counter
						this.numConnector--;
					}
					else if(this.connectors[i].from == this.connectors[j].to && this.connectors[i].to == this.connectors[j].from) {
						// we neglect this connector and send a warning to logger
						//Add a message to the log.
						this.log ("WARNING", "Duplicate connector definitions (" + this.connectors[i].from + "," + this.connectors[i].to + ") found. You can connect two nodes only using a single connector. For example, if you're connecting node 3,4, you CANNOT again connect 4,3.", Logger.LEVEL.ERROR);						
						//Remove it from the connectors array
						this.connectors.splice(j, 1);
						//decrease the counter
						this.numConnector--;
					}
				}
			}
		}
	}
	/**
	 * getValue method gets the value from the particular 
	 * point on the axis.
	 *	@param	axisPos			Numerical axis position for which we need a particular Value
	 *	@param	upperLimit		Numerical upper limit for that axis
	 *	@param	lowerLimit		Numerical lower limit for that axis
	 *	@param	startAxisPos	Pixel start position for that axis
	 *	@param	endAxisPos		Pixel end position for that axis
	 *	@param	isYAxis			Flag indicating whether it's y axis
	 *	@param	xPadding		Padding at left and right sides in case of a x-axis
	 *	@returns				The pixel position of the value on the given axis.
	*/
	private function getValue(axisPos:Number, upperLimit:Number, lowerLimit:Number, startAxisPos:Number, endAxisPos:Number, isYAxis:Boolean, xPadding:Number):Number {
		//Define variables to be used locally
		var numericalInterval:Number;
		var positionInterval:Number;
		var value:Number;
		//Get the numerical difference between the limits
		numericalInterval = (upperLimit-lowerLimit);
		if (isYAxis) {
			//If it's y axis, the co-ordinates are opposite in Flash
			positionInterval = (endAxisPos-startAxisPos);
			value = (numericalInterval/positionInterval)*(endAxisPos-axisPos)+lowerLimit;
		} else {
			positionInterval = (endAxisPos-startAxisPos)-(2*xPadding);
			value = ((numericalInterval/positionInterval)*(axisPos-startAxisPos-xPadding))+lowerLimit;
		}
		if (value<lowerLimit) {
			value = lowerLimit;
		}
		if (value>upperLimit) {
			value = upperLimit;
		}
		return value;
	}
	/**
	* calculatePoints method calculates the various points on the chart.
	*/
	private function calculatePoints() {
		//Loop variable
		var i:Number;
		var j:Number;
		//Based on label step, set showLabel of each data point as required.
		//Visible label count
		var visibleCount:Number = 0;
		var finalVisibleCount:Number = 0;
		for (i=1; i<=this.numCat; i++) {
			//Now, the label can be preset to be hidden (set via XML)
			if (this.categories[i].isValid && this.categories[i].showLabel) {
				visibleCount++;
				//If label step is defined, we need to set showLabel of those
				//labels which fall on step as false.
				if ((i-1)%this.params.labelStep == 0) {
					this.categories[i].showLabel = true;
				} else {
					this.categories[i].showLabel = false;
				}
			}
			//Update counter     
			finalVisibleCount = (this.categories[i].showLabel) ? (finalVisibleCount+1) : (finalVisibleCount);
		}		
		//We now need to calculate the available Width on the canvas.
		//Available width = total Chart width minus the list below
		// - Left and Right Margin
		// - yAxisName (if to be shown)
		// - yAxisValues
		// - Trend line display values (both left side and right side).
		// - Legend (If to be shown at right)
		var canvasWidth:Number = this.width-(this.params.chartLeftMargin+this.params.chartRightMargin);
		//Set canvas startX
		var canvasStartX:Number = this.params.chartLeftMargin;
		//Now, if y-axis name is to be shown, simulate it and get the width
		if (this.params.yAxisName != "") {
			//Get style object
			var yAxisNameStyle:Object = this.styleM.getTextStyle(this.objects.YAXISNAME);
			if (this.params.rotateYAxisName) {
				//Set embedded font - as we need to rotate
				yAxisNameStyle.font = _embeddedFont;
				//Un-bold and un-italicize
				yAxisNameStyle.bold = false;
				yAxisNameStyle.italic = false;
				//Create text field to get width
				var yAxisNameObj:Object = createText(true, this.params.yAxisName, this.tfTestMC, 1, testTFX, testTFY, 90, yAxisNameStyle, false, 0, 0);
				//Accomodate width and padding
				canvasStartX = canvasStartX+yAxisNameObj.width+this.params.yAxisNamePadding;
				canvasWidth = canvasWidth-yAxisNameObj.width-this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.yAxisName = returnDataAsElement(0, 0, yAxisNameObj.width, yAxisNameObj.height);
			} else {
				//If the y-axis name is not to be rotated
				//Calculate the width of the text if in full horizontal mode
				//Create text field to get width
				var yAxisNameObj:Object = createText(true, this.params.yAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, yAxisNameStyle, false, 0, 0);
				//Get a value for this.params.yAxisNameWidth
				this.params.yAxisNameWidth = Number(getFV(this.params.yAxisNameWidth, yAxisNameObj.width));
				//Get the lesser of the width (to avoid un-necessary space)				
				this.params.yAxisNameWidth = Math.min(this.params.yAxisNameWidth, yAxisNameObj.width);
				//Accomodate width and padding
				canvasStartX = canvasStartX+this.params.yAxisNameWidth+this.params.yAxisNamePadding;
				canvasWidth = canvasWidth-this.params.yAxisNameWidth-this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.yAxisName = returnDataAsElement(0, 0, this.params.yAxisNameWidth, yAxisNameObj.height);
			}
			delete yAxisNameStyle;
			delete yAxisNameObj;
		}
		//Accomodate width for y-axis values. Now, y-axis values conists of two parts         
		//(for backward compatibility) - limits (upper and lower) and div line values.
		//So, we'll have to individually run through both of them.
		var yAxisValMaxWidth:Number = 0;
		var divLineObj:Object;
		var divStyle:Object = this.styleM.getTextStyle(this.objects.YAXISVALUES);
		//Iterate through all the div line values
		for (i=1; i<this.divLines.length; i++) {
			//If div line value is to be shown
			if (this.divLines[i].showValue) {
				//If it's the first or last div Line (limits), and it's to be shown
				if ((i == 1) || (i == this.divLines.length-1)) {
					if (this.params.showLimits) {
						//Get the width of the text
						divLineObj = createText(true, this.divLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width>yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
					}
				} else {
					//It's a div interval - div line
					//So, check if we've to show div line values
					if (this.params.showDivLineValues) {
						//Get the width of the text
						divLineObj = createText(true, this.divLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width>yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
					}
				}
			}
		}
		delete divLineObj;
		//Also iterate through all trend lines whose values are to be shown on
		//left side of the canvas.
		//Get style object
		var trendStyle:Object = this.styleM.getTextStyle(this.objects.TRENDVALUES);
		var trendObj:Object;
		for (i=1; i<=this.numTrendLines; i++) {
			if (this.trendLines[i].isValid == true && this.trendLines[i].valueOnRight == false) {
				//If it's a valid trend line and value is to be shown on left
				//Get the width of the text
				trendObj = createText(true, this.trendLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				yAxisValMaxWidth = (trendObj.width>yAxisValMaxWidth) ? (trendObj.width) : (yAxisValMaxWidth);
			}
		}
		//Accomodate for y-axis/left-trend line values text width
		if (yAxisValMaxWidth>0) {
			canvasStartX = canvasStartX+yAxisValMaxWidth+this.params.yAxisValuesPadding;
			canvasWidth = canvasWidth-yAxisValMaxWidth-this.params.yAxisValuesPadding;
		}
		var trendRightWidth:Number = 0;
		//Now, also check for trend line values that fall on right
		for (i=1; i<=this.numTrendLines; i++) {
			if (this.trendLines[i].isValid == true && this.trendLines[i].valueOnRight == true) {
				//If it's a valid trend line and value is to be shown on right
				//Get the width of the text
				trendObj = createText(true, this.trendLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				trendRightWidth = (trendObj.width>trendRightWidth) ? (trendObj.width) : (trendRightWidth);
			}
		}
		delete trendObj;
		//Accomodate trend right text width
		if (trendRightWidth>0) {
			canvasWidth = canvasWidth-trendRightWidth-this.params.yAxisValuesPadding;
		}
		//Round them off finally to avoid distorted pixels    
		canvasStartX = int(canvasStartX);
		canvasWidth = int(canvasWidth);
		//We finally have canvas Width and canvas Start X
		//-----------------------------------------------------------------------------------//
		//Now, we need to calculate the available Height on the canvas.
		//Available height = total Chart height minus the list below
		// - Chart Top and Bottom Margins
		// - Space for Caption, Sub Caption and caption padding
		// - Height of data labels
		// - xAxisName
		// - Vertical trend line values
		// - Legend (If to be shown at bottom position)
		//Initialize canvasHeight to total height minus margins
		var canvasHeight:Number = this.height-(this.params.chartTopMargin+this.params.chartBottomMargin);
		//Set canvasStartY
		var canvasStartY:Number = this.params.chartTopMargin;
		//Now, if we've to show caption
		if (this.params.caption != "") {
			//Create text field to get height
			var captionObj:Object = createText(true, this.params.caption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.CAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+captionObj.height;
			canvasHeight = canvasHeight-captionObj.height;
			//Create element for caption - to store width & height
			this.elements.caption = returnDataAsElement(0, 0, captionObj.width, captionObj.height);
			delete captionObj;
		}
		//Now, if we've to show sub-caption         
		if (this.params.subCaption != "") {
			//Create text field to get height
			var subCaptionObj:Object = createText(true, this.params.subCaption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.SUBCAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+subCaptionObj.height;
			canvasHeight = canvasHeight-subCaptionObj.height;
			//Create element for sub caption - to store height
			this.elements.subCaption = returnDataAsElement(0, 0, subCaptionObj.width, subCaptionObj.height);
			delete subCaptionObj;
		}
		//Now, if either caption or sub-caption was shown, we also need to adjust caption padding         
		if (this.params.caption != "" || this.params.subCaption != "") {
			//Account for padding
			canvasStartY = canvasStartY+this.params.captionPadding;
			canvasHeight = canvasHeight-this.params.captionPadding;
		}
		//Now, if data labels are to be shown, we need to account for their heights     
		//Data labels can be rendered in 3 ways:
		//1. Normal - no staggering - no wrapping - no rotation
		//2. Wrapped - no staggering - no rotation
		//3. Staggered - no wrapping - no rotation
		//4. Rotated - no staggering - no wrapping
		//Placeholder to store max height
		this.config.maxLabelHeight = 0;
		this.config.labelAreaHeight = 0;
		var labelObj:Object;
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
		if (this.params.labelDisplay == "ROTATE") {
			//Case 4: If the labels are rotated, we iterate through all the string labels
			//provided to us and get the height and store max.
			for (i=1; i<=this.numCat; i++) {
				//If the label is to be shown
				if (this.categories[i].isValid && this.categories[i].showLabel) {
					//Set style bold/italic to false and font to embedded font
					labelStyleObj.font = _embeddedFont;
					labelStyleObj.bold = false;
					labelStyleObj.italic = false;
					//Create text box and get height
					labelObj = createText(true, this.categories[i].label, this.tfTestMC, 1, testTFX, testTFY, this.config.labelAngle, labelStyleObj, false, 0, 0);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else if (this.params.labelDisplay == "WRAP") {
			//Case 2 (WRAP): Create all the labels on the chart. Set width as
			//totalAvailableWidth/finalVisibleCount.
			//Set max height as 50% of available canvas height at this point of time. Find all
			//and select the max one.
			var maxLabelWidth:Number = (canvasWidth/finalVisibleCount);
			var maxLabelHeight:Number = (canvasHeight/2);
			//Store it in config for later usage
			this.config.wrapLabelWidth = maxLabelWidth;
			this.config.wrapLabelHeight = maxLabelHeight;
			for (i=1; i<=this.numCat; i++) {
				//If the label is to be shown
				if (this.categories[i].isValid && this.categories[i].showLabel) {
					//Create text box and get height
					labelObj = createText(true, this.categories[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, true, maxLabelWidth, maxLabelHeight);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else {
			//Case 1,3: Normal or Staggered Label
			//We iterate through all the labels, and if any of them has &lt or < (HTML marker)
			//embedded in them, we add them to the array, as for them, we'll need to individually
			//create and see the text height. Also, the first element in the array - we set as
			//ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=....
			//Create array to store labels.
			var strLabels:Array = new Array();
			strLabels.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=/*-+~`");
			//Now, iterate through all the labels and for those visible labels, whcih have < sign,
			//add it to array.
			for (i=1; i<=this.numCat; i++) {
				//If the label is to be shown
				if (this.categories[i].isValid && this.categories[i].showLabel) {
					if ((this.categories[i].label.indexOf("&lt;")>-1) || (this.categories[i].label.indexOf("<")>-1)) {
						strLabels.push(this.categories[i].label);
					}
				}
			}
			//Now, we've the array for which we've to check height (for each element).
			for (i=0; i<strLabels.length; i++) {
				//Create text box and get height
				labelObj = createText(true, this.categories[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, false, 0, 0);
				//Store the larger
				this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
			}
			//We now have the max label height. If it's staggered, then store accordingly, else
			//simple mode
			if (this.params.labelDisplay == "STAGGER") {
				//Multiply max label height by stagger lines.
				this.config.labelAreaHeight = this.params.staggerLines*this.config.maxLabelHeight;
			} else {
				this.config.labelAreaHeight = this.config.maxLabelHeight;
			}
		}
		if (this.config.labelAreaHeight>0) {
			//Deduct the calculated label height from canvas height
			canvasHeight = canvasHeight-this.config.labelAreaHeight-this.params.labelPadding;
		}
		//Delete objects       
		delete labelObj;
		delete labelStyleObj;
		
		//If any vertical trend line values are to be shown
		var trendObj:Object;
		var trendStyle:Object = this.styleM.getTextStyle(this.objects.TRENDVALUES);
		var trendHeight:Number = 0;
		//Now, also check for trend line values that fall on right
		this.config.vTrendHeight = 0;
		for (i=1; i<=this.numVTrendLines; i++) {
			if (this.vTrendLines[i].isValid == true) {
				//If it's a valid trend line
				//Get the height of the text
				trendObj = createText(true, this.vTrendLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				trendHeight = (trendObj.height>trendHeight) ? (trendObj.height) : (trendHeight);				
			}
		}		
		delete trendObj;
		//Accomodate
		if (trendHeight>0){
			canvasHeight = canvasHeight-trendHeight;
			//Store vertical trend line text height - will be used later to adjust x-axis name.
			this.config.vTrendHeight = trendHeight;
		}		
		//Accomodate space for xAxisName (if to be shown);
		if (this.params.xAxisName != "") {
			//Create text field to get height
			var xAxisNameObj:Object = createText(true, this.params.xAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.XAXISNAME), false, 0, 0);
			//Store the height
			canvasHeight = canvasHeight-xAxisNameObj.height-this.params.xAxisNamePadding;
			//Object to store width and height of xAxisName
			this.elements.xAxisName = returnDataAsElement(0, 0, xAxisNameObj.width, xAxisNameObj.height);
			delete xAxisNameObj;
		}
		//We now check whether the form Button is to be shown
		if (this.params.showFormBtn){
			//Width of the form Button
			var btnWidth:Number = this.params.formBtnWidth;
			//Height of the form Button
			var btnHeight:Number = 20;
			//Now deduct the height from the calculated canvas height
			canvasHeight = canvasHeight-btnHeight-this.params.btnPadding;
			//Set the button position
			this.elements.btn = returnDataAsElement(this.width - this.params.chartRightMargin - btnWidth - this.params.btnPadding, this.height - this.params.chartBottomMargin - btnHeight/2- this.params.btnPadding, btnWidth, btnHeight); 
		}
		//We have canvas start Y and canvas height     
		//We now check whether the legend is to be drawn 
		if (this.params.showLegend){
			//Object to store dimensions
			var lgndDim:Object;
			//Create container movie clip for legend
			this.lgndMC = this.cMC.createEmptyMovieClip("Legend",this.dm.getDepth("LEGEND"));
			//Create instance of legend			
			if (this.params.legendPosition=="BOTTOM"){
				//Maximum Height - 50% of stage
				lgnd = new Legend(lgndMC, this.styleM.getTextStyle(this.objects.LEGEND), this.params.legendPosition, canvasStartX + canvasWidth/2, this.height/2, canvasWidth, (this.height-(this.params.chartTopMargin+this.params.chartBottomMargin))*0.5, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor);
			}
			else {
				//Maximum Width - 40% of stage
				lgnd = new Legend(lgndMC, this.styleM.getTextStyle(this.objects.LEGEND), this.params.legendPosition, this.width/2, canvasStartY + canvasHeight/2, (this.width-(this.params.chartLeftMargin+this.params.chartRightMargin))*0.4, canvasHeight, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor);			
			}
			//Feed data set series Name for legend
			for (i=1; i<=this.numDS; i++){
				if (this.dataset[i].includeInLegend && this.dataset[i].seriesName!=""){
					lgnd.addItem(this.dataset[i].seriesName, this.dataset[i].color);
				}
			}			
			//If user has defined a caption for the legend, set it
			if (this.params.legendCaption!=""){
				lgnd.setCaption(this.params.legendCaption);
			}
			//Whether to use circular marker
			lgnd.useCircleMarker(this.params.legendMarkerCircle);
			if (this.params.legendPosition=="BOTTOM"){
				lgndDim = lgnd.getDimensions();
				//Now deduct the height from the calculated canvas height
				canvasHeight = canvasHeight-lgndDim.height-this.params.legendPadding;
				//Re-set the legend position
				this.lgnd.resetXY(canvasStartX + canvasWidth/2, this.height - this.params.chartBottomMargin - lgndDim.height/2);
				//If the button has to be shown then we subtract the button height to locate the
				//lengend position correctly
				if(this.params.showFormBtn) {
					//Re-set the legend position
					this.lgnd.resetXY(canvasStartX + canvasWidth/2, this.elements.btn.y - this.params.btnPadding - this.elements.btn.h/2 +this.params.legendPadding -lgndDim.height/2);
				}
				else {
					//Re-set the legend position
					this.lgnd.resetXY(canvasStartX + canvasWidth/2, this.height - this.params.chartBottomMargin - lgndDim.height/2);
				}
			}
			else{
				//Get dimensions
				lgndDim = lgnd.getDimensions();
				//Now deduct the width from the calculated canvas width
				canvasWidth = canvasWidth-lgndDim.width-this.params.legendPadding;
				//Right position
				this.lgnd.resetXY(this.width - this.params.chartRightMargin - lgndDim.width/2, canvasStartY + canvasHeight/2);
			}
		}
		//Create an element to represent the canvas now.
		this.elements.canvas = returnDataAsElement(canvasStartX, canvasStartY, canvasWidth, canvasHeight);
		
		//Format all the numbers on the chart and store their display values
		//We format and store here itself, so that later, whenever needed,
		//we just access displayValue instead of formatting once again.
		//Also set tool tip text values
		var toolText:String;
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.dataset[i].num; j++) {
				//Format and store
				this.dataset[i].data[j].displayValue = formatNumber(this.dataset[i].data[j].yv, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
				//Tool tip text.
				//Preferential Order - Set Tool Text (No concatenation) > SeriesName + Cat Name + Value
				if (this.dataset[i].data[j].toolText == undefined || this.dataset[i].data[j].toolText == "") {
					//If the tool tip text is not already defined
					//If labels have been defined
					toolText = (this.params.seriesNameInToolTip && this.dataset[i].seriesName != "") ? (this.dataset[i].seriesName+this.params.toolTipSepChar) : "";
					toolText = toolText+this.dataset[i].data[j].xv+this.params.toolTipSepChar;
					toolText = toolText+this.dataset[i].data[j].displayValue;
					this.dataset[i].data[j].toolText = toolText;
				}
			}
		}
		//Calculate x-position of categories
		for (i=1; i<=this.numCat; i++) {
			//If categories is within the valid range
			if (this.categories[i].xv<this.config.xMin || this.categories[i].xv>this.config.xMax) {
				this.categories[i].isValid = false;
			}
			this.categories[i].x = this.getAxisPosition(this.categories[i].xv, this.config.xMax, this.config.xMin, this.elements.canvas.x, this.elements.canvas.toX, false, 0);
		}
		//We now need to calculate the position of points on the chart.
		for (i=1; i<=this.numDS; i++) {
			//Now, store the positions of the points
			for (j=1; j<=this.dataset[i].num; j++) {
				//Store the central point of the rectangle as the x and y position of the node
				this.dataset[i].data[j].x = this.getAxisPosition(this.dataset[i].data[j].xv, this.config.xMax, this.config.xMin, this.elements.canvas.x, this.elements.canvas.toX, false, 0);
				//Set the y position
				this.dataset[i].data[j].y = this.getAxisPosition(this.dataset[i].data[j].yv, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
			}
		}
		//We now check each connectors
		this.checkConnectors();
		//Enable links and disable drag if link is defined
		if(this.config.linksDefined && this.params.enableLink) {
			this.config.enableLinks = true;
			this.config.enableDrag = false;
		} else {
			this.config.enableDrag = true;
		}
	}
	/**
	 * getDSIndex method returns the index to dataitem for each connector
	*/
	private function getDSIndex(from:String, to:String):Object {
		//Variables		
		var i:Number, j:Number;
		var fromDsIndex:Number = -1;
		var fromIndex:Number = -1;
		var toDsIndex:Number = -1;
		var toIndex:Number = -1;
		//Create an Object to return
		var indexObj:Object = new Object();
		//Iterate through all Nodes
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.dataset[i].num; j++) {
				//If defined and id's are valid
				if (this.dataset[i].data[j].isDefined && this.dataset[i].data[j].id!="") {
					if (this.dataset[i].data[j].id == from) {
						//Store the from indexes
						fromDsIndex = i;
						fromIndex = j;
					}
					if (this.dataset[i].data[j].id  == to) {
						//Store the to indexes
						toDsIndex = i;
						toIndex = j;
					}
				}
			}
		}
		//Store the values in an object
		indexObj.fromDsIndex = fromDsIndex;
		indexObj.fromIndex = fromIndex;
		indexObj.toDsIndex = toDsIndex;
		indexObj.toIndex = toIndex;
		return indexObj;
	}
	/**
	 * allotDepths method allots the depths for various chart objects
	 * to be rendered. We do this before hand, so that we can later just
	 * go on rendering chart objects, without swapping.
	*/
	private function allotDepths():Void {
		//Background
		this.dm.reserveDepths("BACKGROUND", 1);
		//Click URL Handler
		this.dm.reserveDepths("CLICKURLHANDLER", 1);
		//Background SWF
		this.dm.reserveDepths("BGSWF", 1);
		//Canvas
		this.dm.reserveDepths("CANVAS", 1);
		//If horizontal grid is to be shown    
		if (this.params.showAlternateHGridColor) {
			this.dm.reserveDepths("HGRID", Math.ceil((this.divLines.length+1)/2));
		}
		//Div Lines and their labels                                                  
		this.dm.reserveDepths("DIVLINES", (this.divLines.length*2));
		//Vertical div lines
		this.dm.reserveDepths("VLINES", this.numCat);
		//Zero Plane
		this.dm.reserveDepths("ZEROPLANE", 2);
		//Caption
		this.dm.reserveDepths("CAPTION", 1);
		//Sub-caption
		this.dm.reserveDepths("SUBCAPTION", 1);
		//X-Axis Name
		this.dm.reserveDepths("XAXISNAME", 1);
		//Y-Axis Name
		this.dm.reserveDepths("YAXISNAME", 1);
		//Vertical trend lines
		this.dm.reserveDepths("VTRENDLINES", this.numVTrendLines);
		this.dm.reserveDepths("VTRENDVALUES", this.numVTrendLines);
		//Horizontal Trend lines below plot (lines and their labels)
		this.dm.reserveDepths("TRENDLINESBELOW", this.numTrendLinesBelow);
		this.dm.reserveDepths("TRENDVALUESBELOW", this.numTrendLinesBelow);
		//Data Labels
		this.dm.reserveDepths("DATALABELS", this.numCat);
		//Canvas Border
		this.dm.reserveDepths("CANVASBORDER", 1);
		//Nodes Connector
		this.dm.reserveDepths("DATACONNECTOR", 1);
		//Horizontal Trend lines below plot (lines and their labels)
		this.dm.reserveDepths("TRENDLINESABOVE", (this.numTrendLines-this.numTrendLinesBelow));
		this.dm.reserveDepths("TRENDVALUESABOVE", (this.numTrendLines-this.numTrendLinesBelow));
		//Legend 
		this.dm.reserveDepths("LEGEND", 1);
		//Nodes
		this.dm.reserveDepths("DATAPLOT", 1);
		//Edit Nodes
		this.dm.reserveDepths("EDITNODE", 1);
		//Connector's Db
		this.dm.reserveDepths("CONNECTORDB", 1);
		//Drag Cursor
		this.dm.reserveDepths("DRAGCURSOR", 1);
	}
	//--------------- VISUAL RENDERING METHODS -------------------------//
	/**
	* drawHeaders method renders the following on the chart:
	* CAPTION, SUBCAPTION, XAXISNAME, YAXISNAME
	*/
	private function drawHeaders() {
		//Render caption
		if (this.params.caption != "") {
			var captionStyleObj:Object = this.styleM.getTextStyle(this.objects.CAPTION);
			captionStyleObj.align = "center";
			captionStyleObj.vAlign = "bottom";
			var captionObj:Object = createText(false, this.params.caption, this.cMC, this.dm.getDepth("CAPTION"), this.elements.canvas.x+(this.elements.canvas.w/2), this.params.chartTopMargin, 0, captionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(captionObj.tf, this.objects.CAPTION, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.caption.w/2), 0, this.params.chartTopMargin, 0, 100, null, null, null);
			}
			//Apply filters                                                           
			this.styleM.applyFilters(captionObj.tf, this.objects.CAPTION);
			//Delete
			delete captionObj;
			delete captionStyleObj;
		}
		//Render sub caption                                                           
		if (this.params.subCaption != "") {
			var subCaptionStyleObj:Object = this.styleM.getTextStyle(this.objects.SUBCAPTION);
			subCaptionStyleObj.align = "center";
			subCaptionStyleObj.vAlign = "top";
			var subCaptionObj:Object = createText(false, this.params.subCaption, this.cMC, this.dm.getDepth("SUBCAPTION"), this.elements.canvas.x+(this.elements.canvas.w/2), this.elements.canvas.y-this.params.captionPadding, 0, subCaptionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(subCaptionObj.tf, this.objects.SUBCAPTION, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.subCaption.w/2), 0, this.elements.canvas.y-this.params.captionPadding-this.elements.subCaption.h, 0, 100, null, null, null);
			}
			//Apply filters                                                           
			this.styleM.applyFilters(subCaptionObj.tf, this.objects.SUBCAPTION);
			//Delete
			delete subCaptionObj;
			delete subCaptionStyleObj;
		}
		//Render x-axis name                                                           
		if (this.params.xAxisName != "") {
			var xAxisNameStyleObj:Object = this.styleM.getTextStyle(this.objects.XAXISNAME);
			xAxisNameStyleObj.align = "center";
			xAxisNameStyleObj.vAlign = "bottom";
			var xAxisNameObj:Object = createText(false, this.params.xAxisName, this.cMC, this.dm.getDepth("XAXISNAME"), this.elements.canvas.x+(this.elements.canvas.w/2), this.elements.canvas.toY+this.params.labelPadding+this.config.labelAreaHeight+this.params.xAxisNamePadding+this.config.vTrendHeight, 0, xAxisNameStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(xAxisNameObj.tf, this.objects.XAXISNAME, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.subCaption.w/2), 0, this.elements.canvas.toY+this.config.labelAreaHeight+this.params.xAxisNamePadding, 0, 100, null, null, null);
			}
			//Apply filters                                                           
			this.styleM.applyFilters(xAxisNameObj.tf, this.objects.XAXISNAME);
			//Delete
			delete xAxisNameObj;
			delete xAxisNameStyleObj;
		}
		//Render y-axis name                                                           
		if (this.params.yAxisName != "") {
			var yAxisNameStyleObj:Object = this.styleM.getTextStyle(this.objects.YAXISNAME);
			//Set alignment parameters
			yAxisNameStyleObj.align = "left";
			yAxisNameStyleObj.vAlign = "middle";
			//If the name is to be rotated
			if (this.params.rotateYAxisName) {
				//Set font as the embedded font
				yAxisNameStyleObj.font = _embeddedFont;
				//Set bold/italic to false.
				yAxisNameStyleObj.bold = false;
				yAxisNameStyleObj.italic = false;
				var yAxisNameObj:Object = createText(false, this.params.yAxisName, this.cMC, this.dm.getDepth("YAXISNAME"), this.params.chartLeftMargin, this.elements.canvas.y+(this.elements.canvas.h/2), 270, yAxisNameStyleObj, false, 0, 0);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.params.chartLeftMargin, 0, this.elements.canvas.y+(this.elements.canvas.h/2)+(this.elements.yAxisName.h/2), 0, 100, null, null, null);
				}
			} else {
				//We show horizontal name
				//Adding 1 to this.params.yAxisNameWidth and then passing to avoid line breaks				
				var yAxisNameObj:Object = createText(false, this.params.yAxisName, this.cMC, this.dm.getDepth("YAXISNAME"), this.params.chartLeftMargin, this.elements.canvas.y+(this.elements.canvas.h/2), 0, yAxisNameStyleObj, true, this.params.yAxisNameWidth+1, this.elements.canvas.h);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.params.chartLeftMargin, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}
			//Apply filters     
			this.styleM.applyFilters(yAxisNameObj.tf, this.objects.YAXISNAME);
			//Delete
			delete yAxisNameObj;
			delete yAxisNameStyleObj;
		}
		//Clear Interval                                                           
		clearInterval(this.config.intervals.headers);
	}
	/**
	* drawLabels method draws the x-axis labels based on the parameters.
	*/
	private function drawLabels() {
		var labelObj:Object;
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
		var labelYShift:Number;
		var staggerCycle:Number = 0;
		var staggerAddFn:Number = 1;
		var depth:Number = this.dm.getDepth("DATALABELS");
		var i:Number;
		for (i=1; i<=this.numCat; i++) {
			//If the label is to be shown
			if (this.categories[i].isValid && this.categories[i].showLabel) {
				if (this.params.labelDisplay == "ROTATE") {
					//Set style bold/italic to false and font to embedded font
					labelStyleObj.font = _embeddedFont;
					labelStyleObj.bold = false;
					labelStyleObj.italic = false;
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Create text box and get height
					labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.categories[i].x, this.elements.canvas.toY+this.params.labelPadding, this.config.labelAngle, labelStyleObj, false, 0, 0);
				} else if (this.params.labelDisplay == "WRAP") {
					//Case 2 (WRAP)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.categories[i].x, this.elements.canvas.toY+this.params.labelPadding, 0, labelStyleObj, true, this.config.wrapLabelWidth, this.config.wrapLabelHeight);
				} else if (this.params.labelDisplay == "STAGGER") {
					//Case 3 (Stagger)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Need to get cyclic position for staggered textboxes
					//Matrix formed is of 2*this.params.staggerLines - 2 rows
					var pos:Number = i%(2*this.params.staggerLines-2);
					//Last element needs to be reset
					pos = (pos == 0) ? (2*this.params.staggerLines-2) : pos;
					//Cyclic iteration
					pos = (pos>this.params.staggerLines) ? (this.params.staggerLines-(pos%this.params.staggerLines)) : pos;
					//Get position to 0 base
					pos--;
					//Shift accordingly
					var labelYShift:Number = this.config.maxLabelHeight*pos;
					labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.categories[i].x, this.elements.canvas.toY+this.params.labelPadding+labelYShift, 0, labelStyleObj, false, 0, 0);
				} else {
					//Render normal label
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.categories[i].x, this.elements.canvas.toY+this.params.labelPadding, 0, labelStyleObj, false, 0, 0);
				}
				//Apply filter
				this.styleM.applyFilters(labelObj.tf, this.objects.DATALABELS);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(labelObj.tf, this.objects.DATALABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
				}
				//Increase depth                                                  
				depth++;
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.labels);
	}
	/**
	 * drawConnectors method draws the connectors on the chart
	*/
	private function drawConnectors():Void {
		//Variables		
		var i:Number;
		var fromRadius:Number, toRadius:Number;
		var connectorDepth:Number = this.dm.getDepth("DATACONNECTOR");
		//Create the connector container MC
		var connectorCont:MovieClip = this.cMC.createEmptyMovieClip("ConnectorContainer", connectorDepth);
		//Delegate the column Listener onResizeEnd Function
		connectorDelListener.onConnectorDelete = Delegate.create(this, onConnectorDelete);
		//Iterate through all connectors
		for (i=1; i<=this.numConnector; i++) {
			//Get the Node index to which it connects to.
			var DSIndex:Object = this.getDSIndex(this.connectors[i].from, this.connectors[i].to);
			//Check whether the to and from are a valid index to Dataset
			if(DSIndex.fromDsIndex != -1 && DSIndex.fromIndex != -1 && DSIndex.toDsIndex != -1 && DSIndex.toIndex != -1 ) {
				//Add it to the conList for fromDS and toDS
				this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].conList.push(i);
				this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].conList.push(i);
				//Create an empty movie clip for this connector
				var connectorMC:MovieClip = connectorCont.createEmptyMovieClip("Connector_"+i, i);
				//Store the cosmetic property in an Object and pass it to its constructor
				var lineProp:Object = new Object();
				lineProp.color = this.connectors[i].color;
				lineProp.alpha = this.connectors[i].alpha;
				lineProp.thickness = this.connectors[i].strength*this.params.stdThickness;
				lineProp.dashed = this.connectors[i].dashed;
				lineProp.dashLen = this.connectors[i].dashLen;
				lineProp.dashGap = this.connectors[i].dashGap;
				var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.CONNECTORLABELS);
				labelStyleObj.bgColor = this.connectors[i].color;
				//Create an object to place the position of the connector
				var posObj:Object = new Object();
				posObj.fromX = this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].x;
				posObj.fromY = this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].y;
				posObj.toX = this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].x;
				posObj.toY = this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].y;
				//If Polygon or circle then send the radius of connecting datasets
				if(this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].shape.toUpperCase()=="POLYGON" || this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].shape.toUpperCase()=="CIRCLE") {
					toRadius = this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].r;
				}
				else if(this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].shape.toUpperCase()=="RECTANGLE") {
					//Send the diagonal/2
					toRadius = Math.sqrt(Math.pow(this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].h,2)+ Math.pow(this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].w,2))/2;
				}
				if(this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].shape.toUpperCase()=="POLYGON" || this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].shape.toUpperCase()=="CIRCLE") {
					fromRadius = this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].r;
				}
				else if(this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].shape.toUpperCase()=="RECTANGLE") {
					//Send diagonal/2
					fromRadius = Math.sqrt(Math.pow(this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].h,2)+ Math.pow(this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].w,2))/2;
				}
				//Create an instance of the connector class
				var connectorIns:NodeConnector = new NodeConnector(connectorMC, i, this.connectors[i].label, posObj, lineProp, labelStyleObj, fromRadius, toRadius, this.connectors[i].arrowAtStart, this.connectors[i].arrowAtEnd, this.connectors[i].strength, this.params.viewMode);
				//Register the listener
				connectorIns.addEventListener("onConnectorDelete", connectorDelListener);
				//Add to stack
				this.addToListenerStk(connectorIns, "onConnectorDelete", connectorDelListener);
				//Draw the connector
				connectorIns.draw();
				//Apply animation
				if (this.params.animation) {
					//Set the container central registration point
					connectorCont._x = 0;
					connectorCont._y = 0;
					//Get the reference of the connector MovieClip
					var connectorRef:MovieClip  = eval(connectorMC+".Connector");
					//Define the animation style for the connectors
					this.styleM.applyAnimation(connectorRef, this.objects.CONNECTOR, this.macro, connectorRef._x, 0, connectorRef._y, 0, 100, 100, 100, null);
				}
				//Apply filters                                                           
				this.styleM.applyFilters(connectorMC, this.objects.CONNECTOR);
				//Delete
				delete lineProp;
				delete connectorIns;
				delete posObj;
			}
			else {
				//Make a logger entry
				this.log ("ERROR", "Invalid connector (From-"+this.connectors[i].from+" To- "+ this.connectors[i].to+")", Logger.LEVEL.ERROR);
				//Delete this connector from the list
				this.connectors.splice(i, 1);
				//decrease the counter
				this.numConnector--;
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.connectors);
	}
	/**
	 * reDrawConnectors method redraws the connectors on the chart
	*/
	private function reDrawConnectors(conList:Array):Void {
		//Variables		
		var i:Number;
		var fromRadius:Number, toRadius:Number;
		//get the reference to container MC
		var connectorCont:MovieClip = eval(this.cMC+".ConnectorContainer");
		//Delegate the column Listener onResizeEnd Function
		connectorDelListener.onConnectorDelete = Delegate.create(this, onConnectorDelete);
		//Iterate through the list of connectors
		for (i=0; i<conList.length; i++) {
			//Get the reference to the connector
			var connectorMC:MovieClip = eval(connectorCont+".Connector_"+(conList[i]));
			//clear the previously drawn connectors
			connectorMC.clear();
			//Store the cosmetic property in an Object and pass it to its constructor
			var lineProp:Object = new Object();
			lineProp.color = this.connectors[conList[i]].color;
			lineProp.alpha = this.connectors[conList[i]].alpha;
			lineProp.thickness = this.connectors[conList[i]].strength*this.params.stdThickness;
			lineProp.dashed = this.connectors[conList[i]].dashed;
			lineProp.dashLen = this.connectors[conList[i]].dashLen;
			lineProp.dashGap = this.connectors[conList[i]].dashGap;
			//Get the Node index to which it connects to.
			var DSIndex:Object = this.getDSIndex(this.connectors[conList[i]].from, this.connectors[conList[i]].to);
			//Check whether the to and from are a valid index to Dataset
			if(DSIndex.fromDsIndex != -1 && DSIndex.fromIndex != -1 && DSIndex.toDsIndex != -1 && DSIndex.toIndex != -1 ) {
				//Create an object to place the position of the connector
				var posObj:Object = new Object();
				posObj.fromX = this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].x;
				posObj.fromY = this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].y;
				posObj.toX = this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].x;
				posObj.toY = this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].y;
				var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.CONNECTORLABELS);
				labelStyleObj.bgColor = this.connectors[conList[i]].color;
				//If Polygon or circle then send the radius of connecting datasets
				if(this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].shape.toUpperCase()=="POLYGON" || this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].shape.toUpperCase()=="CIRCLE") {
					toRadius = this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].r;
				}
				else if(this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].shape.toUpperCase()=="RECTANGLE") {
					//Send the diagonal/2
					toRadius = Math.sqrt(Math.pow(this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].h,2)+ Math.pow(this.dataset[DSIndex.toDsIndex].data[DSIndex.toIndex].w,2))/2;
				}
				if(this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].shape.toUpperCase()=="POLYGON" || this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].shape.toUpperCase()=="CIRCLE") {
					fromRadius = this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].r;
				}
				else if(this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].shape.toUpperCase()=="RECTANGLE") {
					//Send diagonal/2
					fromRadius = Math.sqrt(Math.pow(this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].h,2)+ Math.pow(this.dataset[DSIndex.fromDsIndex].data[DSIndex.fromIndex].w,2))/2;
				}
				//Create an instance of the connector class
				var connectorIns:NodeConnector = new NodeConnector(connectorMC, conList[i], this.connectors[conList[i]].label, posObj, lineProp, labelStyleObj, fromRadius, toRadius, this.connectors[conList[i]].arrowAtStart, this.connectors[conList[i]].arrowAtEnd, this.connectors[conList[i]].strength, this.params.viewMode);
				//Register the listener
				connectorIns.addEventListener("onConnectorDelete", connectorDelListener);
				//Add to stack
				this.addToListenerStk(connectorIns, "onConnectorDelete", connectorDelListener);
				//Draw the connector
				connectorIns.draw();
				//Delete
				delete lineProp;
				delete connectorIns;
				delete posObj;
			}
		}
	}
	/** 
	* drawDragCursor method draws a resize handler Mouse Cursor
	*/
	public function drawDragCursor():Void {
		//Get the depth
		var depth:Number = this.dm.getDepth("DRAGCURSOR");
		//Create the movie clip for drag cursor
		this.dragCursorMC = this.cMC.createEmptyMovieClip("DragCursorMC", depth);
		//Hide the cursor initially
		this.dragCursorMC._visible = false;
		//First  Draw the UPDOWN arrow
		//Start Filling
		this.dragCursorMC.beginFill(parseInt("000000", 16), 100);
		//Draw the cursor
		this.dragCursorMC.moveTo(-1, 4);
		this.dragCursorMC.lineTo(-1, -4);
		this.dragCursorMC.lineTo(-3.5, -4);
		this.dragCursorMC.lineTo(0, -6);
		this.dragCursorMC.lineTo(3.5, -4);
		this.dragCursorMC.lineTo(1, -4);
		this.dragCursorMC.lineTo(1, 4);
		this.dragCursorMC.lineTo(3.5, 4);
		this.dragCursorMC.lineTo(0, 6);
		this.dragCursorMC.lineTo(-3.5, 4);
		this.dragCursorMC.lineTo(-1, 4);
		this.dragCursorMC.endFill();
		//Now Draw the LEFT ROGHT arrow
		//Start Filling
		this.dragCursorMC.beginFill(parseInt("000000", 16), 100);
		//Draw the cursor
		this.dragCursorMC.moveTo(4, -1);
		this.dragCursorMC.lineTo(-4, -1);
		this.dragCursorMC.lineTo(-4, -3.5);
		this.dragCursorMC.lineTo(-6, 0);
		this.dragCursorMC.lineTo(-4, 3.5);
		this.dragCursorMC.lineTo(-4, 1);
		this.dragCursorMC.lineTo(4, 1);
		this.dragCursorMC.lineTo(4, 3.5);
		this.dragCursorMC.lineTo(6, 0);
		this.dragCursorMC.lineTo(4, -3.5);
		this.dragCursorMC.lineTo(4, -1);
		this.dragCursorMC.endFill();
		//Set the position
		this.dragCursorMC._x = -200;
		this.dragCursorMC._y = -200;
		//Define the filters and apply
		var shadowFilter:DropShadowFilter = new DropShadowFilter(3, 45, 0x999999, 0.8, 4, 4, 1, 1, false, false, false);
		this.dragCursorMC.filters = [shadowFilter];
	}
	/**
	 * drawFormBtn method draw a button and register event for XML generation
	*/
	private function drawFormBtn():Void{
		//Get the depth of the form button
		var depth:Number = this.dm.getDepth("FORMBUTTON");
		//Create a listener for the button
		var btnListener:Object = new Object();
		// Instantiate the form button object
		var btnForm:FCButton = new FCButton(this.cMC, depth);
		//Store the class reference
		var classRef:Object = this;
		var loadVar:LoadVars;
		//Register the listener
		btnListener.click = function(){
			loadVar = new LoadVars();
			loadVar.strXML = escape(classRef.returnXML());
			loadVar.strXML = classRef.returnXML();
			loadVar.send(classRef.params.formAction, classRef.params.formTarget, classRef.params.formMethod);
		}
		//Set the parameters of the required button
		btnForm.setParams(this.params.formBtnTitle, this.elements.btn.x, this.elements.btn.y, this.elements.btn.h, this.elements.btn.w, 5, this.params.formBtnBgColor, this.params.formBtnBorderColor, "Verdana", this.params.btnTextColor, 10);
		//Draw the button
		btnForm.draw();
		//Show the button
		btnForm.show();
		//Register the event with the button
		btnForm.addEventListener("click", btnListener);
		//Add to stack
		this.addToListenerStk(btnForm, "click", btnListener);
		//Clear interval                                                     
		clearInterval(this.config.intervals.formBtn);
	}
	/**
	 * getIdList method generates the id list for every node to which it is not connected by the connector.
	*	@param	dsIndex	dataset index of the node.
	*	@param	index	index of the dataitem for which we need the list
	*/
	private function getIdList(dsIndex:Number, index:Number):Array {
		//Arrays which hold either the connected one or not connected
		var arrConnectedId:Array = new Array();
		var arrNotConnectedId:Array = new Array();
		//Flag
		var flagPresent:Boolean =false;
		//Loop Variable
		var i:Number;
		var j:Number;
		var k:Number;
		//Loop through the connector list to get the list of corresponding data ID
		for(k=0;k<this.dataset[dsIndex].data[index].conList.length; k++) {
			if(this.connectors[this.dataset[dsIndex].data[index].conList[k]].to == this.dataset[dsIndex].data[index].id ) {
				arrConnectedId.push(this.connectors[this.dataset[dsIndex].data[index].conList[k]].from);
			}
			else if(this.connectors[this.dataset[dsIndex].data[index].conList[k]].from == this.dataset[dsIndex].data[index].id) {
				arrConnectedId.push(this.connectors[this.dataset[dsIndex].data[index].conList[k]].to);
			}
		}
		//Now create an Array of not connected ones
		//Iterate through all node
		for (i=1; i<=this.numDS; i++) {
			//Unset the present Flag
			flagPresent = false;
			for (j=1; j<=this.num; j++) {
				flagPresent = false;
				for(k=0;k<arrConnectedId.length; k++) {
					if(this.dataset[i].data[j].id == arrConnectedId[k]) { 
						flagPresent = true;
						break;
					}
				}
				if(!flagPresent) {
					//Add only when the dataitem is valid and is not connecting to itself
					if(this.dataset[i].data[j].isDefined && (!(j==index && i==dsIndex)) ) {
						arrNotConnectedId.push({id:this.dataset[i].data[j].id, dsId:this.dataset[i].id});
						flagPresent = false;
					}
				}
			}
		}
		arrNotConnectedId.sortOn(["dsId", "id" ]);
		return arrNotConnectedId;
	}
	/**
	 * drawNodeChart method draws the node on the chart
	*/
	private function drawNodeChart():Void {
		//Variables		
		var i:Number, j:Number;
		//Create function storage containers for Delegate functions
		var fnRollOver:Function, fnClick:Function, fnOnPress:Function, fnOnRelease:Function;
		var nodeDepth:Number = this.dm.getDepth("DATAPLOT");
		var dbDepth:Number = this.dm.getDepth("CONNECTORDB");
		//Delegate the Node Listener on NodeDelete
		nodeDelListener.onNodeDelete = Delegate.create(this, onNodeDelete);
		//Delegate the Connector Listener on Addition of a new Connector
		connectorAddListener.onAddConnector = Delegate.create(this, onAddConnector);
		//Create the node container MC
		var nodeCont:MovieClip = this.cMC.createEmptyMovieClip("Node", nodeDepth);
		//Set the position 0,0 
		nodeCont._x = 0;
		nodeCont._y = 0;
		//Create an empty movie clip for the dialog box
		var dbMC:MovieClip = this.cMC.createEmptyMovieClip("ConnectorDB", dbDepth);
		dbMC._x = 0;
		dbMC._y = 0;
		//Iterate through all node
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.dataset[i].num; j++) {
				//If defined
				if (this.dataset[i].data[j].isDefined) {
					//For each defined Node we create a list of Nodes to which it is not connected to.
					//So that user can dynamically add new connectors using Menu item
					this.dataset[i].data[j].dataNotConnected = this.getIdList(i, j);
					//Create an empty movie clip for this node
					var nodeMC:MovieClip = nodeCont.createEmptyMovieClip("Node_"+i+"_"+j, this.config.depthCounter);
					var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
					//Create an Object to store all the image related properties
					var imagePropObj:Object = new Object();
					imagePropObj.imageNode = this.dataset[i].data[j].imageNode;
					imagePropObj.url = this.dataset[i].data[j].imageUrl;
					imagePropObj.imageW = this.dataset[i].data[j].imageWidth;
					imagePropObj.imageH = this.dataset[i].data[j].imageHeight;
					imagePropObj.imageAlign = this.dataset[i].data[j].imageAlign;
					imagePropObj.labelAlign = this.dataset[i].data[j].labelAlign;
					//Create an instance of the dragNode class
					var nodeIns:DragNode = new DragNode(nodeMC, dbMC, this.dataset[i].data[j].x, this.dataset[i].data[j].y, this.dataset[i].data[j].w, this.dataset[i].data[j].h, this.width, this.height, this.x, this.y, this.dataset[i].data[j].r, this.dataset[i].data[j].numSides, this.dataset[i].data[j].shape, this.dataset[i].data[j].name, labelStyleObj, i, j, this.dataset[i].data[j].dataNotConnected, this.params.viewMode, imagePropObj);
					//Set the cosmetic paramters
					nodeIns.setParams(this.dataset[i].data[j].isDraggable, this.params.use3DLighting, this.dataset[i].plotBorderColor, this.dataset[i].plotBorderAlpha, this.dataset[i].plotBorderThickness, this.dataset[i].data[j].color, this.dataset[i].data[j].alpha);
					//Register a listener to show the resize handler
					nodeIns.addEventListener("onNodeDelete", nodeDelListener);
					//Add to stack
					this.addToListenerStk(nodeIns, "onNodeDelete", nodeDelListener);
					nodeIns.addEventListener("onAddConnector", connectorAddListener);
					//Add to stack
					this.addToListenerStk(nodeIns, "onAddConnector", connectorAddListener);
					//Draw the Node
					nodeIns.draw();
					//Apply animation
					if (this.params.animation) {
						this.styleM.applyAnimation(nodeMC, this.objects.DATAPLOT, this.macro, nodeMC._x, 0, nodeMC._y, 0, 100, 100, 100, null);
					}
					//Apply filters                                                           
					this.styleM.applyFilters(nodeMC, this.objects.DATAPLOT);
					//Create Delegate for roll over function columnOnRollOver
					fnRollOver = Delegate.create(this, dataOnRollOver);
					//Set the index
					fnRollOver.dsindex = i;
					fnRollOver.index = j;
					fnRollOver.nodeMC = nodeMC;
					fnRollOver.nodeIns = nodeIns;
					//Assing the delegates to movie clip handler
					nodeMC.onRollOver = fnRollOver;
					//Set roll out and mouse move too.
					nodeMC.onRollOut = Delegate.create(this, dataOnRollOut);
					nodeMC.onMouseMove = Delegate.create(this, dataOnMouseMove);
					//Event handlers for the dragging   
					//Create Delegate for onPress function 
					fnOnPress = Delegate.create(this, dataOnPress);
					//Set the index
					fnOnPress.dsindex = i;
					fnOnPress.index = j;
					fnOnPress.mcNode = nodeMC;
					fnOnPress.nodeIns = nodeIns; 
					//Assing the delegates to movie clip handler
					nodeMC.onPress = fnOnPress;
					//Set onRelease event.
					//Create Delegate for onPress function 
					fnOnRelease = Delegate.create(this, dataOnRelease);
					//Set the index
					fnOnRelease.dsindex = i;
					fnOnRelease.index = j;
					fnOnRelease.mcNode = nodeMC;
					fnOnRelease.nodeIns = nodeIns; 
					nodeMC.onRelease = nodeMC.onReleaseOutside=fnOnRelease;
					//delete 
					delete nodeIns;
					//Increase the depth
					this.config.depthCounter++;
				}
			}
		}
		//Clear interval                                                     
		clearInterval(this.config.intervals.nodes);
	}
	/**
	 * addNode method adds a node to the chart
	*/
	private function addNode():Void {
		//Loop Variable
		var i:Number, j:Number;
		var nodeDepth:Number = this.dm.getDepth("EDITNODE");
		//Register the listener and delegate it to the class function
		nodeUpdateListener.onNodeUpdate = Delegate.create(this, addNewNode);
		nodeCancelListener.onNodeUpdate = Delegate.create(this, cancelNode);
		//Create a seriesName array
		var seriesNameArr:Array = new Array();
		//Create an ID array
		var idArr:Array = new Array();
		//Create an array of all seriesNames of the dataset
		for (i=1; i<=this.numDS; i++) {
			seriesNameArr.push({sn:this.dataset[i].seriesName, dsId:this.dataset[i].id});
		}
		//Create an array of all the ID's of the data -item so that we can throw exception for similar id
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.dataset[i].num; j++) {
				//If defined and value is to be shown
				if (this.dataset[i].data[j].isDefined) {
					idArr.push(this.dataset[i].data[j].id);
				}
			}
		}
		//Create an empty movie clip for this node
		var editNodeMC:MovieClip = this.cMC.createEmptyMovieClip("EditNode", nodeDepth);
		//Create an instance of the EditNode class
		var editNodeIns:EditNode = new EditNode(editNodeMC, editNodeMC._xmouse, editNodeMC._ymouse, 80, 80, this.width, this.height, 0, 0, 80, 4, "RECTANGLE", seriesNameArr, idArr);
		editNodeIns.addEventListener("onNodeUpdate", nodeUpdateListener);
		//Add to stack
		this.addToListenerStk(editNodeIns, "onNodeUpdate", nodeUpdateListener);
		editNodeIns.addEventListener("onCancel", nodeCancelListener);
		//Add to stack
		this.addToListenerStk(editNodeIns, "onCancel", nodeCancelListener);
		//Draw the Node
		editNodeIns.draw();
		//Apply filters                                                           
		this.styleM.applyFilters(editNodeMC, this.objects.DATAPLOT);
	}
	/**
	 * drawLegend method renders the legend
	*/
	private function drawLegend():Void {
		if (this.params.showLegend) {
			this.lgnd.render();
			//Apply filter
			this.styleM.applyFilters(lgndMC, this.objects.LEGEND);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(lgndMC, this.objects.LEGEND, this.macro, null, 0, null, 0, 100, null, null, null);
			}
		}
		//Clear interval                                                  
		clearInterval(this.config.intervals.legend);
	}
	/**
	 * setContextMenu method sets the context menu for the chart.
	 * For this chart, the context items are "Print Chart".
	*/
	private function setContextMenu():Void {
		var chartMenu:ContextMenu = new ContextMenu();
		chartMenu.hideBuiltInItems();
		// initially, if links are defined for atleast one Node, then the initial 
		//	mode of user interaction is set to 'Enable Links'
		if(this.config.linksDefined && this.params.enableLink) {
			// setting enable status 
			var isDragCMIEnabled:Boolean = true;
			var isLinkCMIEnabled:Boolean = false;
			// otherwise, initial user interaction mode is set to what ever is specified in the xml
		} else {
			// setting enable status of the drag menu items ("Enable Links" is irrelevant for none of the nodes are having links)
			var isDragCMIEnabled:Boolean = (!this.config.enableDrag);
		}
		// instantiating ContextMenuItem for each menu item
		var cmiDrag:ContextMenuItem = new ContextMenuItem("Enable Drag", dragHandler, false, isDragCMIEnabled);
		//Push Drag item.
		chartMenu.customItems.push(cmiDrag);
		// "Enable Links" will be available if and only if link is defined for atleast one node.
		if (this.config.linksDefined) {
			var cmiLink:ContextMenuItem = new ContextMenuItem("Enable Links", linkHandler, false, isLinkCMIEnabled);
			//Push Link item.
			chartMenu.customItems.push(cmiLink);
		}
		//If in Edit Mode we add a menu item ADD A NODE
		if(!this.params.viewMode) {
			var cmiAddNode:ContextMenuItem = new ContextMenuItem("Add a Node", Delegate.create(this, addNode), true);
			//Push Add item.
			chartMenu.customItems.push(cmiAddNode);
		}
		// instance reference is stored                                                           
		var instanceRef = this;
		// functions invoked due selection of the menu items are defined
		function linkHandler() {
			// enabling/disabling the ContextMenuItems
			cmiDrag.enabled = true;
			cmiLink.enabled = false;
			// updating flags about current menu enable status
			instanceRef.config.enableLinks = true;
			instanceRef.config.enableDrag = false;
		}
		function dragHandler() {
			cmiDrag.enabled = false;
			cmiLink.enabled = true;
			instanceRef.config.enableLinks = false;
			instanceRef.config.enableDrag = true;
		}
		
		//Create a print chart contenxt menu item
		var printCMI:ContextMenuItem = new ContextMenuItem("Print Chart", Delegate.create(this, printChart), true);
		//Push print item.
		chartMenu.customItems.push(printCMI);
		if (this.params.imageSave){
			//Add the export to image option
			chartMenu.customItems.push(super.returnImageSaveMenuItem());		
		}
		if (this.params.showFCMenuItem){
			//Push "About FusionCharts" Menu Item
			chartMenu.customItems.push(super.returnAbtMenuItem());		
		}
		//Assign the menu to cMC movie clip
		this.cMC.menu = chartMenu;
	}
	/**
	 * returnXML method returns the updated XML file
	*/
	public function returnXML():String{
		//This function returns the XML representation of the modified data
		//*** XML Generator ***//
		var objItem:Object = new Object();
		//Generate the <chart> element attributes
		var strXML:String = "<chart ";
		var val:String;
		//Add the Charts parameters
		for(objItem in this.params) {
			if(typeof(this.params[objItem]) == "boolean") {
				val = (this.params[objItem] == true)?("1"):("0");
			} else  {
				val = this.params[objItem];
			}
			strXML = strXML+objItem+"='"+val+"' ";
		}
		strXML += ">";
		//Now, generate the categories elements
		strXML = strXML+"<categories>";
		for (var i:Number=1; i<=this.num; i++) {
			if(this.categories[i].xv != undefined || this.categories[i].label != undefined ) {
				strXML = strXML+"<category label='"+this.categories[i].label+"' x='"+this.categories[i].xv+"' />";
			}
		}
		//End the categories tag - <categories>
		strXML = strXML+"</categories>";
		//--Now generate the Datasets
		for (i=1; i<=this.numDS; i++) {
			//Attach the attributes
			strXML = strXML+"<dataSet id='"+this.dataset[i].id+"' seriesName='"+this.dataset[i].seriesName+"' >";
			//Data set generated
			//Now generate the data tags
			for (var j:Number=1; j<=this.dataset[i].num; j++) {
				if(this.dataset[i].data[j].isDefined) {
					strXML = strXML+"<set id='"+this.dataset[i].data[j].id+"' x='";					
					strXML += this.dataset[i].data[j].updatedXV+"' y='";
					strXML += this.dataset[i].data[j].updatedYV+"' name='";
					strXML += this.dataset[i].data[j].name;
					if(this.dataset[i].data[j].shape.toUpperCase() == "RECTANGLE") {
						strXML += "' height='"+this.dataset[i].data[j].h+"' width='"+this.dataset[i].data[j].w+"' shape='"+this.dataset[i].data[j].shape;
					}
					else if(this.dataset[i].data[j].shape.toUpperCase() == "POLYGON") {
						strXML += "' numSides='"+this.dataset[i].data[j].numSides;
						strXML += "' radius='"+this.dataset[i].data[j].r+"' shape='"+this.dataset[i].data[j].shape;
					}
					else if(this.dataset[i].data[j].shape.toUpperCase() == "CIRCLE") {
						strXML += "' radius='"+this.dataset[i].data[j].r+"' shape='"+this.dataset[i].data[j].shape;
					}
					else if(this.dataset[i].data[j].name!= undefined) {
						strXML += "' name='"+this.dataset[i].data[j].name;
					}
					//Add image node details
					if(this.dataset[i].data[j].imageNode) {
						strXML = strXML+"' imageNode='1' imageURL='"+this.dataset[i].data[j].imageUrl+"' imageHeight='"+this.dataset[i].data[j].imageHeight+"' imageWidth='"+this.dataset[i].data[j].imageWidth+"' imageAlign='"+this.dataset[i].data[j].imageAlign+"' labelAlign='"+this.dataset[i].data[j].labelAlign;
					}
					strXML += "' color='"+this.dataset[i].data[j].color+"' />" 
				} 
			}
			//End data set
			strXML = strXML+"</dataSet>";
		}
		//--Now generate the Connectors
		strXML = strXML+"<connectors";
		//Add global Parameters for Connectors
		strXML = strXML+" stdThickness='"+ this.params.stdThickness+"' >";
		for (i=1; i<=this.numConnector; i++) {
			if(this.connectors[i].from != undefined && this.connectors[i].to != undefined) {
				strXML = strXML+"<connector from='"+this.connectors[i].from+"' to='"+this.connectors[i].to+"' color='"+this.connectors[i].color+"' strength='"+this.connectors[i].strength+"' alpha='"+this.connectors[i].alpha;
				if(this.connectors[i].label != undefined ) {
					strXML = strXML+"' label='"+this.connectors[i].label;
				}
				strXML = strXML+"' />";
			}
		}
		//End Connectors
		strXML = strXML+"</connectors>";
		//End the chart tag
		strXML = strXML+"</chart>";
		return (strXML.toString());
	}
	/**
	 * setThreshold method sets the threshold strength value - hides the Connector if strength
	 * value is less than the threshold value.
	*/
	public function setThreshold(minStrength) {
		//This function sets the threshold of the chart
		//i.e., the minimum strength
		//Loop Variable
		var i:Number;
		//Get the reference to the connector container
		var connectorCont:MovieClip = eval(this.cMC+".ConnectorContainer");
		for (i=1; i<=this.numConnector; i++) {
			//Get the reference to the connector
			var connectorMC:MovieClip = eval(connectorCont+".Connector_"+i);
			//Firstly, make it visible
			connectorMC._visible = true;
			//Hide the connector and  its label
			if (this.connectors[i].strength<Number(minStrength)) {
				//Hide only if the strength is below the threshhold value
				connectorMC._visible = false;
				//delete the MC
				delete connectorMC;
			}
		}
	};
	// -------------------- EVENT HANDLERS --------------------//
	/**
	 * cancelNode method is called when the user click the cancel button
	*/
	private function cancelNode():Void {
		//delete the edit MC
		//Create an empty movie clip for this node
		var editNodeMC:MovieClip = eval(this.cMC+".EditNode");
		editNodeMC.removeMovieClip();
	}
	
	/**
	 * addNewNode method adds the detail of the new node
	*/
	private function addNewNode(evtObj):Void {
		//Variables		
		var i:Number, j:Number, k:Number;
		//Create function storage containers for Delegate functions
		var fnRollOver:Function, fnClick:Function, fnOnPress:Function, fnOnRelease:Function;
		//get the next highest depth
		var nodeDepth:Number = this.dm.getDepth("DATAPLOT");
		var dbDepth:Number = this.dm.getDepth("EDITNODE");
		//Create an empty movie clip for this node
		var editNodeMC:MovieClip = eval(this.cMC+".EditNode");
		//Clear and remove the MC
		editNodeMC.clear();
		editNodeMC.removeMovieClip();
		//Get the reference to the Node MC container
		var nodeCont:MovieClip = eval(this.cMC+".Node");
		//Set the position to 0,0 
		nodeCont._x = 0;
		nodeCont._y = 0;
		//Iterate through all Nodes Dataset
		for (i=1; i<=this.numDS; i++) {
			if (this.dataset[i].id == evtObj.dsId) {
				this.dataset[i].num++;
				//Increase the global counter 
				if(this.dataset[i].num>this.num) {
					this.num = this.dataset[i].num;
				}
				//Define the different parameters of the dataset 
				this.dataset[i].data[this.dataset[i].num] = this.returnDataAsObject(evtObj.id, 1, 1, Number(evtObj.w), Number(evtObj.h), Number(evtObj.r), evtObj.numSide, evtObj.nodeShape, evtObj.name, this.dataset[i].allowDrag, evtObj.name, "", this.dataset[i].color, this.dataset[i].alpha);				
				//Get the corresponding Value of the Node
				this.dataset[i].data[this.dataset[i].num].updatedXV = this.getValue(this.dataset[i].data[this.dataset[i].num].x, this.config.xMax, this.config.xMin, this.elements.canvas.x, this.elements.canvas.x+this.elements.canvas.w, false, 0);
				this.dataset[i].data[this.dataset[i].num].updatedYV = this.getValue(this.dataset[i].data[this.dataset[i].num].y, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.y+this.elements.canvas.h, true, 0);
				this.dataset[i].data[this.dataset[i].num].xv = this.dataset[i].data[this.dataset[i].num].updatedXV;
				this.dataset[i].data[this.dataset[i].num].yv = this.dataset[i].data[this.dataset[i].num].updatedYV;
				//Set the defined flag
				this.dataset[i].data[this.dataset[i].num].isDefined = true;
				//Set the new position with respect to canvas
				this.dataset[i].data[this.dataset[i].num].x = evtObj.x;
				this.dataset[i].data[this.dataset[i].num].y = evtObj.y;
				//Create the arrays
				this.dataset[i].data[this.dataset[i].num].conList = new Array();
				this.dataset[i].data[this.dataset[i].num].dataNotConnected = new Array();
				//Draw the Node again with all the events defined
				if (this.dataset[i].data[this.dataset[i].num].isDefined) {
					//For each defined Node we create a list of Nodes to which it is not connected to.
					//So that user can dynamically add new connectors using Menu item
					this.dataset[i].data[this.dataset[i].num].dataNotConnected = this.getIdList(i, this.dataset[i].num);
					//Create an empty movie clip for this node
					var nodeMC:MovieClip = nodeCont.createEmptyMovieClip("Node_"+i+"_"+(this.dataset[i].num), ++this.config.depthCounter);
					var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
					//Create an Object to store all the image related properties
					var imagePropObj:Object = new Object();
					imagePropObj.imageNode = evtObj.imageNode;
					imagePropObj.url = evtObj.url;
					imagePropObj.imageW = -1;
					imagePropObj.imageH = -1;
					imagePropObj.imageAlign = "bottom";
					imagePropObj.labelAlign = "top";
					//Create an empty movie clip for the dialog box
					var dbMC:MovieClip = eval(this.cMC+".ConnectorDB");
					//Create an instance of the dragNode class
					var nodeIns:DragNode = new DragNode(nodeMC, dbMC, this.dataset[i].data[this.dataset[i].num].x, this.dataset[i].data[this.dataset[i].num].y, this.dataset[i].data[this.dataset[i].num].w, this.dataset[i].data[this.dataset[i].num].h, this.width, this.height, this.x, this.y, this.dataset[i].data[this.dataset[i].num].r, this.dataset[i].data[this.dataset[i].num].numSides, this.dataset[i].data[this.dataset[i].num].shape, this.dataset[i].data[this.dataset[i].num].name, labelStyleObj, i, this.dataset[i].num, this.dataset[i].data[this.dataset[i].num].dataNotConnected, this.params.viewMode, imagePropObj);
					//Set the cosmetic paramters
					nodeIns.setParams(this.dataset[i].allowDrag, this.params.use3DLighting, this.dataset[i].plotBorderColor, this.dataset[i].plotBorderAlpha, this.dataset[i].plotBorderThickness, this.dataset[i].color, this.dataset[i].alpha);
					//Register a listener to show the resize handler
					nodeIns.addEventListener("onNodeDelete", nodeDelListener);
					//Add to stack
					this.addToListenerStk(nodeIns, "onNodeDelete", nodeDelListener);
					nodeIns.addEventListener("onAddConnector", connectorAddListener);
					//Add to stack
					this.addToListenerStk(nodeIns, "onAddConnector", connectorAddListener);
					//Draw the Node
					nodeIns.draw();
					//Append the Node list of all the other nodes as this node is not connected to anyone
					for (j=1; j<=this.numDS; j++) {
						for (k=1; k<=this.dataset[j].num; k++) {
							if(!(i==j && k==this.dataset[i].num)) {
								this.dataset[j].data[k].dataNotConnected.push({id:this.dataset[i].data[this.dataset[i].num].id, dsId:this.dataset[i].id});
							}
						}
					}
				}
				//Create Delegate for roll over function columnOnRollOver
				fnRollOver = Delegate.create(this, dataOnRollOver);
				//Set the index
				fnRollOver.dsindex = i;
				fnRollOver.index = this.dataset[i].num;
				fnRollOver.nodeMC = nodeMC;
				fnRollOver.nodeIns = nodeIns;
				//Assing the delegates to movie clip handler
				nodeMC.onRollOver = fnRollOver;
				//Set roll out and mouse move too.
				nodeMC.onRollOut = Delegate.create(this, dataOnRollOut);
				nodeMC.onMouseMove = Delegate.create(this, dataOnMouseMove);
				//Event handlers for the dragging   
				//Create Delegate for onPress function 
				fnOnPress = Delegate.create(this, dataOnPress);
				//Set the index
				fnOnPress.dsindex = i;
				fnOnPress.index = this.dataset[i].num;
				fnOnPress.mcNode = nodeMC;
				fnOnPress.nodeIns = nodeIns; 
				//Assing the delegates to movie clip handler
				nodeMC.onPress = fnOnPress;
				//Set onRelease event.
				//Create Delegate for onPress function 
				fnOnRelease = Delegate.create(this, dataOnRelease);
				//Set the index
				fnOnRelease.dsindex = i;
				fnOnRelease.index = this.dataset[i].num;
				fnOnRelease.mcNode = nodeMC;
				fnOnRelease.nodeIns = nodeIns; 
				nodeMC.onRelease = nodeMC.onReleaseOutside=fnOnRelease;
			}
		}
	}
	/**
	 * onNodeDelete is the delegat-ed event handler method that'll
	 * be invoked when the user deletes a paticular node from Menu item.
	*/
	private function onNodeDelete(evtObj):Void {
		//Hide the drag Cursor if visible
		this.dragCursorMC._visible = false;
		//Hide the tool tip
		this.tTip.hide();
		//Loop Variable
		var i:Number;
		var j:Number;
		var k:Number;
		//Delete this Node from the list of NOTCONNECTED Array of all other Nodes
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.dataset[i].num; j++) {
				for(k=0;k<this.dataset[i].data[j].dataNotConnected.length;k++) {
					if(this.dataset[evtObj.dsIndex].data[evtObj.index].id == this.dataset[i].data[j].dataNotConnected[k].id) {
						//Delete this index from the array
						this.dataset[i].data[j].dataNotConnected.splice(k, 1);
					}
				}
			}
		}
		//get the reference to container MC
		var connectorCont:MovieClip = eval(this.cMC+".ConnectorContainer");
		for(i=0;i<this.dataset[evtObj.dsIndex].data[evtObj.index].conList.length; i++) {
			//Get the reference to the connector
			var connectorMC:MovieClip = eval(connectorCont+".Connector_"+(this.dataset[evtObj.dsIndex].data[evtObj.index].conList[i]));
			//clear the previously drawn connectors
			connectorMC.clear();
			//Remove the MC
			connectorMC.removeMovieClip();
			//delete the connector's entry
			this.connectors[this.dataset[evtObj.dsIndex].data[evtObj.index].conList[i]] = new Object();
		}		
		//Delete it from the data array
		this.dataset[evtObj.dsIndex].data[evtObj.index] =  new Object();
		this.dataset[evtObj.dsIndex].data[evtObj.index].isDefined = false;
		//Show Mouse Again - as it might be a case when we delete Node we were in drag Mode
		Mouse.show();
	}
	/**
	 * onAddConnector method adds the detail of the new connector
	*/
	private function onAddConnector(evtObj):Void {
		//Loop Variable
		var i:Number;
		var j:Number;
		//Assign the array index
		for (var i:Number=1; i<=this.numDS; i++) {
			if(evtObj.toDsIndex == this.dataset[i].id) {
				evtObj.toDsIndex = i;
			}
			for (j=1; j<=this.dataset[i].num; j++) {
				if(evtObj.toId == this.dataset[i].data[j].id) {
					evtObj.toId = j;
				}
			}
		}
		//Variables
		var fromRadius:Number, toRadius:Number;
		//Create the connectors array and store all the details
		i = ++this.numConnector;
		this.connectors[i] = this.returnDataAsCon(evtObj.label, this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].id, this.dataset[evtObj.toDsIndex].data[evtObj.toId].id, this.params.conColor, this.params.conAlpha, evtObj.dashed, this.params.conDashGap, this.params.conDashLen, evtObj.arrowStart, evtObj.arrowEnd, evtObj.strength);
		//Now draw the connector
		//Depth
		var connectorDepth:Number = this.dm.getDepth("DATACONNECTOR")+this.numConnector;
		//Add it to the conList for fromDS and toDS
		this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].conList.push(i);
		this.dataset[evtObj.toDsIndex].data[evtObj.toId].conList.push(i);
		//Create an empty movie clip for this connector
		//get the reference to container MC
		var connectorCont:MovieClip = eval(this.cMC+".ConnectorContainer");
		var connectorMC:MovieClip = connectorCont.createEmptyMovieClip("Connector_"+i, connectorDepth);
		//Store the cosmetic property in an Object and pass it to its constructor
		var lineProp:Object = new Object();
		lineProp.color = this.connectors[i].color;
		lineProp.alpha = this.connectors[i].alpha;
		lineProp.thickness = this.connectors[i].strength*this.params.stdThickness;
		lineProp.dashed = this.connectors[i].dashed;
		lineProp.dashLen = this.connectors[i].dashLen;
		lineProp.dashGap = this.connectors[i].dashGap;
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.CONNECTORLABELS);
		labelStyleObj.bgColor = this.connectors[i].color;
		//Create an object to place the position of the connector
		var posObj:Object = new Object();
		this.connectors[i].fromX = posObj.fromX = this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].x;
		this.connectors[i].fromY = posObj.fromY = this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].y;
		this.connectors[i].toX = posObj.toX = this.dataset[evtObj.toDsIndex].data[evtObj.toId].x;
		this.connectors[i].toY = posObj.toY = this.dataset[evtObj.toDsIndex].data[evtObj.toId].y;
		//If Polygon or circle then send the radius of connecting datasets
		if(this.dataset[evtObj.toDsIndex].data[evtObj.toId].shape.toUpperCase()=="POLYGON" || this.dataset[evtObj.toDsIndex].data[evtObj.toId].shape.toUpperCase()=="CIRCLE") {
			toRadius = this.dataset[evtObj.toDsIndex].data[evtObj.toId].r;
		}
		else if(this.dataset[evtObj.toDsIndex].data[evtObj.toId].shape.toUpperCase()=="RECTANGLE") {
			//Send the diagonal/2
			toRadius = Math.sqrt(Math.pow(this.dataset[evtObj.toDsIndex].data[evtObj.toId].h,2)+ Math.pow(this.dataset[evtObj.toDsIndex].data[evtObj.toId].w,2))/2;
		}
		if(this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].shape.toUpperCase()=="POLYGON" || this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].shape.toUpperCase()=="CIRCLE") {
			fromRadius = this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].r;
		}
		else if(this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].shape.toUpperCase()=="RECTANGLE") {
			//Send diagonal/2
			fromRadius = Math.sqrt(Math.pow(this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].h,2)+ Math.pow(this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].w,2))/2;
		}
		//Create an instance of the connector class
		var connectorIns:NodeConnector = new NodeConnector(connectorMC, i, evtObj.label, posObj, lineProp, labelStyleObj, fromRadius, toRadius, this.connectors[i].arrowAtStart, this.connectors[i].arrowAtEnd, evtObj.strength, this.params.viewMode);
		//Register the listener
		connectorIns.addEventListener("onConnectorDelete", connectorDelListener);
		//Add to stack
		this.addToListenerStk(connectorIns, "onConnectorDelete", connectorDelListener);
		//Draw the connector
		connectorIns.draw();
		//Delete the possible list of connectors for the from Nodes
		for(j=0;j<this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].dataNotConnected.length;j++) {
			if(this.dataset[evtObj.toDsIndex].data[evtObj.toId].id  ==  this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].dataNotConnected[j].id ) {
				//delete from the array - as we just deleted this node
				this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].dataNotConnected.splice(j, 1);
			}
		}
		//Delete the possible list of connectors for the TO Nodes
		for(j=0;j<this.dataset[evtObj.toDsIndex].data[evtObj.toId].dataNotConnected.length;j++) {
			if(this.dataset[evtObj.fromDsIndex].data[evtObj.fromId].id ==  this.dataset[evtObj.toDsIndex].data[evtObj.toId].dataNotConnected[j].id) {
				//delete from the array - as we just deleted this node
				this.dataset[evtObj.toDsIndex].data[evtObj.toId].dataNotConnected.splice(j, 1);
			}
		}
		//Apply filters                                                           
		this.styleM.applyFilters(connectorMC, this.objects.CONNECTOR);
	}
	/**
	 * onConnectorDelete is the delegat-ed event handler method that'll
	 * be invoked when the user deletes a paticular connector from Menu item.
	*/
	private function onConnectorDelete(evtObj):Void {
		//Loop Variable
		var i:Number;
		var j:Number;
		var fromDsId:Number=-1, fromId:Number=-1;
		var toDsId:Number=-1, toId:Number=-1;
		//get the reference to container MC
		var connectorCont:MovieClip = eval(this.cMC+".ConnectorContainer");
		//Get the reference to the connector
		var connectorMC:MovieClip = eval(connectorCont+".Connector_"+(evtObj.index));
		//clear the previously drawn connectors
		connectorMC.clear();
		//Remove the MC
		connectorMC.removeMovieClip();
		//Assign the array index
		for (var i:Number=1; i<=this.numDS; i++) {
			for (j=1; j<=this.dataset[i].num; j++) {
				if(this.connectors[evtObj.index].to == this.dataset[i].data[j].id) {
					//Store the indexes
					toId = j;
					toDsId = i;
				}
				if(this.connectors[evtObj.index].from == this.dataset[i].data[j].id) {
					//Store the indexes
					fromId = j;
					fromDsId = i;
				}
			}
		}
		this.dataset[fromDsId].data[fromId].dataNotConnected.push({id:this.connectors[evtObj.index].to, dsId:this.dataset[toDsId].id});
		this.dataset[toDsId].data[toId].dataNotConnected.push({id:this.connectors[evtObj.index].from, dsId:this.dataset[fromDsId].id});
		//delete the connector's entry
		this.connectors[evtObj.index] = new Object();
	}
	/**
	 * dataOnRollOver is the delegat-ed event handler method that'll
	 * be invoked when the user rolls his mouse over a node. 
	 * This function is invoked, only if the tool tip is to be shown.
	 * Here, we show the tool tip.
	*/
	private function dataOnRollOver():Void {
		//Index of data is stored in arguments.caller.index
		var dsindex:Number = arguments.caller.dsindex;
		var index:Number = arguments.caller.index;
		var nodeMC:MovieClip = arguments.caller.nodeMC;
		var nodeIns:MovieClip = arguments.caller.nodeIns;
		//If link mode is ON - use hand cursor
		if(this.dataset[dsindex].data[index].link !='' && this.config.enableLinks)		{
			nodeMC.useHandCursor = true;
		}
		else if(this.config.enableDrag && nodeIns.getDragProp()) {
			//Do not use handcursor
			nodeMC.useHandCursor = false;
			//Hide the mouse
			Mouse.hide();
			//Set the resize cursor position as the current mouse cursor
			this.dragCursorMC._x = nodeMC._parent._xmouse+2;
			this.dragCursorMC._y = nodeMC._parent._ymouse-2;
			//Make it visible
			this.dragCursorMC._visible = true;
			//Store the class Reference
			var classRef:Object = this;
			//On enter frame we keep the visibility to true 
			//And we hide it only when it is roll out of handler
			nodeMC.onEnterFrame = function() {
				//Set the new position of the cursor
				classRef.dragCursorMC._x = this._parent._xmouse+2;
				classRef.dragCursorMC._y = this._parent._ymouse-2;
				//to avoid flickers
				updateAfterEvent();
			};
		}
		//Event handlers for tool tip
		if (this.params.showToolTip) {
			//Set tool tip text
			this.tTip.setText(this.dataset[dsindex].data[index].toolText);
			//Show the tool tip
			this.tTip.show();
		}
	}
	/**
	 * dataOnRollOut method is invoked when the mouse rolls out
	 * of node. We just hide the tool tip here.
	*/
	private function dataOnRollOut():Void {
		//Show the mouse
		Mouse.show();
		//Show drag cursor
		this.dragCursorMC._visible = false;
		//Delete the EnterFrame event
		delete this.dragCursorMC.onEnterFrame;
		//Hide the tool tip
		this.tTip.hide();
	}
	/*
	 * dataOnMouseMove is called when the mouse position has changed
	 * over column. We reposition the tool tip.
	*/
	private function dataOnMouseMove():Void {
		//Reposition the tool tip only if it's in visible state
		if (this.tTip.visible()) {
			this.tTip.rePosition();
		}
	}
	/**
	 * dataOnPress is invoked when the user presses on a node (if link
	 * has been defined). We start the dragging.														  
	*/
	private function dataOnPress():Void {
		//Index of Node is stored in arguments.caller.index
		var dsindex:Number = arguments.caller.dsindex;
		var index:Number = arguments.caller.index;
		var mcNode:MovieClip = arguments.caller.mcNode;
		var nodeIns:Object = arguments.caller.nodeIns;
		//Hide the tool tip
		this.tTip.hide();
		//Store the class Reference
		var classRef:Object = this;
		// either links or dragging option is ON - we set dargging to false explicitly if the link is defined
		this.config.enableDrag = !this.config.enableLinks;
		//Drag the anchors only if the dragging option is set to ON
		if(this.config.enableDrag && nodeIns.getDragProp() ) {
			//Do not use hand cursor
			mcNode.useHandCursor = false;
			//Set the drag parameters based on the shape of the node
			
			if(this.dataset[dsindex].data[index].shape.toUpperCase() == "POLYGON" || this.dataset[dsindex].data[index].shape.toUpperCase() == "CIRCLE") {
				mcNode.startDrag(false, this.elements.canvas.x+this.dataset[dsindex].data[index].r, this.elements.canvas.y+this.dataset[dsindex].data[index].r, this.elements.canvas.x+this.elements.canvas.w-this.dataset[dsindex].data[index].r, this.elements.canvas.y+this.elements.canvas.h-this.dataset[dsindex].data[index].r);
			}
			else {
				mcNode.startDrag(false, this.elements.canvas.x+this.dataset[dsindex].data[index].w/2, this.elements.canvas.y+this.dataset[dsindex].data[index].h/2, this.elements.canvas.x+this.elements.canvas.w-this.dataset[dsindex].data[index].w/2, this.elements.canvas.y+this.elements.canvas.h-this.dataset[dsindex].data[index].h/2);
			}
			//Define enterFrame event of this
			mcNode.onEnterFrame = function() {
				//Set the new position of the Node
				classRef.dataset[dsindex].data[index].x = this._x;
				classRef.dataset[dsindex].data[index].y = this._y;
				classRef.dragCursorMC._x = this._parent._xmouse+2;
				classRef.dragCursorMC._y = this._parent._ymouse-2;
				classRef.reDrawConnectors(classRef.dataset[dsindex].data[index].conList);
				updateAfterEvent();
			}
		} else if(this.dataset[dsindex].data[index].link !='' && this.config.enableLinks) {
			mcNode.useHandCursor = true;
			//Invoke the link
			super.invokeLink(this.dataset[dsindex].data[index].link);
		}
		
	}
	/**
	 * dataOnRelease is invoked when the user release the mouse after pressing a node
	 * We stop the dragging and update the chart. 
	*/
	private function dataOnRelease():Void {
		//Make the dragCursor Invisible
		this.dragCursorMC._visible = false;
		Mouse.show();
		//Index of Node is stored in arguments.caller.index
		var dsindex:Number = arguments.caller.dsindex;
		var index:Number = arguments.caller.index;
		var mcNode:MovieClip = arguments.caller.mcNode;
		var nodeIns:MovieClip = arguments.caller.nodeIns;
		//Set the final paramters of  the anchors only if the dragging option was set to ON
		if(this.config.enableDrag && nodeIns.getDragProp() ) {
			//Set the new position of the Node
			this.dataset[dsindex].data[index].x = mcNode._x;
			this.dataset[dsindex].data[index].y = mcNode._y;
			//Calculate the new values of the dataitems
			this.dataset[dsindex].data[index].updatedXV = this.getValue(this.dataset[dsindex].data[index].x, this.config.xMax, this.config.xMin, this.elements.canvas.x, this.elements.canvas.x+this.elements.canvas.w, false, 0);
			this.dataset[dsindex].data[index].updatedYV = this.getValue(this.dataset[dsindex].data[index].y, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.y+this.elements.canvas.h, true, 0);
			this.dragCursorMC._x = mcNode._parent._xmouse+2;
			this.dragCursorMC._y = mcNode._parent._ymouse-2;
		}		
		delete mcNode.onEnterFrame;
		mcNode.stopDrag();
		
	}
	/**
	 * addToListenerStk method adds listeners to stack. These listeners have to  
	 * be deleted from memory  for efficiency purpose.
	 *	@param	obj		Object which needs to be added to stack list
	 *	@param	type	type of event
	 *	@param	lHandler	listener reference which needs to be removed
	*/
	public function addToListenerStk(obj:Object, type:String, lHandler:Object):Void {
		//Add it to stack
		//We store all the properties of the listener - so as to make sure we remove the 
		// specific listner and not unnecessary listeners
		this.config.stkListener[this.config.stkListenerLength++] = new Object();
		this.config.stkListener[this.config.stkListenerLength-1].obj = obj;
		this.config.stkListener[this.config.stkListenerLength-1].lType = type;
		this.config.stkListener[this.config.stkListenerLength-1].lHandler = lHandler;
	}
	/**
	 * reInit method re-initializes the chart. This method is basically called
	 * when the user changes chart data through JavaScript. In that case, we need
	 * to re-initialize the chart, set new XML data and again render.
	*/
	public function reInit():Void {
		//Invoke super class's reInit
		super.reInit();
		//Initialize Connector
		this.connectors = new Array();
		this.numConnector = 0;
		//Configuration whether links have been defined - by default assume no.
		this.config.linksDefined = false;
		//Enable/Disable for link and drag
		this.config.enableDrag = false;
		this.config.enableLinks = false;
		//Initialize the depth counter for Nodes
		this.config.depthCounter = 0;
		//Remove all the listeners
		while (this.config.stkListenerLength>0) {
			//Remove the required listener
			this.config.stkListener[this.config.stkListenerLength].obj.removeEventListener(this.config.stkListener[this.config.stkListenerLength].lType, this.config.stkListener[this.config.stkListenerLength].lHandler);
			//Reduce the listener stack length
			this.config.stkListenerLength--;
		}
		//Reinitialize the array and set length to 0
		this.config.stkListener = new Array();
		this.config.stkListenerLength = 0;
	}
	/**
	 * remove method removes the chart by clearing the chart movie clip
	 * and removing any listeners. 
	*/
	public function remove():Void {
		super.remove();
	}
	/**
	* destroy method destroys the chart by removing the chart movie clip,
	* logger movie clip, and removing any listeners.
	*/
	public function destroy () : Void 
	{
		//Remove the chart first
		super.remove ();
		//Remove drag cursor MC
		this.dragCursorMC.removeMovieClip();
	}
}
