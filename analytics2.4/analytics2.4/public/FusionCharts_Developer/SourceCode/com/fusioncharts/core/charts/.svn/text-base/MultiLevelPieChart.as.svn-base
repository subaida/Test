/**
 * MultiLevelPieChart chart extends the Chart class to render a 
 * 2D MultiLevel PieChart.
 */
// Import the Delegate class
import mx.utils.Delegate;
//Import parent Chart class
import com.fusioncharts.core.Chart;
//Utils class
import com.fusioncharts.helper.Utils;
//Error class
import com.fusioncharts.helper.FCError;
//Import Logger Class
import com.fusioncharts.helper.Logger;
//Import the Style Object
import com.fusioncharts.core.StyleObject;
class com.fusioncharts.core.charts.MultiLevelPieChart extends Chart {
	//Version number (if different from super Chart class)
	//private var _version:String = "3.0.0";
	//Instance variables
	//Container for data
	private var data:Array;
	//num keeps a count of number of data sets provided to the chart
	private var num:Number = 0;
	//List of chart objects
	private var _arrObjects:Array;
	// XML object 
	private var xmlData:XML;	
	/**
	 * Constructor function. We invoke the super class'
	 * constructor and then set the objects for this chart.
	*/
	function MultiLevelPieChart(targetMC:MovieClip, depth:Number, width:Number, height:Number, x:Number, y:Number, debugMode:Boolean, lang:String, scaleMode:String, registerWithJS:Boolean, DOMId:String) {
		//Invoke the super class constructor
		super (targetMC, depth, width, height, x, y, debugMode, lang, scaleMode, registerWithJS, DOMId);
		//Log additional information to debugger
		//We log version from this class, so that if this class version
		//is different, we can log it
		this.log("Version", _version, Logger.LEVEL.INFO);
		this.log("Chart Type", "Multi-Level Pie Chart", Logger.LEVEL.INFO);
		//List Chart Objects and set them
		_arrObjects = new Array("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "DATALABELS", "DATAPLOT", "TOOLTIP");
		super.setChartObjects(_arrObjects);
		//Initialize data container
		this.data = new Array();
		//Set the properties radius, start and end angle of the Zero-eth DataItem
		this.data[0] = this.returnDataAsObject(1, "", 0, 100, "", "", 0);
		//Initial level Count
		this.config.levelCount = 0;
	}
	// -------------------- CORE CHART METHODS -------------------------- //
	/**
	 * render method is the single call method that does the rendering of chart:
	 * - Parsing XML
	 * - Calculating values and co-ordinates
	 * - Visual layout and rendering
	 * - Event handling
	*/
	public function render():Void {
		//Parse the XML Data document
		this.parseXML();
		//Now, if the number of data elements is 0, we show pertinent
		//error.
		if (this.num == 0) {
			tfAppMsg = this.renderAppMessage(_global.getAppMessage("NODATA", this.lang));
			//Add a message to log.
			this.log("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn't any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI><LI>You might be using a Single Series Chart .swf file instead of Multi-series .swf file and providing multi-series data or vice-versa.</LI>", Logger.LEVEL.ERROR);
			//Expose rendered method
			this.exposeChartRendered();
		} else {
			//Set style defaults
			this.setStyleDefaults();
			//Detect number scales
			this.detectNumberScales();
			//Calculate Points
			this.calculatePoints();
			//Allot the depths for various charts objects now
			this.allotDepths();
			//Feed macro values
			this.feedMacros();
			//Set tool tip parameter
			this.setToolTipParam();
			//-------- Start Visual Rendering Now ------//
			//Draw background
			this.drawBackground();
			// set the global URL click
			this.drawClickURLHandler();
			// load the background SWF, if any
			this.loadBgSWF();
			//Update timer
			this.timeElapsed = (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.BACKGROUND) : 0;
			//Draw headers - caption and sub-caption
			this.config.intervals.headers = setInterval(Delegate.create(this, drawHeaders), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.CAPTION, this.objects.SUBCAPTION) : 0;
			//Call the unified draw method to render chart.
			this.config.intervals.plot = setInterval(Delegate.create(this, draw), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DATAPLOT) : 0;
			//Set the labels
			this.config.intervals.label = setInterval(Delegate.create(this, setLabels), this.timeElapsed);
			//Remove application message
			this.removeAppMessage(this.tfAppMsg);
			//Dispatch event that the chart has loaded.
			this.config.intervals.renderedEvent = setInterval(Delegate.create(this, exposeChartRendered) , this.timeElapsed);
			//Render context menu
			//We do not put context menu interval as we need the menu to appear
			//right from start of the play.
			this.setContextMenu();
		}
	}
	/**
	 * allotDepths method allots the depths for various chart objects
	 * to be rendered. We do this before hand, so that we can later just
	 * go on rendering chart objects, without swapping.
	*/
	private function allotDepths():Void {
		//Background
		this.dm.reserveDepths("BACKGROUND", 1);
		//Click URL Handler
		this.dm.reserveDepths("CLICKURLHANDLER", 1);
		//Background SWF
		this.dm.reserveDepths("BGSWF", 1);
		//Caption
		this.dm.reserveDepths("CAPTION", 1);
		//Sub-caption
		this.dm.reserveDepths("SUBCAPTION", 1);
		// pie container holder
		this.dm.reserveDepths("DATAPLOT", 1);
		//Pie border
		this.dm.reserveDepths("DATABORDER", this.num);
		//labels
		this.dm.reserveDepths("DATALABELS", this.num);
	}
	/**
	 * setStyleDefaults method sets the default values for styles or
	 * extracts information from the attributes and stores them into
	 * style objects.
	*/
	private function setStyleDefaults():Void {
		/**
		 * For the Multi-level chart, we need to set defaults for the
		 * following object - property combinations:
		 * CAPTION - FONT
		 * SUBCAPTION - FONT
		 * DATALABELS - FONT
		 * TOOLTIP - FONT
		 * DATAPLOT - Default Animation (Alpha)
		 */
		//Default font object for Caption
		//-----------------------------------------------------------------//
		var captionFont = new StyleObject();
		captionFont.name = "_SdCaptionFont";
		captionFont.align = "center";
		captionFont.valign = "top";
		captionFont.bold = "1";
		captionFont.font = this.params.baseFont;
		captionFont.size = this.params.baseFontSize;
		captionFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.CAPTION, captionFont, this.styleM.TYPE.FONT, null);
		delete captionFont;
		//-----------------------------------------------------------------//
		//Default font object for SubCaption
		//-----------------------------------------------------------------//
		var subCaptionFont = new StyleObject();
		subCaptionFont.name = "_SdSubCaptionFont";
		subCaptionFont.align = "center";
		subCaptionFont.valign = "top";
		subCaptionFont.bold = "1";
		subCaptionFont.font = this.params.baseFont;
		subCaptionFont.size = this.params.baseFontSize;
		subCaptionFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.SUBCAPTION, subCaptionFont, this.styleM.TYPE.FONT, null);
		delete subCaptionFont;
		//-----------------------------------------------------------------//
		//Default font object for DataLabels
		//-----------------------------------------------------------------//
		var dataLabelsFont = new StyleObject();
		dataLabelsFont.name = "_SdDataLabelsFont";
		dataLabelsFont.align = "center";
		dataLabelsFont.valign = "middle";
		dataLabelsFont.font = this.params.baseFont;
		dataLabelsFont.size = this.params.baseFontSize;
		dataLabelsFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.DATALABELS, dataLabelsFont, this.styleM.TYPE.FONT, null);
		delete dataLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for ToolTip
		//-----------------------------------------------------------------//
		var toolTipFont = new StyleObject();
		toolTipFont.name = "_SdToolTipFont";
		toolTipFont.font = this.params.baseFont;
		toolTipFont.size = this.params.baseFontSize;
		toolTipFont.color = this.params.baseFontColor;
		toolTipFont.bgcolor = this.params.toolTipBgColor;
		toolTipFont.bordercolor = this.params.toolTipBorderColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TOOLTIP, toolTipFont, this.styleM.TYPE.FONT, null);
		delete toolTipFont;
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for DataPlot
		//-----------------------------------------------------------------//
		if (this.params.showShadow) {
			var dataPlotShadow = new StyleObject();
			dataPlotShadow.name = "_SdDataPlotShadow";
			dataPlotShadow.angle = 45;
			//If we do not have to show column shadow
			dataPlotShadow.alpha = this.params.shadowAlpha;
			dataPlotShadow.color = this.params.shadowColor;
			//Over-ride     
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			delete dataPlotShadow;
		}
		//-----------------------------------------------------------------//              
		//Default Animation object for DataPlot (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation) {
			//We need rotation animation objects.
			var dataPlotRotAnim = new StyleObject();
			dataPlotRotAnim.name = "_SdDataPlotAnimRotation";
			dataPlotRotAnim.param = "_rotation";
			dataPlotRotAnim.easing = "regular";
			dataPlotRotAnim.wait = 0;
			dataPlotRotAnim.start = 0;
			dataPlotRotAnim.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotRotAnim, this.styleM.TYPE.ANIMATION, "_rotation");
			delete dataPlotRotAnim;
		}
	}
	// ----------------- DATA READING, PARSING AND STORING -----------------//
	/**
	 * parseXML method parses the XML data, sets defaults and validates
	 * the attributes before storing them to data storage objects.
	*/
	private function parseXML():Void {
		//Get the element nodes
		var arrDocElement:Array = this.xmlData.childNodes;
		//Look for <graph> element
		for (var i:Number = 0; i<arrDocElement.length; i++) {
			//If it's a <graph> element, proceed.
			//Do case in-sensitive mathcing by changing to upper case
			if (arrDocElement[i].nodeName.toUpperCase() == "GRAPH" || arrDocElement[i].nodeName.toUpperCase() == "CHART") {
				//Extract attributes of <graph> element
				this.parseAttributes(arrDocElement[i]);
				//Now, get the child nodes - first level nodes
				var arrLevel1Nodes:Array = arrDocElement[i].childNodes;
				//Now parse the categories tag
				this.parseCategories(arrDocElement[i], this.num, 0);
				//Iterate through all level 1 nodes.
				for (var j:Number = 0; j<arrLevel1Nodes.length; j++) {
					if (arrLevel1Nodes[j].nodeName.toUpperCase() == "STYLES") {
						//Styles Node - extract child nodes
						var arrStyleNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the style nodes to extract style information
						super.parseStyleXML(arrStyleNodes);
					}
				}
			}
		}
		//Delete all temporary objects used for parsing XML Data document
		delete arrDocElement;
		delete arrLevel1Nodes;
	}
	/** 
	 * parseCategories method parses the categories tag and store it in an object
	 * @param	catNode		Category XML node
	 * @param	currentId 	current category unique id
	 * @param	parentId 	parent Id of the category
	 * @param	parentArr 	an array holding the list of parent until the root Node.
	*/
	private function parseCategories(catNode:Array, currentId:Number, parentId:Number, parentArr:Array):Void {
		//This function parses the categories nodes for a given node.
		var category:Array;
		var i:Number;
		//Iterate through all level 1 nodes.
		for (category in catNode.childNodes) {
			var currentNode = catNode.childNodes[category];
			if (currentNode.nodeName.toUpperCase() == "CATEGORY") {
				//Get attributes
				var atts:Array;
				atts = this.getAttributesArray(currentNode);
				this.num++;
				currentId = this.num;
				//Extract the attributes
				//Value
				var catValue:Number = getSetValue(atts["value"]);
				//If is not a number
				if (isNaN(catValue)) {
					catValue = 1;
				}
				//Take only positive values 
				catValue = Math.abs(catValue);
				//Category label
				var catLabel:String = getFV(atts["label"], atts["name"], "");
				//Hover text
				var catHoverText:String = getFV(atts["tooltext"], atts["hovertext"], catLabel);
				//If its the root Node then create a new Array to store all the parent's Id
				//i.e. if its the first level node
				if (parentId == 0) {
					parentArr = new Array();
				}
				//If we havent stored the last parent of the currentNode then add it to the list
				//which means siblings of the current Node will not effect in adding of a new parent ID
				//to the list
				if (parentArr[parentArr.length-1] != parentId) {
					parentArr.push(parentId);
				}
				//We check whether there is any repition of parent ID's in the list
				//This is just a measure to check for any repition in the list.
				//(to solve the issue for checking of siblings of the sibling parent Node)
				for (i=0; i<parentArr.length; i++) {
					if (parentArr[i] == parentId) {
						parentArr.splice(i, parentArr.length-i-1);
					}
				}
				//Link
				var catLink:String = getFV(atts["link"], "");
				//Fill Color
				var color:String = String(formatColor(getFV(atts["color"], this.defColors.getColor())));
				// hexadecimal color code stored for the pie
				var catFillColor:Number = parseInt(color, 16);
				//Alpha
				var catAlpha:Number = getFV(atts["alpha"], this.params.pieFillAlpha);
				//Store the data
				this.data[this.num] = this.returnDataAsObject(catValue, catLabel, catFillColor, catAlpha, catHoverText, catLink, parentId);
				//Store this category Id as the child of the parent Node
				this.data[parentId].childList.push(currentId);
				//If no more child - then declare current category as the leaf Node
				if (String(currentNode.childNodes).length == 0) {
					//If leaf node then store the parent parent's list to calculate the level count
					this.data[this.num-1].parentArr = parentArr;
					//Store the max levelCount
					this.config.levelCount = (this.config.levelCount<this.data[this.num-1].parentArr.length) ? (this.data[this.num-1].parentArr.length) : (this.config.levelCount);
				}
				//Recursive call to itself
				this.parseCategories(currentNode, this.num, currentId, parentArr);
			}
		}
	}
	/** 
	 * getChildren method parses the data list to sort the children 
	 * of the given parent.
	 * @param	parentId	parent ID
	*/
	private function getChildren(parentId:Number):Object {
		//This function returns the immediate children of the given parent id
		var rtnObject:Object = new Object();
		if (this.data[parentId].childList.length>0) {
			//Allot to the object
			rtnObject.count = this.data[parentId].childList.length;
			rtnObject.child = this.data[parentId].childList;
		} else {
			rtnObject.count = 0;
			rtnObject.child = new Array();
		}
		return rtnObject;
	}
	/** 
	 * getParent method returns the entire parent list(parent, their parent etc) 
	 * for a given node in the array provided as the argument.
	 * @param	catId	category Id 
	*/
	private function getParent(catId:Number):Object {
		//This method returns the parent category id of the given category till the tree top
		var count:Number = 0;
		var parent:Array = new Array();
		var rtnObject:Object = new Object();
		var parentId:Number = -1;
		//Increase the counter
		count++;
		//Add the current Node in the list
		parent.push(catId);
		//While we reach the root node - keep adding the node's parent ID
		while (catId != 0) {
			parentId = this.data[catId].parentId;
			catId = parentId;
			count++;
			parent.push(parentId);
		}
		//Allot to the object
		rtnObject.count = count;
		rtnObject.parent = parent;
		return rtnObject;
	}
	/** 
	 * parseAttributes method parses the attributes and stores them in
	 * chart storage objects.
	 * Starting ActionScript 2, the parsing of XML attributes have also
	 * become case-sensitive. However, prior versions of FusionCharts
	 * supported case-insensitive attributes. So we need to parse all
	 * attributes as case-insensitive to maintain backward compatibility.
	 * To do so, we first extract all attributes from XML, convert it into
	 * lower case and then store it in an array. Later, we extract value from
	 * this array.
	 * @param	graphElement	XML Node containing the <graph> element
	 *							and it's attributes	 
	*/
	private function parseAttributes(graphElement:XMLNode):Void {
		//Array to store the attributes
		var atts:Array = this.getAttributesArray(graphElement);
		//NOW IT'S VERY NECCESARY THAT WHEN WE REFERENCE THIS ARRAY
		//TO GET AN ATTRIBUTE VALUE, WE SHOULD PROVIDE THE ATTRIBUTE
		//NAME IN LOWER CASE. ELSE, UNDEFINED VALUE WOULD SHOW UP.
		//Extract attributes pertinent to this chart
		//Which palette to use?
		this.params.palette = getFN(atts["palette"], 1);
		//Whether to show about FusionCharts Menu Item - by default set to on
		this.params.showFCMenuItem = toBoolean(getFN (atts ["showfcmenuitem"] , 1));
		//Background properties - Gradient
		this.params.bgColor = getFV(atts["bgcolor"], this.defColors.get2DBgColor(this.params.palette));
		this.params.bgAlpha = getFV(atts["bgalpha"], this.defColors.get2DBgAlpha(this.params.palette));
		this.params.bgRatio = getFV(atts["bgratio"], this.defColors.get2DBgRatio(this.params.palette));
		this.params.bgAngle = getFV(atts["bgangle"], this.defColors.get2DBgAngle(this.params.palette));
		//Border Properties of chart
		this.params.showBorder = toBoolean(getFN(atts["showborder"], 1));
		this.params.borderColor = formatColor(getFV(atts["bordercolor"], this.defColors.get2DBorderColor(this.params.palette)));
		this.params.borderThickness = getFN(atts["borderthickness"], 1);
		this.params.borderAlpha = getFN(atts["borderalpha"], this.defColors.get2DBorderAlpha(this.params.palette));
		//Background swf
		this.params.bgSWF = getFV(atts["bgswf"], "");
		this.params.bgSWFAlpha = getFV(atts["bgswfalpha"], 100);
		// global URL
		this.params.clickURL = getFV(atts["clickurl"], "");
		//Chart Caption and sub Caption
		this.params.caption = getFV(atts["caption"], "");
		this.params.subCaption = getFV(atts["subcaption"], "");
		//captionPadding = Space between caption/subcaption and canvas start Y
		this.params.captionPadding = getFN(atts["captionpadding"], 10);
		//Whether to set animation for entire chart.                                                                                                                                      
		this.params.animation = toBoolean(getFN(atts["animation"], 1));
		//Whether to set the default chart animation
		this.params.defaultAnimation = toBoolean(getFN(atts["defaultanimation"], 1));
		//Configuration to set whether to show the names or not
		this.params.showNames = toBoolean(getFN(atts["showlabels"], atts["shownames"], 1));
		//Tool Tip - Show/Hide, Background Color, Border Color, Separator Character
		this.params.showToolTip = toBoolean(getFN(atts["showtooltip"], atts["showhovercap"], 1));
		this.params.toolTipBgColor = String(formatColor(getFV(atts["tooltipbgcolor"], atts["hovercapbgcolor"], atts["hovercapbg"], this.defColors.get2DToolTipBgColor(this.params.palette))));
		this.params.toolTipBorderColor = String(formatColor(getFV(atts["tooltipbordercolor"], atts["hovercapbordercolor"], atts["hovercapborder"], this.defColors.get2DToolTipBorderColor(this.params.palette))));
		//Seperator character
		this.params.toolTipSepChar = getFV(atts["tooltipsepchar"], atts["hovercapsepchar"], ", ");
		//Font Properties
		this.params.baseFont = getFV(atts["basefont"], "Verdana");
		this.params.baseFontSize = getFN(atts["basefontsize"], 9);
		this.params.baseFontColor = String(formatColor(getFV(atts["basefontcolor"], this.defColors.get2DBaseFontColor(this.params.palette))));
		// shadow related params                                                                                                                         
		this.params.showShadow = toBoolean(getFN(atts["showshadow"], 1));
		this.params.shadowColor = formatColor(getFV(atts["shadowcolor"], "666666"));
		this.params.shadowAlpha = getFN(atts["shadowalpha"], 100);
		// Pie related properties                                                                                                                                                                            
		this.params.pieRadius = atts["pieradius"];
		//Plot border properties
		this.params.showPlotBorder = toBoolean(getFN(atts["showplotborder"], 1));
		this.params.pieBorderThickness = getFN(atts["plotborderthickness"], atts["pieborderthickness"], 1);
		this.params.pieBorderAlpha = getFN(atts["plotborderalpha"], atts["pieborderalpha"], (this.params.showPlotBorder == true) ? 80 : 0);
		this.params.pieBorderColor = getFV(atts["plotbordercolor"], atts["piebordercolor"], this.defColors.get2DBgRatio(this.params.palette));
		this.params.pieFillAlpha = getFN(atts["plotfillalpha"], atts["piefillalpha"], 80);
		this.params.pieFillColor = getFV(atts["plotfillcolor"], atts["piebordercolor"]);
		this.params.useHoverColor = toBoolean(getFN(atts["usehovercolor"], 1));
		this.params.hoverFillColor = getFV(atts["hoverfillcolor"], "FF5904");
		//Chart Margins                      
		this.params.chartLeftMargin = getFN(atts["chartleftmargin"], 15);
		this.params.chartRightMargin = getFN(atts["chartrightmargin"], 15);
		this.params.chartTopMargin = getFN(atts["charttopmargin"], 15);
		this.params.chartBottomMargin = getFN(atts["chartbottommargin"], 15);
		// ---------------------- Image Saving ------------------------------//
		this.params.imageSave = toBoolean (getFN (atts ["imagesave"] , 0));
		this.params.imageSaveURL = getFV (atts ["imagesaveurl"] , "");
		this.params.imageSaveDialogColor = formatColor (getFV (atts ["imagesavedialogcolor"] , "E2E2E2"));
		this.params.imageSaveDialogFontColor = formatColor (getFV (atts ["imagesavedialogfontcolor"] , "666666"));
	}
	/**
	 * returnDataAsObject method creates an object out of the parameters
	 * passed to this method. The idea is that we store each data point
	 * as an object with multiple (flexible) properties. So, we do not 
	 * use a predefined class structure. Instead we use a generic object.
	 */
	private function returnDataAsObject(dataValue:Number, dataLabel:String, color:Number, fillAlpha:Number, toolText:String, link:String, dataParentId:Number):Object {
		//Create a container
		var dataObj:Object = new Object();
		//Store the values
		dataObj.value = dataValue;
		dataObj.label = dataLabel;
		dataObj.color = color;
		dataObj.alpha = fillAlpha;
		dataObj.toolText = toolText;
		dataObj.link = link;
		dataObj.parentId = dataParentId;
		//Default value
		dataObj.outerRadius = 0;
		dataObj.startAngle = 0;
		dataObj.endAngle = 0;
		dataObj.childList = new Array();
		dataObj.parentArr = new Array();
		//dataObj.position is reserved for storing coordinates of the pie
		//Return the container
		return dataObj;
	}
	// ---------------- CALCULATION AND OPTIMIZATION -----------------//
	/**
	* calculatePoints method calculates the various points on the chart.
	*/
	private function calculatePoints():Void {
		//We now need to calculate the available plot Width on the canvas.
		//Available width = total Chart width minus 
		// - Left and Right Margin
		var canvasWidth:Number = this.width-(this.params.chartLeftMargin+this.params.chartRightMargin);
		//Set canvas startX
		var canvasStartX:Number = this.params.chartLeftMargin;
		//We finally have canvas Width and canvas Start X
		//-----------------------------------------------------------------------------------//
		//Now, we need to calculate the available plot Height on the canvas.
		//Available height = total Chart height minus the list below
		// - Chart Top and Bottom Margins
		// - Space for Caption, Sub Caption and caption padding
		//Initialize canvasHeight to total height minus margins
		var canvasHeight:Number = this.height-(this.params.chartTopMargin+this.params.chartBottomMargin);
		//Set canvasStartY
		var canvasStartY:Number = this.params.chartTopMargin;
		//Now, if we've to show caption
		if (this.params.caption != "") {
			//Create text field to get height
			var captionObj:Object = createText(true, this.params.caption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.CAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+captionObj.height;
			canvasHeight = canvasHeight-captionObj.height;
			//Create element for caption - to store width & height
			this.elements.caption = returnDataAsElement(0, 0, captionObj.width, captionObj.height);
			delete captionObj;
		}
		//Now, if we've to show sub-caption                                                                                                                                                                                               
		if (this.params.subCaption != "") {
			//Create text field to get height
			var subCaptionObj:Object = createText(true, this.params.subCaption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.SUBCAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+subCaptionObj.height;
			canvasHeight = canvasHeight-subCaptionObj.height;
			//Create element for sub caption - to store height
			this.elements.subCaption = returnDataAsElement(0, 0, subCaptionObj.width, subCaptionObj.height);
			delete subCaptionObj;
		}
		//Now, if either caption or sub-caption was shown, we also need to adjust caption padding                                                                                                                                                                                               
		if (this.params.caption != "" || this.params.subCaption != "") {
			//Account for padding
			canvasStartY = canvasStartY+this.params.captionPadding;
			canvasHeight = canvasHeight-this.params.captionPadding;
		}
		//We now finally have canvas start Y and canvas height         
		//Create an element to represent the canvas now.
		this.elements.canvas = returnDataAsElement(canvasStartX, canvasStartY, canvasWidth, canvasHeight);
		//Diameter is set according to the left over canvas height/width - whichever is minimum
		var pieDia:Number = (canvasHeight<canvasWidth) ? (canvasHeight) : (canvasWidth);
		//Calculate the maximum radius 
		this.params.pieRadius = Number(getFV(this.params.pieRadius, (pieDia/2)));
		//Create the object for each pie slice
		this.elements.pie = returnDataAsElement(canvasStartX+canvasWidth/2, canvasStartY+canvasHeight/2, this.params.pieRadius, this.params.pieRadius);
		//we distribute the radius evenly
		this.config.perSegmentRadius = Math.round((this.params.pieRadius)/(this.config.levelCount));
		//Now, calculate the figures for all the data 
		this.data[0].outerRadius = 0;
		this.data[0].startAngle = 0;
		this.data[0].endAngle = 360;
		//We need to calculate the start angle and end angle for each category
		this.calculateLevelPoints(0);
	}
	/** 
	 * getTotalValue method calculates the total value of all the child of the given parent
	 * @param	parentId	parentId for which we need the values to be calculated
	*/
	private function getTotalValue(parentId:Number):Number {
		//This function calculates the total value for a given parent ID
		var sum:Number = 0;
		//Create a new Object
		var childObj:Object = new Object();
		///Get the child list of the node
		childObj = this.getChildren(parentId);
		//Category Id
		var catId:Number;
		for (catId in childObj.child) {
			//Keep adding the value
			sum += this.data[childObj.child[catId]].value;
		}
		//return the total value
		return sum;
	}
	/** 
	 * calculateLevelPoints method calculates the points for the given id
	 * @param	parentId	parentId for which we need the angles to be calculated
	*/
	private function calculateLevelPoints(parentId:Number):Void {
		//This function calculates the points for the given level
		//Angle
		var angle:Number = 0;
		//Level Count
		var lCount:Number = 0;
		//Child Object
		var childObj:Object = new Object();
		//Get the children list
		childObj = this.getChildren(parentId);
		//Get the total for the children nodes
		var total:Number = this.getTotalValue(parentId);
		//Category ID
		var catId:Number;
		//For each child category
		for (catId in childObj.child) {
			//Now, set it
			this.data[childObj.child[catId]].startAngle = this.data[parentId].startAngle+angle;
			//Calculate angle.
			angle += (this.data[parentId].endAngle-this.data[parentId].startAngle)*(this.data[childObj.child[catId]].value/total);
			this.data[childObj.child[catId]].endAngle = this.data[parentId].startAngle+angle;
			//End angle cannot exceed 360 arc value
			if (this.data[childObj.child[catId]].endAngle>360) {
				this.data[childObj.child[catId]].endAngle = 360;
			}
			//Store the outer radius
			this.data[childObj.child[catId]].outerRadius = this.data[parentId].outerRadius+this.config.perSegmentRadius;
			//Increase counter
			lCount++;
			//Now, if this category has got child nodes, do for the same.
			if (this.getChildren(childObj.child[catId]).count != 0) {
				//Set for same
				this.calculateLevelPoints(childObj.child[catId]);
			}
		}
	}
	/**
	 * feedMacros method feeds macros and their respective values
	 * to the macro instance. This method is to be called after
	 * calculatePoints, as we set the canvas and chart co-ordinates
	 * in this method, which is known to us only after calculatePoints.
	 * WE OVER-RIDE THE CHART CLASS METHOD BECAUSE CANVAS IS NOT DEFINED
	 * FOR A PIE CHART. SO, WE JUST ASSUME THE VALUES OF FULL PLOT AREA.
	 *	@returns	Nothing
	*/
	private function feedMacros():Void {
		//Feed macros one by one
		//Chart dimension macros
		this.macro.addMacro("$chartStartX", this.x);
		this.macro.addMacro("$chartStartY", this.y);
		this.macro.addMacro("$chartWidth", this.width);
		this.macro.addMacro("$chartHeight", this.height);
		this.macro.addMacro("$chartEndX", this.width);
		this.macro.addMacro("$chartEndY", this.height);
		this.macro.addMacro("$chartCenterX", this.width/2);
		this.macro.addMacro("$chartCenterY", this.height/2);
		//Canvas dimension macros
		this.macro.addMacro("$canvasStartX", this.x);
		this.macro.addMacro("$canvasStartY", this.y);
		this.macro.addMacro("$canvasWidth", this.width);
		this.macro.addMacro("$canvasHeight", this.height);
		this.macro.addMacro("$canvasEndX", this.width);
		this.macro.addMacro("$canvasEndY", this.height);
		this.macro.addMacro("$canvasCenterX", this.width/2);
		this.macro.addMacro("$canvasCenterY", this.height/2);
	}
	// -------------- VISUAL RENDERING METHODS ---------------------//
	/**
	* drawHeaders method renders the following on the chart:
	* CAPTION, SUBCAPTION
	*/
	private function drawHeaders() {
		//Sub-caption start y position
		var subCaptionY:Number = this.params.chartTopMargin;
		//Render caption
		if (this.params.caption != "") {
			var captionStyleObj:Object = this.styleM.getTextStyle(this.objects.CAPTION);
			captionStyleObj.align = "center";
			captionStyleObj.vAlign = "bottom";
			var captionObj:Object = createText(false, this.params.caption, this.cMC, this.dm.getDepth('CAPTION'), (this.width/2), this.params.chartTopMargin, 0, captionStyleObj, false, 0, 0);
			//Add for sub-caption y position
			subCaptionY = subCaptionY+captionObj.height;
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(captionObj.tf, this.objects.CAPTION, this.macro, captionObj.tf._x, 0, captionObj.tf._y, 0, 100, null, null, null);
			}
			//Apply filters                                                                                                                                                                                               
			this.styleM.applyFilters(captionObj.tf, this.objects.CAPTION);
			//Delete
			delete captionObj;
			delete captionStyleObj;
		}
		//Render sub caption                                                                                                                                                                                               
		if (this.params.subCaption != "") {
			var subCaptionStyleObj:Object = this.styleM.getTextStyle(this.objects.SUBCAPTION);
			subCaptionStyleObj.align = "center";
			subCaptionStyleObj.vAlign = "bottom";
			var subCaptionObj:Object = createText(false, this.params.subCaption, this.cMC, this.dm.getDepth('SUBCAPTION'), (this.width/2), subCaptionY, 0, subCaptionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(subCaptionObj.tf, this.objects.SUBCAPTION, this.macro, subCaptionObj.tf._x, 0, subCaptionObj.tf._y, 0, 100, null, null, null);
			}
			//Apply filters                                                                                                                                                                                               
			this.styleM.applyFilters(subCaptionObj.tf, this.objects.SUBCAPTION);
			//Delete
			delete subCaptionObj;
			delete subCaptionStyleObj;
		}
		//Clear interval                                                                                                                                                                                          
		clearInterval(this.config.intervals.headers);
	}
	/**
	* drawArc method draw an arc of specified angle
	 * @param	mc			MovieClip in which we need the arc to be drawn
 	 * @param	x			X position of the arc
	 * @param	y			y position of the arc
	 * @param	startAngle	starting angle of the arc
	 * @param	arc			Arc span angle
	 * @param	radius		x radius of the arc
	 * @param	yRadius		y radius of the arc
	*/
	private function drawArc(mc:MovieClip, x:Number, y:Number, startAngle:Number, arc:Number, radius:Number, yRadius:Number) {
		// ==============
		// x, y = center point of the wedge.
		// startAngle = starting angle in degrees.
		// arc = sweep of the wedge. Negative values draw clockwise.
		// radius = radius of wedge. If [optional] yRadius is defined, then radius is the x radius.
		// yRadius = [optional] y radius for wedge.
		// if yRadius is undefined, yRadius = radius
		if (yRadius == undefined) {
			yRadius = radius;
		}
		// Init vars   
		var segAngle, theta, angle, angleMid, segs, ax, ay, bx, by, cx, cy;
		// limit sweep to reasonable numbers
		if (Math.abs(arc)>360) {
			arc = 360;
		}
		// Flash uses 8 segments per circle, to match that, we draw in a maximum   
		// of 45 degree segments. First we calculate how many segments are needed
		// for our arc.
		segs = Math.ceil(Math.abs(arc)/45);
		// Now calculate the sweep of each segment.
		segAngle = arc/segs;
		// The math requires radians rather than degrees. To convert from degrees
		// use the formula (degrees/180)*Math.PI to get radians.
		theta = -(segAngle/180)*Math.PI;
		// convert angle startAngle to radians
		angle = -(startAngle/180)*Math.PI;
		// draw the curve in segments no larger than 45 degrees.
		if (segs>0) {
			// draw a line from the center to the start of the curve
			ax = x+Math.cos(startAngle/180*Math.PI)*radius;
			ay = y+Math.sin(-startAngle/180*Math.PI)*yRadius;
			//If we have more than 1 totalSlices, then we draw line to the center
			// Loop for drawing curve segments
			for (var i = 0; i<segs; i++) {
				angle += theta;
				angleMid = angle-(theta/2);
				bx = x+Math.cos(angle)*radius;
				by = y+Math.sin(angle)*yRadius;
				cx = x+Math.cos(angleMid)*(radius/Math.cos(theta/2));
				cy = y+Math.sin(angleMid)*(yRadius/Math.cos(theta/2));
				mc.curveTo(cx, cy, bx, by);
			}
		}
	}
	/**
	* drawPie method draws a single pie within the chart
	 * @param	mc			MovieClip in which we need the pie to be drawn
 	 * @param	x			X position of the arc
	 * @param	y			y position of the arc
	 * @param	radius		outer radius of the pie slice
	 * @param	innerRadius	inner radius of the slice
	 * @param	startAngle	starting angle of the pie
	 * @param	arcAngle	Arc span angle
	 * @param	fillColor 	pie fill color
	 * @param	alpha		pie fill alpha
	 * @param	borderColor		border color of the pie
	 * @param	borderThickness		border thickness of the pie
	 * @param	borderAlpha		border alpha of the pie
	*/
	private function drawPie(mc:MovieClip, x:Number, y:Number, radius:Number, innerRadius:Number, startAngle:Number, arcAngle:Number, fillColor:Number, alpha:Number, borderColor:String, borderThickness:Number, borderAlpha:Number) {
		//This function draws a pie
		startAngle = -arcAngle/2;
		mc.lineStyle(borderThickness, parseInt(borderColor, 16), borderAlpha);
		mc.beginFill(fillColor, alpha);
		var ax = x+Math.cos(startAngle/180*Math.PI)*radius;
		var ay = y+Math.sin(-startAngle/180*Math.PI)*radius;
		mc.moveTo(ax, ay);
		this.drawArc(mc, x, y, startAngle, arcAngle, radius, radius);
		ax = x+Math.cos((arcAngle+startAngle)/180*Math.PI)*innerRadius;
		ay = y+Math.sin(-(arcAngle+startAngle)/180*Math.PI)*innerRadius;
		mc.lineTo(ax, ay);
		this.drawArc(mc, x, y, (startAngle+arcAngle), -arcAngle, innerRadius);
		ax = x+Math.cos(startAngle/180*Math.PI)*radius;
		ay = y+Math.sin(-startAngle/180*Math.PI)*radius;
		mc.lineTo(ax, ay);
		mc.endFill();		
	}
	/** 
	 * draw method draws the pie chart by calling various other 
	 * methods of this class.
	*/
	private function draw():Void {
		//This function renders the pies
		//Loop variable
		var i:Number;
		var parentObj:Object;
		//Depth of the pie
		var depth:Number = this.dm.getDepth("DATAPLOT");
		//depth of the pie border
		var borderDepth:Number = this.dm.getDepth("DATABORDER");
		//Create function storage containers for Delegate functions
		var fnRollOver:Function, fnClick:Function, fnRollOut:Function;
		//Create the container
		var mcPieCont:MovieClip = this.cMC.createEmptyMovieClip("PieCont", depth);
		var mcPie:MovieClip;
		//Now, the rest of slices
		for (i=1; i<=this.num; i++) {
			//Create the pie
			mcPie = mcPieCont.createEmptyMovieClip("ASMov_Pie_"+i, i);
			//create the pie border
			var mcPieBorder:MovieClip = this.cMC.createEmptyMovieClip("ASMov_PieBorder_"+i, borderDepth);
			//Draw the pie
			this.drawPie(mcPie, 0, 0, this.data[i].outerRadius, this.data[i].outerRadius-this.config.perSegmentRadius, this.data[i].startAngle, this.data[i].endAngle-this.data[i].startAngle, this.data[i].color, 100, this.params.pieBorderColor, this.params.pieBorderThickness, 0);
			//Set the actual Alpha
			mcPie._alpha = this.data[i].alpha;
			//Set the position
			mcPie._x = this.elements.pie.x;
			mcPie._y = this.elements.pie.y;
			if (i != 1) {
				//draw the pie border
				this.drawPie(mcPieBorder, 0, 0, this.data[i].outerRadius, this.data[i].outerRadius-this.config.perSegmentRadius, this.data[i].startAngle, this.data[i].endAngle-this.data[i].startAngle, this.data[i].color, 0, this.params.pieBorderColor, this.params.pieBorderThickness, this.params.pieBorderAlpha);
			}
			//Set the position 
			mcPieBorder._x = this.elements.pie.x;
			mcPieBorder._y = this.elements.pie.y;
			//parent id's
			parentObj = this.getParent(i);
			//Event handlers for tool tip
			if (this.params.showToolTip) {
				//Create Delegate for roll over function pieOnRollOver
				fnRollOver = Delegate.create(this, pieOnRollOver);
				//Set the index
				fnRollOver.index = i;
				fnRollOver.count = parentObj.count;
				fnRollOver.parentList = parentObj;
				//Assing the delegates to movie clip handler
				mcPie.onRollOver = fnRollOver;
				//Set roll out and mouse move too.
				//Create Delegate for roll over function pieOnRollOver
				fnRollOut = Delegate.create(this, pieOnRollOut);
				//Set the index
				fnRollOut.count = parentObj.count;
				fnRollOut.parentList = parentObj;
				mcPie.onRollOut = mcPie.onReleaseOutside=fnRollOut;
				mcPie.onMouseMove = Delegate.create(this, pieOnMouseMove);
			}
			//Click handler for links - only if link for this column has been defined and click URL  
			//has not been defined.
			if (this.data[i].link != "" && this.data[i].link != undefined && this.params.clickURL == "") {
				//Create delegate function
				fnClick = Delegate.create(this, pieOnClick);
				//Set index
				fnClick.index = i;
				//Assign
				mcPie.onRelease = fnClick;
			} else {
				//Do not use hand cursor
				mcPie.useHandCursor = (this.params.clickURL == "") ? false : true;
			}
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(mcPie, this.objects.DATAPLOT, this.macro, this.elements.pie.x, 0, this.elements.pie.y, 0, 100, 100, 100, -((this.data[i].startAngle+this.data[i].endAngle)/2));
				this.styleM.applyAnimation(mcPieBorder, this.objects.DATAPLOT, this.macro, this.elements.pie.x, 0, this.elements.pie.y, 0, 100, 100, 100, -((this.data[i].startAngle+this.data[i].endAngle)/2));
			}
			if (!(this.params.animation) || !(this.params.defaultAnimation)){			
				//Set rotation to final angle
				mcPie._rotation = -((this.data[i].startAngle+this.data[i].endAngle)/2);
				mcPieBorder._rotation = -((this.data[i].startAngle+this.data[i].endAngle)/2);
			}
			//increase the pie border depth 
			borderDepth++;
		}
		//Apply filters     
		this.styleM.applyFilters(mcPieCont, this.objects.DATAPLOT);
		//Clear sequence interval
		clearInterval(this.config.intervals.plot);
	}
	/**
	 * calculatePoint method calculates a point from the given point with a specified distance.
	*/
	private function calculatePoint(fromX:Number, fromY:Number, distance:Number, angle:Number):Object {
		//This function calculates the x and y co-ordinates of a point at an angular distance of "distance,angle" from the base point fromX, fromY
		//Convert the angle into radians
		angle = angle*(Math.PI/180);
		var xPos:Number = fromX+(distance*Math.cos(angle));
		var yPos:Number = fromY-(distance*Math.sin(angle));
		return ({x:xPos, y:yPos});
	}
	/**
	 * setLabels method sets the label for each pie slice around the center point of pie
	*/
	private function setLabels():Void {
		//This method sets the labels for the chart
		if (this.params.showNames) {
			var depth:Number = this.dm.getDepth("DATALABELS");
			var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
			//Set the rest of the labels
			for (var i:Number = 1; i<=this.num; i++) {
				if (i != 1) {
					//Get the point for this pie slice
					var point:Object = this.calculatePoint(this.elements.pie.x, this.elements.pie.y, this.data[i].outerRadius-(this.config.perSegmentRadius/2), this.data[i].startAngle+((this.data[i].endAngle-this.data[i].startAngle)/2));
					//Create the text
					Utils.createText(false, this.data[i].label, this.cMC, ++depth, point.x, point.y, 0, labelStyleObj, false, 0, 0);
				} else {
					//Create the text
					Utils.createText(false, this.data[i].label, this.cMC, ++depth, this.elements.pie.x, this.elements.pie.y, 0, labelStyleObj, false, 0, 0);
				}
			}
		}
		//Clear 
		clearInterval(this.config.intervals.label);
	}
	/**
	 * setContextMenu method is called only once initially
	 * to set right click behavior and optios.
	 */
	private function setContextMenu():Void {
		// ContextMenu instance is created
		var cmCustom:ContextMenu = new ContextMenu();
		// hide the default menu items
		cmCustom.hideBuiltInItems();
		//Create a print chart contenxt menu item
		var printCMI : ContextMenuItem = new ContextMenuItem ("Print Chart", Delegate.create (this, printChart));
		//Push print item.
		cmCustom.customItems.push (printCMI);
		if (this.params.imageSave){
			//Add the export to image option
			cmCustom.customItems.push(super.returnImageSaveMenuItem());		
		}		
		if (this.params.showFCMenuItem){
			//Push "About FusionCharts" Menu Item
			cmCustom.customItems.push(super.returnAbtMenuItem());		
		}
		// applying the custom menu formed to the chart movieclip ... vital for multichart display in one swf 
		this.cMC.menu = cmCustom;
	}
	//--------------- EVENT HANDLERS -----------------//
	/**
	 * pieOnRollOver is the delegat-ed event handler method that'll
	 * be invoked when the user rolls his mouse over a pie slice. 
	 * This function is invoked, only if the tool tip is to be shown.
	 * Here, we show the tool tip.
	*/
	private function pieOnRollOver():Void {
		//Index of column is stored in arguments.caller.index
		var index:Number = arguments.caller.index;
		//Count
		var count:Number = arguments.caller.count;
		var parentList:Object = arguments.caller.parentList;
		//Loop Variable
		var i:Number;
		//If hover color is required.
		if (this.params.useHoverColor) {
			//We first highlight the colors of the selected catId.
			//Highlight the colors of movie clips
			for (i=0; i<count; i++) {
				//Pie
				var mcPieRef:MovieClip = eval(this.cMC+".PieCont.ASMov_Pie_"+parentList.parent[i]);
				var clrPie:Color = new Color(mcPieRef);
				//Set the highlight color
				clrPie.setRGB(parseInt(this.params.hoverFillColor, 16));
				//Set to max alpha
				mcPieRef._alpha = 100;
			}
		}
		//If hover cap is to be shown. 
		//Set tool tip text
		this.tTip.setText(this.data[index].toolText);
		//Show the tool tip
		this.tTip.show();
	}
	/**
	 * pieOnRollOut method is invoked when the mouse rolls out
	 * of column. We just hide the tool tip here.
	*/
	private function pieOnRollOut():Void {
		//This function hides the hover caption
		//Re-set the original colors
		//Count
		var count:Number = arguments.caller.count;
		var parentList:Object = arguments.caller.parentList;
		//Loop Variable
		var i:Number;
		//If hover color is required.
		if (this.params.useHoverColor) {
			//We first highlight the colors of the selected catId.
			//Highlight the colors of movie clips
			for (i=0; i<count; i++) {
				var mcPieRef:MovieClip = eval(this.cMC+".PieCont.ASMov_Pie_"+parentList.parent[i]);
				//Set back to its original alpha
				mcPieRef._alpha = this.data[parentList.parent[i]].alpha;
				var clrPie:Color = new Color(mcPieRef);
				//re-Set the color
				clrPie.setRGB(this.data[parentList.parent[i]].color);
			}
		}
		//Hide the tool tip 
		this.tTip.hide();
	}
	/*
	 * pieOnMouseMove is called when the mouse position has changed
	 * over column. We reposition the tool tip.
	*/
	private function pieOnMouseMove():Void {
		//Reposition the tool tip only if it's in visible state
		if (this.tTip.visible()) {
			this.tTip.rePosition();
		}
	}
	/**
	 * pieOnClick is invoked when the user clicks on a column (if link
	 * has been defined). We invoke the required link.														  
	*/
	private function pieOnClick():Void {
		//Index of column is stored in arguments.caller.index
		var index:Number = arguments.caller.index;
		//Invoke the link
		super.invokeLink(this.data[index].link);
	}
	/**
	 * reInit method re-initializes the chart. This method is basically called
	 * when the user changes chart data through JavaScript. In that case, we need
	 * to re-initialize the chart, set new XML data and again render.
	*/
	public function reInit():Void {
		//Invoke super class's reInit
		super.reInit();
		//Now initialize things that are pertinent to this class
		//but not defined in super class.
		//Num
		this.num = 0;
		//Initialize data container
		this.data = new Array();
		//Set the properties radius, start and end angle
		this.data[0] = this.returnDataAsObject(1, "", 0, 100, "", "", 0);
		//Set the level Count back to zero
		this.config.levelCount = 0;
	}
	/**
	 * remove method removes the chart by clearing the chart movie clip
	 * and removing any listeners. However, the logger still stays on.
	 * To remove the logger too, you need to call destroy method of chart.
	*/
	public function remove():Void {
		//Call super remove
		super.remove();
	}
	/**
	 * destroy method destroys the chart by removing the chart movie clip,
	 * logger movie clip, and removing any listeners. 
	*/
	public function destroy():Void {
		//Destroy chart
		super.destroy();
		//Now destroy anything additional pertinent to this chart, but
		//not included as a part of parent Chart class.
	}
}

