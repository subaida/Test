/**
* @class MSDragColumn2DChart
* @author InfoSoft Global (P) Ltd. www.InfoSoftGlobal.com
* @version 3.0
*
* Copyright (C) InfoSoft Global Pvt. Ltd. 2005-2006
*
* MSDragColumn2DChart chart extends the Drag2DVerticalChart class to render a
* Multi-series 2D Drag-able Column Chart.
*/
//Import Chart class
import com.fusioncharts.core.Chart;
//Parent SingleYAxis2DVerticalChart Class
import com.fusioncharts.core.SingleYAxis2DVerticalChart;
//Error class
import com.fusioncharts.helper.FCError;
//Import Logger Class
import com.fusioncharts.helper.Logger;
//Style Object
import com.fusioncharts.core.StyleObject;
//Delegate
import mx.utils.Delegate;
//Columns
import com.fusioncharts.core.chartobjects.DragColumn2D;
//Legend Class
import com.fusioncharts.helper.Legend;
//Dialog Box
import com.fusioncharts.helper.FCErrorDialogBox;
//Button
import com.fusioncharts.helper.FCButton;
//Extensions
import com.fusioncharts.extensions.ColorExt;
import com.fusioncharts.extensions.StringExt;
//Class
class com.fusioncharts.core.charts.DragColumn2DChart extends com.fusioncharts.core.Drag2DVerticalChart {
	//Version number (if different from super Chart class)
	//private var _version:String = "3.0.0";
	//Instance variables
	//List of chart objects
	private var _arrObjects:Array;
	private var xmlData:XML;
	//Array to store x-axis categories (labels)
	private var categories:Array;
	//Array to store datasets
	private var dataset:Array;
	//Number of data sets
	private var numDS:Number;
	//Number of data items
	private var num:Number;
	//Reference to legend component of chart
	private var lgnd:Legend;
	//Reference to legend movie clip
	private var lgndMC:MovieClip;
	//Dialog Box
	private var db:FCErrorDialogBox;
	//Listener Object for the column
	private var colListener:Object;
	//Listener Object for the resize Roll Over handler
	private var resizeROverListener:Object;
	//Listener Object for the resize Roll Over handler
	private var resizeROutListener:Object;
	/**
	* Constructor function. We invoke the super class'
	* constructor and then set the objects for this chart.
	*/
	function DragColumn2DChart(targetMC:MovieClip, depth:Number, width:Number, height:Number, x:Number, y:Number, debugMode:Boolean, lang:String, scaleMode:String, registerWithJS:Boolean, DOMId:String) {
		//Invoke the super class constructor
		super (targetMC, depth, width, height, x, y, debugMode, lang, scaleMode, registerWithJS, DOMId);
		//Log additional information to debugger
		//We log version from this class, so that if this class version
		//is different, we can log it
		this.log("Version", _version, Logger.LEVEL.INFO);
		this.log("Chart Type", "Multi Series 2D Drag Column Chart", Logger.LEVEL.INFO);
		//List Chart Objects and set them
		_arrObjects = new Array("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "YAXISNAME", "XAXISNAME", "DIVLINES", "YAXISVALUES", "HGRID","DATALABELS", "DATAVALUES", "TRENDLINES", "TRENDVALUES", "DATAPLOT", "TOOLTIP", "VLINES", "LEGEND");
		super.setChartObjects(_arrObjects);
		//Initialize the containers for chart
		this.categories = new Array();
		this.dataset = new Array();
		//Initialize the number of data elements present
		this.numDS = 0;
		this.num = 0;
		//Set the constant for animation over
		this.config.animationOver = false;
		//Array to store the valueTB
		this.config.valTf = new Array();
		//Initialize the listener object
		colListener  =  new Object();
		//Initialize the resize handler event listeners
		resizeROverListener = new Object();
		resizeROutListener = new Object();
	}
	/**
	* render method is the single call method that does the rendering of chart:
	* - Parsing XML
	* - Calculating values and co-ordinates
	* - Visual layout and rendering
	* - Event handling
	*/
	public function render(flagRestore:Boolean):Void {
		//Parse the XML Data document
		this.parseXML();
		//Update restore events/flags
		if (flagRestore){
			//We do not need animation for restoring the chart
			this.params.defaultAnimation = false;
			this.params.animation = false;
		}
		//Now, if the number of data elements is 0, we show pertinent
		//error.
		if (this.numDS*this.num == 0) {
			tfAppMsg = this.renderAppMessage(_global.getAppMessage("NODATA", this.lang));
			//Add a message to log.
			this.log("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn't any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI><LI>You might be using a Single Series Chart .swf file instead of Multi-series .swf file and providing multi-series data or vice-versa.</LI>", Logger.LEVEL.ERROR);
			//Expose rendered method
			this.exposeChartRendered();
		} else {			
			//Detect number scales
			this.detectNumberScales();
			//Calculate the axis limits
			this.calculateAxisLimits();
			//Calculate exact number of div lines
			this.calcDivs();			
			//Set Style defaults
			this.setStyleDefaults();			
			//Validate trend lines
			this.validateTrendLines();
			//Allot the depths for various charts objects now
			this.allotDepths();			
			//Calculate Points
			this.calculatePoints();
			//Calculate vLine Positions
			this.calcVLinesPos();
			//Calculate trend line positions
			this.calcTrendLinePos();			
			//Feed macro values
			super.feedMacros();			
			//Remove application message
			this.removeAppMessage(this.tfAppMsg);
			//Set tool tip parameter
			this.setToolTipParam();
			//-----Start Visual Rendering Now------//
			//Draw background
			this.drawBackground();
			//Set click handler
			this.drawClickURLHandler()
			//Load background SWF
			this.loadBgSWF();
			//Draw the dialog Box
			this.drawDialogBox();
			//Draw the Resize Handler
			this.drawResizeHandler();
			//Update timer
			this.timeElapsed = (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.BACKGROUND) : 0;
			//Draw canvas
			this.config.intervals.canvas = setInterval(Delegate.create(this, drawCanvas), this.timeElapsed);
			//Draw headers
			this.config.intervals.headers = setInterval(Delegate.create(this, drawHeaders), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.CANVAS, this.objects.CAPTION, this.objects.SUBCAPTION, this.objects.YAXISNAME, this.objects.XAXISNAME) : 0;
			//Draw div lines
			this.config.intervals.divLines = setInterval(Delegate.create(this, drawDivLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DIVLINES, this.objects.YAXISVALUES) : 0;			
			//Horizontal grid
			this.config.intervals.hGrid = setInterval(Delegate.create(this, drawHGrid), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.HGRID) : 0;
			//Draw labels
			this.config.intervals.labels = setInterval(Delegate.create(this, drawLabels), this.timeElapsed);
			//Draw columns
			this.config.intervals.plot = setInterval(Delegate.create(this, drawColumns), this.timeElapsed);
			//Legend
			this.config.intervals.legend = setInterval(Delegate.create(this, drawLegend), this.timeElapsed);			
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DATALABELS, this.objects.DATAPLOT, this.objects.LEGEND) : 0;
			//Data Values
			var fnDrawValues:Function;
			fnDrawValues = Delegate.create(this, drawValues);
			fnDrawValues.startDsIndex = 1;
			fnDrawValues.endDsIndex = this.numDS;
			fnDrawValues.startIndex = 1;
			fnDrawValues.endIndex = this.num;
			this.config.intervals.dataValues = setInterval(fnDrawValues, this.timeElapsed);
			//Draw trend lines
			this.config.intervals.trend = setInterval(Delegate.create(this, drawTrendLines), this.timeElapsed);
			//Draw vertical div lines
			this.config.intervals.vLine = setInterval(Delegate.create(this, drawVLines), this.timeElapsed);
			if(this.params.showFormBtn) {
				//Draw and show the form button
				this.config.intervals.formBtn = setInterval(Delegate.create(this, drawFormBtn), this.timeElapsed);
			}
			if(this.params.showRestoreBtn) {
				//Draw and show the restore button
				this.config.intervals.restoreBtn = setInterval(Delegate.create(this, drawRestoreBtn), this.timeElapsed);
			}
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.TRENDLINES, this.objects.TRENDVALUES, this.objects.VLINES, this.objects.DATAVALUES) : 0;			
			//Set animation flag
			this.config.intervals.animationReqd = setInterval(Delegate.create(this, setAnimationFlag), this.timeElapsed);			
			//Dispatch event that the chart has loaded.
			this.config.intervals.renderedEvent = setInterval(Delegate.create(this, exposeChartRendered) , this.timeElapsed);
			//Render context menu
			//We do not put context menu interval as we need the menu to appear
			//right from start of the play.
			this.setContextMenu();	
		}
	}
	/**
	* returnDataAsObject method creates an object out of the parameters
	* passed to this method. The idea is that we store each data point
	* as an object with multiple (flexible) properties. So, we do not
	* use a predefined class structure. Instead we use a generic object.
	*	@param	label		Label of the data column.
	*	@param	value		Value for the column.
	*	@param	color		Hex Color code (or comma separated list).
	*	@param	alpha		List of alphas separated by comma
	*	@param	ratio		List of color ratios separated by comma
	*	@param	toolText	Tool tip text (if specified).
	*	@param	link		Link (if any) for the column.
	*	@param	showLabel	Flag to show/hide label for this column.
	*	@param	showValue	Flag to show/hide value for this column.
	*	@param	isDashed	Flag whether the column would have dashed border.
	*	@param	isDraggable	Flag whether the column dragging is allowed.
	*	@param	isNegativeDraggable	Flag whether the column dragging is allowed on negative plane.
	*	@returns			An object encapsulating all these properies.
	*/
	private function returnDataAsObject(id:String, value:Number, color:String, alpha:String, ratio:String, toolText:String, link:String, showValue:Number, isDashed:Boolean, isDraggable:Boolean, isNegativeDraggable:Boolean):Object {
		//Create a container
		var dataObj:Object = new Object();
		//Store the id
		dataObj.id = id;
		//Store the values		
		dataObj.value = value;
		//Store the updated Value as the current value
		dataObj.updatedValue = value;
		//Extract and save colors, ratio, alpha as array so that we do not have to parse later.
		dataObj.color = ColorExt.parseColorList(color);
		dataObj.alpha = ColorExt.parseAlphaList(alpha, dataObj.color.length);
		dataObj.ratio = ColorExt.parseRatioList(ratio, dataObj.color.length);
		dataObj.toolText = toolText;
		dataObj.link = link;				
		dataObj.showValue = (showValue == 1) ? true : false;
		dataObj.dashed = isDashed;
		dataObj.isDraggable = isDraggable;
		dataObj.isNegativeDraggable = isNegativeDraggable;
		//If the given number is not a valid number or it's missing
		//set appropriate flags for this data point
		dataObj.isDefined = ((dataObj.alpha[0] == 0) || isNaN(value)) ? false : true;
		//Other parameters
		//X & Y Position of data point
		dataObj.x = 0;
		dataObj.y = 0;
		//Width and height
		dataObj.w = 0;
		dataObj.h = 0;
		//X & Y Position of value tb
		dataObj.valTBX = 0;
		dataObj.valTBY = 0;
		//Return the container
		return dataObj;
	}
	/**
	 * returnDataAsCat method returns data of a <category> element as
	 * an object
	 *	@param	label		Label of the category.
	 *	@param	showLabel	Whether to show the label of this category.
	 *	@param	toolText	Tool-text for the category
	 *	@returns			A container object with the given properties
	*/
	private function returnDataAsCat(label:String, showLabel:Number, toolText:String):Object{
		//Create container object
		var catObj:Object = new Object();
		catObj.label = label;
		catObj.showLabel = ((showLabel == 1) && (label!=undefined) && (label!=null) && (label!="")) ? true : false;
		catObj.toolText = toolText;
		//X and Y Position
		catObj.x = 0;
		catObj.y = 0;
		//Return container
		return catObj;
	}
	/**
	* parseXML method parses the XML data, sets defaults and validates
	* the attributes before storing them to data storage objects.
	*/
	private function parseXML():Void {
		//Get the element nodes
		var arrDocElement:Array = this.xmlData.childNodes;
		//Loop variable
		var i:Number;
		var j:Number;
		var k:Number;
		//Look for <graph> element
		for (i=0; i<arrDocElement.length; i++) {
			//If it's a <graph> element, proceed.
			//Do case in-sensitive mathcing by changing to upper case
			if (arrDocElement[i].nodeName.toUpperCase() == "GRAPH" || arrDocElement[i].nodeName.toUpperCase() == "CHART") {
				//Extract attributes of <graph> element
				this.parseAttributes(arrDocElement[i]);
				//Now, get the child nodes - first level nodes
				//Level 1 nodes can be - CATEGORIES, DATASET, TRENDLINES, STYLES etc.
				var arrLevel1Nodes:Array = arrDocElement[i].childNodes;
				var setNode:XMLNode;
				//Iterate through all level 1 nodes.
				for (j=0; j<arrLevel1Nodes.length; j++) {
					if (arrLevel1Nodes[j].nodeName.toUpperCase() == "CATEGORIES") {
						//Categories Node. 
						var categoriesNode:XMLNode = arrLevel1Nodes[j];
						//Convert attributes to array
						var categoriesAtt:Array = this.getAttributesArray(categoriesNode);
						//Extract attributes of this node.
						this.params.catFont = getFV(categoriesAtt["font"],this.params.outCnvBaseFont);
						this.params.catFontSize = getFN(categoriesAtt["fontsize"],this.params.outCnvBaseFontSize);
						this.params.catFontColor = formatColor(getFV(categoriesAtt["fontcolor"],this.params.outCnvBaseFontColor));
						//Get reference to child node.
						var arrLevel2Nodes:Array = arrLevel1Nodes[j].childNodes;
						//Iterate through all child-nodes of CATEGORIES element
						//and search for CATEGORY or VLINE node
						for (k=0; k<arrLevel2Nodes.length; k++){
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "CATEGORY"){
								//Category Node. 
								//Update counter
								this.num++;
								//Extract attributes
								var categoryNode:XMLNode = arrLevel2Nodes[k];
								var categoryAtt:Array = this.getAttributesArray(categoryNode);
								//Category label.
								var catLabel:String = getFV(categoryAtt["label"], categoryAtt["name"], "");
								var catShowLabel:Number = getFN(categoryAtt["showlabel"], categoryAtt["showname"], this.params.showLabels);
								var catToolText:String = getFV(categoryAtt["tooltext"], categoryAtt["hovertext"], catLabel);
								//Store it in data container.
								this.categories[this.num] = this.returnDataAsCat(catLabel, catShowLabel, catToolText);
							}
							else if (arrLevel2Nodes[k].nodeName.toUpperCase() == "VLINE") {
								//Vertical axis division Node - extract child nodes
								var vLineNode:XMLNode = arrLevel2Nodes[k];
								//Parse and store
								this.parseVLineNode(vLineNode, this.num);
							}
						}						
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "DATASET") {
						//Increment
						this.numDS++;
						//Dataset node.
						var dataSetNode:XMLNode = arrLevel1Nodes[j];
						//Get attributes array
						var dsAtts:Array = this.getAttributesArray(dataSetNode);
						//Create storage object in dataset array
						this.dataset[this.numDS] = new Object();
						//Store attributes
						this.dataset[this.numDS].id = getFV(dsAtts["id"], this.numDS);						
						this.dataset[this.numDS].seriesName = getFV(dsAtts["seriesname"],"");
						this.dataset[this.numDS].color = getFV(dsAtts["color"],this.defColors.getColor());
						//If plot gradient color has been defined, add it
						if (this.params.plotGradientColor!=""){
							this.dataset[this.numDS].color = this.dataset[this.numDS].color + "," + this.params.plotGradientColor;
						}
						this.dataset[this.numDS].alpha = getFV(dsAtts["alpha"], this.params.plotFillAlpha);
						this.dataset[this.numDS].ratio = getFV(dsAtts["ratio"], this.params.plotFillRatio);
						this.dataset[this.numDS].showValues = toBoolean(getFN(dsAtts["showvalues"], this.params.showValues));
						this.dataset[this.numDS].dashed = toBoolean(getFN(dsAtts["dashed"], this.params.plotBorderDashed));
						this.dataset[this.numDS].includeInLegend = toBoolean(getFN(dsAtts["includeinlegend"], 1));
						//Drag Border properties
						this.dataset[this.numDS].allowDrag = toBoolean(getFN(dsAtts["allowdrag"], "1"));
						this.dataset[this.numDS].allowNegativeDrag = toBoolean(getFN(dsAtts["allownegativedrag"], "1"));
						this.dataset[this.numDS].dragBorderColor = getFV(dsAtts["dragbordercolor"],this.params.dragBorderColor);
						this.dataset[this.numDS].dragBorderThickness = getFN(dsAtts["dragborderthickness"], this.params.dragBorderThickness);
						this.dataset[this.numDS].dragBorderAlpha = getFN(dsAtts["dragborderalpha"], this.params.dragBorderAlpha);
						//Create data array under it.
						this.dataset[this.numDS].data = new Array();						
						//Get reference to child node.
						var arrLevel2Nodes:Array = arrLevel1Nodes[j].childNodes;
						//Iterate through all child-nodes of DATASET element
						//and search for SET node
						//Counter
						var setCount:Number = 0;
						for (k=0; k<arrLevel2Nodes.length; k++){
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "SET") {
								//Set Node. So extract the data.
								//Update counter
								setCount++;
								//Get reference to node.
								setNode = arrLevel2Nodes[k];
								//Get attributes
								var atts:Array;
								atts = this.getAttributesArray(setNode);							
								//Now, get value.
								var setValue:Number = this.getSetValue(atts["value"]);
								//We do NOT unescape the link, as this will be done
								//in invokeLink method for the links that user clicks.
								var setId:String = getFV(atts["id"], setCount+"_"+this.dataset[this.numDS].id);
								var setLink:String = getFV(atts["link"], "");
								var setToolText:String = getFV(atts["tooltext"], atts["hovertext"]);							
								var setColor:String = getFV(atts["color"], this.dataset[this.numDS].color);							
								var setAlpha:String =	getFV(atts["alpha"], this.dataset[this.numDS].alpha);
								var setRatio:String =	getFV(atts["ratio"], this.dataset[this.numDS].ratio);													
								var setShowValue:Number = getFN(atts["showvalue"], this.dataset[this.numDS].showValues);
								var setDashed:Boolean = toBoolean(getFN(atts["dashed"], this.dataset[this.numDS].dashed));
								var setAllowDrag:Boolean = toBoolean(getFN(atts["allowdrag"], this.dataset[this.numDS].allowDrag));
								var setAllowNegativeDrag:Boolean = toBoolean(getFN(atts["allownegativedrag"], this.dataset[this.numDS].allowNegativeDrag));
								//Store all these attributes as object.						
								this.dataset[this.numDS].data[setCount] = this.returnDataAsObject(setId, setValue, setColor, setAlpha, setRatio, setToolText, setLink, setShowValue, setDashed, setAllowDrag, setAllowNegativeDrag);
							} 
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "STYLES") {
						//Styles Node - extract child nodes
						var arrStyleNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the style nodes to extract style information
						super.parseStyleXML(arrStyleNodes);
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "TRENDLINES") {
						//Trend lines node
						var arrTrendNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the trend line nodes
						super.parseTrendLineXML(arrTrendNodes);
					}
				}
			}
		}
		//Delete all temporary objects used for parsing XML Data document
		delete setNode;
		delete arrDocElement;
		delete arrLevel1Nodes;
		delete arrLevel2Nodes;
	}
	/**
	* parseAttributes method parses the attributes and stores them in
	* chart storage objects.
	* Starting ActionScript 2, the parsing of XML attributes have also
	* become case-sensitive. However, prior versions of FusionCharts
	* supported case-insensitive attributes. So we need to parse all
	* attributes as case-insensitive to maintain backward compatibility.
	* To do so, we first extract all attributes from XML, convert it into
	* lower case and then store it in an array. Later, we extract value from
	* this array.
	* @param	graphElement	XML Node containing the <graph> element
	*							and it's attributes
	*/
	private function parseAttributes(graphElement:XMLNode):Void {
		//Array to store the attributes
		var atts:Array = this.getAttributesArray(graphElement);
		//NOW IT'S VERY NECCESARY THAT WHEN WE REFERENCE THIS ARRAY
		//TO GET AN ATTRIBUTE VALUE, WE SHOULD PROVIDE THE ATTRIBUTE
		//NAME IN LOWER CASE. ELSE, UNDEFINED VALUE WOULD SHOW UP.
		//Extract attributes pertinent to this chart
		//Which palette to use?
		this.params.palette = getFN(atts["palette"],1);
		//Whether to show about FusionCharts Menu Item - by default set to on
		this.params.showFCMenuItem = toBoolean(getFN (atts ["showfcmenuitem"] , 1));
		// ---------- PADDING AND SPACING RELATED ATTRIBUTES ----------- //
		//captionPadding = Space between caption/subcaption and canvas start Y
		this.params.captionPadding = getFN(atts["captionpadding"], 10);
		//Padding for x-axis name - to the right
		this.params.xAxisNamePadding = getFN(atts["xaxisnamepadding"], 5);
		//Padding for y-axis name - from top
		this.params.yAxisNamePadding = getFN(atts["yaxisnamepadding"], 5);
		//Y-Axis Values padding - Horizontal space between the axis edge and
		//y-axis values or trend line values (on left/right side).
		this.params.yAxisValuesPadding = getFN(atts["yaxisvaluespadding"], 2);		
		//Label padding - Vertical space between the labels and canvas end position
		this.params.labelPadding = getFN(atts["labelpadding"], atts["labelspadding"], 3);
		//Value padding - vertical space between the end of columns and start of value textboxes
		this.params.valuePadding = getFN(atts["valuepadding"], 2);
		//Percentage space on the plot area
		this.params.plotSpacePercent = getFN(atts["plotspacepercent"], 20);
		///Cannot be less than 0 and more than 80
		if ((this.params.plotSpacePercent<0) || (this.params.plotSpacePercent>80)) {
			//Reset to 20
			this.params.plotSpacePercent = 20;
		}
		//Padding of legend from right/bottom side of canvas
		this.params.legendPadding = getFN(atts["legendpadding"], 6);
		//Chart Margins - Empty space at the 4 sides
		this.params.chartLeftMargin = getFN(atts["chartleftmargin"], 25);
		this.params.chartRightMargin = getFN(atts["chartrightmargin"], 15);
		this.params.chartTopMargin = getFN(atts["charttopmargin"], 15);
		this.params.chartBottomMargin = getFN(atts["chartbottommargin"], 15);
		// -------------------------- HEADERS ------------------------- //
		//Chart Caption and sub Caption
		this.params.caption = getFV(atts["caption"], "");
		this.params.subCaption = getFV(atts["subcaption"], "");
		//X and Y Axis Name
		this.params.xAxisName = getFV(atts["xaxisname"], "");
		this.params.yAxisName = getFV(atts["yaxisname"], "");
		//Adaptive yMin - if set to true, the y min will be based on the values 
		//provided. It won't be set to 0 in case of all positive values
		this.params.setAdaptiveYMin = toBoolean(getFN(atts["setadaptiveymin"], 0));
		// --------------------- CONFIGURATION ------------------------- //
		//The upper and lower limits of y and x axis
		this.params.yAxisMinValue = atts["yaxisminvalue"];
		this.params.yAxisMaxValue = atts["yaxismaxvalue"];
		//Whether to set animation for entire chart.
		this.config.animation = this.params.animation = toBoolean(getFN(atts["animation"], 1));
		//Whether to set the default chart animation
		this.params.defaultAnimation = toBoolean(getFN(atts["defaultanimation"], 1));
		//Configuration to set whether to show the labels   
		this.params.showLabels = toBoolean(getFN(atts["showlabels"], atts["shownames"], 1));
		//Label Display Mode - WRAP, STAGGER, ROTATE or NONE
		this.params.labelDisplay = getFV(atts["labeldisplay"], "WRAP");
		//Remove spaces and capitalize
		this.params.labelDisplay = StringExt.removeSpaces(this.params.labelDisplay);
		this.params.labelDisplay = this.params.labelDisplay.toUpperCase();
		//Option to show vertical x-axis labels
		this.params.rotateLabels = getFV(atts["rotatelabels"], atts["rotatenames"]);		
		//Whether to slant label (if rotated)
		this.params.slantLabels = toBoolean(getFN(atts["slantlabels"], atts["slantlabel"], 0));
		//Angle of rotation based on slanting
		this.config.labelAngle = (this.params.slantLabels == true) ? 315 : 270;
		//If rotateLabels has been explicitly specified, we assign ROTATE value to this.params.labelDisplay
		this.params.labelDisplay = (this.params.rotateLabels == "1") ? "ROTATE" : this.params.labelDisplay;
		//Step value for labels - i.e., show all labels or skip every x label
		this.params.labelStep = int(getFN(atts["labelstep"], 1));
		//Cannot be less than 1
		this.params.labelStep = (this.params.labelStep<1) ? 1 : this.params.labelStep;
		//Number of stagger lines
		this.params.staggerLines = int(getFN(atts["staggerlines"], 2));
		//Cannot be less than 2
		this.params.staggerLines = (this.params.staggerLines<2) ? 2 : this.params.staggerLines;
		//Configuration whether to show data values
		this.params.showValues = toBoolean(getFN(atts["showvalues"], 1));
		//Whether to rotate values
		this.params.rotateValues = toBoolean(getFN(atts["rotatevalues"], 0));
		//Whether to place values inside column
		this.params.placeValuesInside = toBoolean(getFN(atts["placevaluesinside"], 0));
		//Option to show/hide y-axis values
		this.params.showYAxisValues = 1;
		this.params.showLimits = true;
		this.params.showDivLineValues = true;
		//Y-axis value step- i.e., show all y-axis or skip every x(th) value
		this.params.yAxisValuesStep = int(getFN(atts["yaxisvaluesstep"], atts["yaxisvaluestep"], 1));
		//Cannot be less than 1
		this.params.yAxisValuesStep = (this.params.yAxisValuesStep<1) ? 1 : this.params.yAxisValuesStep;
		//Show column shadows
		this.params.showColumnShadow = toBoolean(getFN(atts["showshadow"], atts["showcolumnshadow"], this.defColors.get2DShadow(this.params.palette)));
		//Whether to automatically adjust div lines
		this.params.adjustDiv = toBoolean(getFN(atts["adjustdiv"], 1));
		//Whether to rotate y-axis name
		this.params.rotateYAxisName = toBoolean(getFN(atts["rotateyaxisname"], 1));
		//Max width to be alloted to y-axis name - No defaults, as it's calculated later.
		this.params.yAxisNameWidth = atts["yaxisnamewidth"];
		//Click URL
		this.params.clickURL = getFV(atts["clickurl"],"");
		//Drag options
		this.params.allowAxisChange = toBoolean(getFN(atts["allowaxischange"], 1));
		this.params.changeDivWithAxis = true;
		this.params.dragBorderColor = getFV(atts["dragbordercolor"], this.defColors.get2DBorderColor(this.params.palette));
		this.params.dragBorderThickness = getFN(atts["dragborderthickness"], 1);
		this.params.dragBorderAlpha = getFN(atts["dragborderalpha"], this.defColors.get2DBorderAlpha(this.params.palette));
		this.params.snapToDivOnly = toBoolean(getFN(atts["snaptodivonly"], 0));
		this.params.snapToDiv = toBoolean(getFN(atts["snaptodiv"], !this.params.snapToDivOnly, 1));
		this.params.snapToDivRelaxation = getFN(atts["snaptodivrelaxation"], 10);
		this.params.doNotSnap = toBoolean(getFN(atts["donotsnap"], 0));
		//If no snapping then we set default to all snapping parameters to 0
		if(this.params.doNotSnap) {
			this.params.snapToDivOnly = false;
			this.params.snapToDiv =false;
		}
		//Restore Chart
		this.params.showRestoreBtn = toBoolean(getFN(atts["showrestorebtn"], 1));
		this.params.restoreBtnWidth = getFN(atts["restorebtnwidth"], 80);
		this.params.restoreBtnTitle = getFV(atts["restorebtntitle"], "Restore");
		//Form Actions
		this.params.showFormBtn = toBoolean(getFN(atts["showformbtn"], 1));
		this.params.formBtnWidth = getFN(atts["formbtnwidth"], 80);
		this.params.formBtnTitle = getFV(atts["formbtntitle"], "Submit");
		this.params.formBtnBorderColor = getFV(atts["formbtnbordercolor"], "CBCBCB");
		this.params.formBtnBgColor = getFV(atts["formbtnbgcolor"], "FFFFFF");
		this.params.formAction = getFV(atts["formaction"], "");
		this.params.formTarget = getFV(atts["formtarget"], "_self");
		this.params.formMethod = getFV(atts["formmethod"], "POST");
		this.params.formBtnBgColor = getFV(atts["formbtnbgcolor"], "FFFFFF");
		this.params.btnPadding  = getFN(atts["btnpadding"], 5);
		this.params.btnTextColor = getFV(atts["btntextcolor"], "000000");
		this.params.restoreBtnBorderColor = getFV(atts["restorebtnbordercolor"], this.params.formBtnBorderColor);
		this.params.restoreBtnBgColor = getFV(atts["restorebtnbgcolor"], this.params.formBtnBgColor);
		// ------------------------- COSMETICS -----------------------------//
		//Background properties - Gradient
		this.params.bgColor = getFV(atts["bgcolor"], this.defColors.get2DBgColor(this.params.palette));
		this.params.bgAlpha = getFV(atts["bgalpha"], this.defColors.get2DBgAlpha(this.params.palette));
		this.params.bgRatio = getFV(atts["bgratio"], this.defColors.get2DBgRatio(this.params.palette));
		this.params.bgAngle = getFV(atts["bgangle"], this.defColors.get2DBgAngle(this.params.palette));
		//Border Properties of chart
		this.params.showBorder = toBoolean(getFN(atts["showborder"], 1));
		this.params.borderColor = formatColor(getFV(atts["bordercolor"], this.defColors.get2DBorderColor(this.params.palette)));
		this.params.borderThickness = getFN(atts["borderthickness"], 1);
		this.params.borderAlpha = getFN(atts["borderalpha"], this.defColors.get2DBorderAlpha(this.params.palette));
		//Background swf
		this.params.bgSWF = getFV(atts["bgswf"],"");
		this.params.bgSWFAlpha = getFN(atts["bgswfalpha"],100);
		//Canvas background properties - Gradient
		this.params.canvasBgColor = getFV(atts["canvasbgcolor"], this.defColors.get2DCanvasBgColor(this.params.palette));
		this.params.canvasBgAlpha = getFV(atts["canvasbgalpha"], this.defColors.get2DCanvasBgAlpha(this.params.palette));
		this.params.canvasBgRatio = getFV(atts["canvasbgratio"], this.defColors.get2DCanvasBgRatio(this.params.palette));
		this.params.canvasBgAngle = getFV(atts["canvasbgangle"], this.defColors.get2DCanvasBgAngle(this.params.palette));		
		//Canvas Border properties
		this.params.canvasBorderColor = formatColor(getFV(atts["canvasbordercolor"], this.defColors.get2DCanvasBorderColor(this.params.palette)));
		this.params.canvasBorderThickness = getFN(atts["canvasborderthickness"], 2);
		this.params.canvasBorderAlpha = getFN(atts["canvasborderalpha"], this.defColors.get2DCanvasBorderAlpha(this.params.palette));
		//Plot cosmetic properties
		this.params.showPlotBorder = toBoolean(getFN(atts["showplotborder"], 1));
		this.params.plotBorderColor = formatColor(getFV(atts["plotbordercolor"], this.defColors.get2DPlotBorderColor(this.params.palette)));
		this.params.plotBorderThickness = getFN(atts["plotborderthickness"], 0);
		this.params.plotBorderAlpha = getFN(atts["plotborderalpha"], (this.params.showPlotBorder==true)?95:0);
		//Plot is dashed
		this.params.plotBorderDashed = toBoolean(getFN(atts["plotborderdashed"], 0));
		//Dash Properties
		this.params.plotBorderDashLen = getFN(atts["plotborderdashlen"], 5);
		this.params.plotBorderDashGap = getFN(atts["plotborderdashgap"], 4);
		//Fill properties
		this.params.plotFillAngle = getFN(atts["plotfillangle"], 270);
		this.params.plotFillRatio = getFV(atts["plotfillratio"], "");
		this.params.plotFillAlpha = getFV(atts["plotfillalpha"], "100");
		//Plot gradient color
		if (atts["plotgradientcolor"]==""){
			//If some one doesn't want to specify a plot gradient color
			//i.e., he opts for solid fills
			this.params.plotGradientColor = ""
		}else{
			this.params.plotGradientColor = formatColor(getFV(atts["plotgradientcolor"], this.defColors.get2DPlotGradientColor(this.params.palette)));		
		}
		//Legend properties		
		this.params.showLegend = toBoolean(getFN(atts["showlegend"], 1));
		//Alignment position
		this.params.legendPosition = getFV(atts["legendposition"], "BOTTOM");
		//Legend position can be either RIGHT or BOTTOM -Check for it
		this.params.legendPosition = (this.params.legendPosition.toUpperCase()=="RIGHT")?"RIGHT":"BOTTOM";		
		this.params.legendCaption = getFV(atts ["legendcaption"] , "");
		this.params.legendMarkerCircle = toBoolean(getFN(atts ["legendmarkercircle"] , 0));
		this.params.legendBorderColor = formatColor(getFV(atts["legendbordercolor"], this.defColors.get2DLegendBorderColor(this.params.palette)));
		this.params.legendBorderThickness = getFN(atts["legendborderthickness"], 1);
		this.params.legendBorderAlpha = getFN(atts["legendborderalpha"], 100);
		this.params.legendBgColor = getFV(atts["legendbgcolor"], this.defColors.get2DLegendBgColor(this.params.palette));
		this.params.legendBgAlpha = getFN(atts["legendbgalpha"], 100);
		this.params.legendShadow = toBoolean(getFN(atts["legendshadow"], 1));
		this.params.legendAllowDrag = toBoolean(getFN(atts["legendallowdrag"], 0));
		this.params.legendScrollBgColor = formatColor(getFV(atts["legendscrollbgcolor"], "CCCCCC"));
		this.params.legendScrollBarColor = formatColor(getFV(atts["legendscrollbarcolor"], this.params.legendBorderColor));
		this.params.legendScrollBtnColor = formatColor(getFV(atts["legendscrollbtncolor"], this.params.legendBorderColor));
		//Horizontal grid division Lines - Number, color, thickness & alpha
		//Necessarily need a default value for numDivLines.
		this.params.numDivLines = getFN(atts["numdivlines"],4);
		this.params.initialDivLines = this.params.numDivLines;
		this.params.divLineColor = formatColor(getFV(atts["divlinecolor"], this.defColors.get2DDivLineColor(this.params.palette)));
		this.params.divLineThickness = getFN(atts["divlinethickness"], 1);
		this.params.divLineAlpha = getFN(atts["divlinealpha"], this.defColors.get2DDivLineAlpha(this.params.palette));
		this.params.divLineIsDashed = toBoolean(getFN(atts["divlineisdashed"], 0));
		this.params.divLineDashLen = getFN(atts["divlinedashlen"], 4);
		this.params.divLineDashGap = getFN(atts["divlinedashgap"], 2);
		//Zero Plane properties
		this.params.showZeroPlane = true;
		this.params.zeroPlaneColor = formatColor(getFV(atts["zeroplanecolor"], this.params.divLineColor));
		this.params.zeroPlaneThickness = getFN(atts["zeroplanethickness"], (this.params.divLineThickness==1)?2:this.params.divLineThickness);
		this.params.zeroPlaneAlpha = getFN(atts["zeroplanealpha"], this.params.divLineAlpha*2);
		//Alternating grid colors
		this.params.showAlternateHGridColor = toBoolean(getFN(atts["showalternatehgridcolor"], 1));
		this.params.alternateHGridColor = formatColor(getFV(atts["alternatehgridcolor"], this.defColors.get2DAltHGridColor(this.params.palette)));
		this.params.alternateHGridAlpha = getFN(atts["alternatehgridalpha"], this.defColors.get2DAltHGridAlpha(this.params.palette));
		//Tool Tip - Show/Hide, Background Color, Border Color, Separator Character
		this.params.showToolTip = toBoolean(getFN(atts["showtooltip"], atts["showhovercap"], 1));
		this.params.seriesNameInToolTip = toBoolean(getFN(atts["seriesnameintooltip"], 1));
		this.params.toolTipBgColor = formatColor(getFV(atts["tooltipbgcolor"], atts["hovercapbgcolor"], atts["hovercapbg"], this.defColors.get2DToolTipBgColor(this.params.palette)));
		this.params.toolTipBorderColor = formatColor(getFV(atts["tooltipbordercolor"], atts["hovercapbordercolor"], atts["hovercapborder"], this.defColors.get2DToolTipBorderColor(this.params.palette)));
		this.params.toolTipSepChar = getFV(atts["tooltipsepchar"], atts["hovercapsepchar"], ", ");
		//Font Properties
		this.params.baseFont = getFV(atts["basefont"], "Verdana");
		this.params.baseFontSize = getFN(atts["basefontsize"], 10);
		this.params.baseFontColor = formatColor(getFV(atts["basefontcolor"], this.defColors.get2DBaseFontColor(this.params.palette)));
		this.params.outCnvBaseFont = getFV(atts["outcnvbasefont"], this.params.baseFont);
		this.params.outCnvBaseFontSize = getFN(atts["outcnvbasefontsize"], this.params.baseFontSize);
		this.params.outCnvBaseFontColor = formatColor(getFV(atts["outcnvbasefontcolor"], this.params.baseFontColor));
		// ------------------------- NUMBER FORMATTING ---------------------------- //
		//Option whether the format the number (using Commas)
		this.params.formatNumber = toBoolean(getFN(atts["formatnumber"], 1));
		//Option to format number scale
		this.params.formatNumberScale = toBoolean(getFN(atts["formatnumberscale"], 0));
		//Number Scales
		this.params.defaultNumberScale = getFV(atts["defaultnumberscale"], "");
		this.params.numberScaleUnit = getFV(atts["numberscaleunit"], "K,M");
		this.params.numberScaleValue = getFV(atts["numberscalevalue"], "1000,1000");
		//Number prefix and suffix
		this.params.numberPrefix = getFV(atts["numberprefix"], "");
		this.params.numberSuffix = getFV(atts["numbersuffix"], "");
		//Decimal Separator Character
		this.params.decimalSeparator = getFV(atts["decimalseparator"], ".");
		//Thousand Separator Character
		this.params.thousandSeparator = getFV(atts["thousandseparator"], ",");
		//Input decimal separator and thousand separator. In some european countries,
		//commas are used as decimal separators and dots as thousand separators. In XML,
		//if the user specifies such values, it will give a error while converting to
		//number. So, we accept the input decimal and thousand separator from user, so that
		//we can covert it accordingly into the required format.
		this.params.inDecimalSeparator = getFV(atts["indecimalseparator"], "");
		this.params.inThousandSeparator = getFV(atts["inthousandseparator"], "");
		//Decimal Precision (number of decimal places to be rounded to)
		this.params.decimals = getFV(atts["decimals"], atts["decimalprecision"]);
		//Force Decimal Padding
		this.params.forceDecimals = toBoolean(getFN(atts["forcedecimals"], 0));
		//y-Axis values decimals
		this.params.yAxisValueDecimals = getFV(atts["yaxisvaluedecimals"], atts["yaxisvaluesdecimals"], atts["divlinedecimalprecision"], atts["limitsdecimalprecision"]);
		// ---------------------- Image Saving ------------------------------//
		this.params.imageSave = toBoolean (getFN (atts ["imagesave"] , 0));
		this.params.imageSaveURL = getFV (atts ["imagesaveurl"] , "");
		this.params.imageSaveDialogColor = formatColor (getFV (atts ["imagesavedialogcolor"] , "E2E2E2"));
		this.params.imageSaveDialogFontColor = formatColor (getFV (atts ["imagesavedialogfontcolor"] , "666666"));
	}
	/**
	 * setAnimationFlag method sets the animation to false
	*/
	private function setAnimationFlag():Void {
		this.params.animation = false;
		//Clear Interval     
		clearInterval(this.config.intervals.animationReqd);
	}
	/**
	 * getMaxDataValue method gets the maximum y-axis data value present
	 * in the data.
	 *	@returns	The maximum value present in the data provided.
	*/
	private function getMaxDataValue():Number {
		var maxValue:Number;
		var firstNumberFound:Boolean = false;
		var i:Number, j:Number;
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.num; j++){
				//By default assume the first non-null number to be maximum
				if (firstNumberFound == false) {
					if (this.dataset[i].data[j].isDefined == true) {
						//Set the flag that "We've found first non-null number".
						firstNumberFound = true;
						//Also assume this value to be maximum.
						maxValue = this.dataset[i].data[j].value;
					}
				} else {
					//If the first number has been found and the current data is defined, compare
					if (this.dataset[i].data[j].isDefined) {
						//Store the greater number
						maxValue = (this.dataset[i].data[j].value>maxValue) ? this.dataset[i].data[j].value : maxValue;
					}
				}
			}
		}
		return maxValue;
	}
	/**
	 * getMinDataValue method gets the minimum y-axis data value present
	 * in the data
	 *	@reurns		The minimum value present in data
	*/
	private function getMinDataValue():Number {
		var minValue:Number;
		var firstNumberFound:Boolean = false;
		var i:Number, j:Number;
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.num; j++){
				//By default assume the first non-null number to be minimum
				if (firstNumberFound == false) {
					if (this.dataset[i].data[j].isDefined == true) {
						//Set the flag that "We've found first non-null number".
						firstNumberFound = true;
						//Also assume this value to be minimum.
						minValue = this.dataset[i].data[j].value;
					}
				} else {
					//If the first number has been found and the current data is defined, compare
					if (this.dataset[i].data[j].isDefined) {
						//Store the lesser number					
						minValue = (this.dataset[i].data[j].value<minValue) ? this.dataset[i].data[j].value : minValue;
					}
				}
			}
		}
		return minValue;
	}
	/**
	 * addMaxValue method updates the axis max value by adding a new DivLine value to it.
	*/
	private function addMaxValue():Void{
		this.config.yMax += Math.abs(this.config.divInterval);
	}
	/**
	 * subtractMaxValue method updates the axis max value by subtracting DivLine value to it.
	*/
	private function subtractMaxValue():Void{
		this.config.yMax -= Math.abs(this.config.divInterval);
	}
	/**
	 * addMinValue method updates the axis max value by adding a new DivLine value to it.
	*/
	private function addMinValue():Void{
		this.config.yMin -= Math.abs(this.config.divInterval);
	}
	/**
	 * subtractMinValue method updates the axis max value by subtracting DivLine value to it.
	*/
	private function subtractMinValue():Void{
		this.config.yMin += Math.abs(this.config.divInterval);
	}
	/**
	* calculateAxisLimits method sets the axis limits for the chart.
	* It gets the minimum and maximum value specified in data and
	* based on that it calls super.getAxisLimits();
	*/
	private function calculateAxisLimits():Void {
		this.getAxisLimits(this.getMaxDataValue(), this.getMinDataValue(), true, !this.params.setAdaptiveYMin);
	}
	/**
	* setStyleDefaults method sets the default values for styles or
	* extracts information from the attributes and stores them into
	* style objects.
	*/
	private function setStyleDefaults():Void {
		//Default font object for Caption
		//-----------------------------------------------------------------//
		var captionFont = new StyleObject();
		captionFont.name = "_SdCaptionFont";
		captionFont.align = "center";
		captionFont.valign = "top";
		captionFont.bold = "1";
		captionFont.font = this.params.outCnvBaseFont;
		captionFont.size = this.params.outCnvBaseFontSize;
		captionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.CAPTION, captionFont, this.styleM.TYPE.FONT, null);
		delete captionFont;
		//-----------------------------------------------------------------//
		//Default font object for SubCaption
		//-----------------------------------------------------------------//
		var subCaptionFont = new StyleObject();
		subCaptionFont.name = "_SdSubCaptionFont";
		subCaptionFont.align = "center";
		subCaptionFont.valign = "top";
		subCaptionFont.bold = "1";
		subCaptionFont.font = this.params.outCnvBaseFont;
		subCaptionFont.size = this.params.outCnvBaseFontSize;
		subCaptionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.SUBCAPTION, subCaptionFont, this.styleM.TYPE.FONT, null);
		delete subCaptionFont;
		//-----------------------------------------------------------------//
		//Default font object for YAxisName
		//-----------------------------------------------------------------//
		var yAxisNameFont = new StyleObject();
		yAxisNameFont.name = "_SdYAxisNameFont";
		yAxisNameFont.align = "center";
		yAxisNameFont.valign = "middle";
		yAxisNameFont.bold = "1";
		yAxisNameFont.font = this.params.outCnvBaseFont;
		yAxisNameFont.size = this.params.outCnvBaseFontSize;
		yAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.YAXISNAME, yAxisNameFont, this.styleM.TYPE.FONT, null);
		delete yAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for XAxisName
		//-----------------------------------------------------------------//
		var xAxisNameFont = new StyleObject();
		xAxisNameFont.name = "_SdXAxisNameFont";
		xAxisNameFont.align = "center";
		xAxisNameFont.valign = "middle";
		xAxisNameFont.bold = "1";
		xAxisNameFont.font = this.params.outCnvBaseFont;
		xAxisNameFont.size = this.params.outCnvBaseFontSize;
		xAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.XAXISNAME, xAxisNameFont, this.styleM.TYPE.FONT, null);
		delete xAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for trend lines
		//-----------------------------------------------------------------//
		var trendFont = new StyleObject();
		trendFont.name = "_SdTrendFontFont";
		trendFont.font = this.params.outCnvBaseFont;
		trendFont.size = this.params.outCnvBaseFontSize;
		trendFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TRENDVALUES, trendFont, this.styleM.TYPE.FONT, null);
		delete trendFont;		
		//-----------------------------------------------------------------//
		//Default font object for yAxisValues
		//-----------------------------------------------------------------//
		var yAxisValuesFont = new StyleObject();
		yAxisValuesFont.name = "_SdYAxisValuesFont";
		yAxisValuesFont.align = "right";
		yAxisValuesFont.valign = "middle";
		yAxisValuesFont.font = this.params.outCnvBaseFont;
		yAxisValuesFont.size = this.params.outCnvBaseFontSize;
		yAxisValuesFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.YAXISVALUES, yAxisValuesFont, this.styleM.TYPE.FONT, null);
		delete yAxisValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for DataLabels
		//-----------------------------------------------------------------//
		var dataLabelsFont = new StyleObject();
		dataLabelsFont.name = "_SdDataLabelsFont";
		dataLabelsFont.align = "center";
		dataLabelsFont.valign = "bottom";		
		dataLabelsFont.font = this.params.catFont;
		dataLabelsFont.size = this.params.catFontSize;
		dataLabelsFont.color = this.params.catFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.DATALABELS, dataLabelsFont, this.styleM.TYPE.FONT, null);
		delete dataLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for Legend
		//-----------------------------------------------------------------//
		var legendFont = new StyleObject();
		legendFont.name = "_SdLegendFont";
		legendFont.font = this.params.outCnvBaseFont;
		legendFont.size = this.params.outCnvBaseFontSize;
		legendFont.color = this.params.outCnvBaseFontColor;
		legendFont.ishtml = 1;
		legendFont.leftmargin = 3;
		//Over-ride
		this.styleM.overrideStyle(this.objects.LEGEND, legendFont, this.styleM.TYPE.FONT, null);
		delete legendFont;
		//-----------------------------------------------------------------//
		//Default font object for DataValues
		//-----------------------------------------------------------------//
		var dataValuesFont = new StyleObject();
		dataValuesFont.name = "_SdDataValuesFont";
		dataValuesFont.align = "center";
		dataValuesFont.valign = "middle";
		dataValuesFont.font = this.params.baseFont;
		dataValuesFont.size = this.params.baseFontSize;
		dataValuesFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.DATAVALUES, dataValuesFont, this.styleM.TYPE.FONT, null);
		delete dataValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for ToolTip
		//-----------------------------------------------------------------//
		var toolTipFont = new StyleObject();
		toolTipFont.name = "_SdToolTipFont";
		toolTipFont.font = this.params.baseFont;
		toolTipFont.size = this.params.baseFontSize;
		toolTipFont.color = this.params.baseFontColor;
		toolTipFont.bgcolor = this.params.toolTipBgColor;
		toolTipFont.bordercolor = this.params.toolTipBorderColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TOOLTIP, toolTipFont, this.styleM.TYPE.FONT, null);
		delete toolTipFont;
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for Legend
		//-----------------------------------------------------------------//
		if (this.params.legendShadow){
			var legendShadow = new StyleObject();
			legendShadow.name = "_SdLegendShadow";
			legendShadow.distance = 2;
			legendShadow.alpha =90;
			legendShadow.angle = 45;
			//Over-ride     
			this.styleM.overrideStyle(this.objects.LEGEND, legendShadow, this.styleM.TYPE.SHADOW, null);
			delete legendShadow;
		}
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for DataPlot
		//-----------------------------------------------------------------//
		if (this.params.showColumnShadow) {
			var dataPlotShadow = new StyleObject();
			dataPlotShadow.name = "_SdDataPlotShadow";
			dataPlotShadow.angle = 45;
			//Over-ride     
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			delete dataPlotShadow;
		}
		//-----------------------------------------------------------------//
		//Default Animation object for DataPlot (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation){
			var dataPlotAnim = new StyleObject();
			dataPlotAnim.name = "_SdDataPlotAnim";
			dataPlotAnim.param = "_yscale";
			dataPlotAnim.easing = "regular";
			dataPlotAnim.wait = 0;
			dataPlotAnim.start = 0;
			dataPlotAnim.duration = 1;
			//Over-ride
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotAnim, this.styleM.TYPE.ANIMATION, "_yscale");
			delete dataPlotAnim;
		}
		//-----------------------------------------------------------------//
	}
	/**
	 * calcVLinesPos method calculates the x position for the various
	 * vLines defined. Also, it validates them.
	*/
	private function calcVLinesPos() {
		var i:Number;
		//Iterate through all the vLines
		for (i=1; i<=numVLines; i++) {
			//If the vLine is after 1st data and before last data
			if (this.vLines[i].index>0 && this.vLines[i].index<this.num) {
				//Set it's x position
				this.vLines[i].x = this.categories[this.vLines[i].index].x+(this.categories[this.vLines[i].index+1].x-this.categories[this.vLines[i].index].x)/2;
			} else {
				//Invalidate it
				this.vLines[i].isValid = false;
			}
		}
	}
	/**
	* calculatePoints method calculates the various points on the chart.
	*/
	private function calculatePoints() {
		//Loop variable
		var i:Number, j:Number;
		//Feed empty data - By default there should be equal number of <categories>
		//and <set> element within each dataset. If in case, <set> elements fall short,
		//we need to append empty data at the end.
		for (i=1; i<=this.numDS; i++){
			for (j=1; j<=this.num; j++){
				if (this.dataset[i].data[j] == undefined){
					this.dataset[i].data[j] = this.returnDataAsObject("", NaN);
				}
			}
		}
		//Format all the numbers on the chart and store their display values
		//We format and store here itself, so that later, whenever needed,
		//we just access displayValue instead of formatting once again.
		//Also set tool tip text values
		var toolText:String
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.num; j++){
				//Format and store
				this.dataset[i].data[j].displayValue = formatNumber(this.dataset[i].data[j].value, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
				//Tool tip text.
				//Preferential Order - Set Tool Text (No concatenation) > SeriesName + Cat Name + Value
				if (this.dataset[i].data[j].toolText==undefined || this.dataset[i].data[j].toolText==""){
					//If the tool tip text is not already defined
					//If labels have been defined
					toolText = (this.params.seriesNameInToolTip && this.dataset[i].seriesName!="")?(this.dataset[i].seriesName + this.params.toolTipSepChar):"";
					toolText = toolText + ((this.categories[j].toolText!="")?(this.categories[j].toolText + this.params.toolTipSepChar):"");
					toolText = toolText + this.dataset[i].data[j].displayValue;
					this.dataset[i].data[j].toolText = toolText;
				}				
			}
		}
		//Based on label step, set showLabel of each data point as required.
		//Visible label count
		var visibleCount:Number = 0;
		var finalVisibleCount:Number = 0;
		for (i=1; i<=this.num; i++) {
			//Now, the label can be preset to be hidden (set via XML)
			if (this.categories[i].showLabel) {
				visibleCount++;
				//If label step is defined, we need to set showLabel of those
				//labels which fall on step as false.
				if ((i-1)%this.params.labelStep == 0) {
					this.categories[i].showLabel = true;
				} else {
					this.categories[i].showLabel = false;
				}
			}
			//Update counter     
			finalVisibleCount = (this.categories[i].showLabel) ? (finalVisibleCount+1) : (finalVisibleCount);
		}
		//We now need to calculate the available Width on the canvas.
		//Available width = total Chart width minus the list below
		// - Left and Right Margin
		// - yAxisName (if to be shown)
		// - yAxisValues
		// - Trend line display values (both left side and right side).
		// - Legend (If to be shown at right)
		var canvasWidth:Number = this.width-(this.params.chartLeftMargin+this.params.chartRightMargin);
		//Set canvas startX
		var canvasStartX:Number = this.params.chartLeftMargin;
		//Now, if y-axis name is to be shown, simulate it and get the width
		if (this.params.yAxisName != "") {
			//Get style object
			var yAxisNameStyle:Object = this.styleM.getTextStyle(this.objects.YAXISNAME);
			if (this.params.rotateYAxisName){
				//Set embedded font - as we need to rotate
				yAxisNameStyle.font = _embeddedFont;
				//Un-bold and un-italicize
				yAxisNameStyle.bold = false;
				yAxisNameStyle.italic = false;
				//Create text field to get width
				var yAxisNameObj:Object = createText(true, this.params.yAxisName, this.tfTestMC, 1, testTFX, testTFY, 90, yAxisNameStyle, false, 0, 0);
				//Accomodate width and padding
				canvasStartX = canvasStartX+yAxisNameObj.width+this.params.yAxisNamePadding;
				canvasWidth = canvasWidth-yAxisNameObj.width-this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.yAxisName = returnDataAsElement(0, 0, yAxisNameObj.width, yAxisNameObj.height);				
			}else{
				//If the y-axis name is not to be rotated
				//Calculate the width of the text if in full horizontal mode
				//Create text field to get width
				var yAxisNameObj:Object = createText(true, this.params.yAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, yAxisNameStyle, false, 0, 0);
				//Get a value for this.params.yAxisNameWidth
				this.params.yAxisNameWidth = Number(getFV(this.params.yAxisNameWidth,yAxisNameObj.width));
				//Get the lesser of the width (to avoid un-necessary space)				
				this.params.yAxisNameWidth = Math.min(this.params.yAxisNameWidth,yAxisNameObj.width);
				//Accomodate width and padding
				canvasStartX = canvasStartX+this.params.yAxisNameWidth+this.params.yAxisNamePadding;
				canvasWidth = canvasWidth-this.params.yAxisNameWidth-this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.yAxisName = returnDataAsElement(0, 0, this.params.yAxisNameWidth, yAxisNameObj.height);				
			}
			delete yAxisNameStyle;
			delete yAxisNameObj;
		}
		//Accomodate width for y-axis values. Now, y-axis values conists of two parts     
		//(for backward compatibility) - limits (upper and lower) and div line values.
		//So, we'll have to individually run through both of them.
		var yAxisValMaxWidth:Number = 0;
		var divLineObj:Object;
		var divStyle:Object = this.styleM.getTextStyle(this.objects.YAXISVALUES);
		//Iterate through all the div line values
		for (i=1; i<this.divLines.length; i++) {
			//If div line value is to be shown
			if (this.divLines[i].showValue) {
				//If it's the first or last div Line (limits), and it's to be shown
				if ((i == 1) || (i == this.divLines.length-1)) {
					if (this.params.showLimits) {
						//Get the width of the text
						divLineObj = createText(true, this.divLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width>yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
					}
				} else {
					//It's a div interval - div line
					//So, check if we've to show div line values
					if (this.params.showDivLineValues) {
						//Get the width of the text
						divLineObj = createText(true, this.divLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width>yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
					}
				}
			}
		}
		delete divLineObj;
		//Also iterate through all trend lines whose values are to be shown on
		//left side of the canvas.
		//Get style object
		var trendStyle:Object = this.styleM.getTextStyle(this.objects.TRENDVALUES);
		var trendObj:Object;
		for (i=1; i<=this.numTrendLines; i++) {			
			if(this.trendLines[i].isValid==true && this.trendLines[i].valueOnRight==false){
				//If it's a valid trend line and value is to be shown on left
				//Get the width of the text
				trendObj= createText(true, this.trendLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				yAxisValMaxWidth = (trendObj.width>yAxisValMaxWidth) ? (trendObj.width) : (yAxisValMaxWidth);				
			}
		}
		//Accomodate for y-axis/left-trend line values text width
		if (yAxisValMaxWidth>0) {
			canvasStartX = canvasStartX+yAxisValMaxWidth+this.params.yAxisValuesPadding;
			canvasWidth = canvasWidth-yAxisValMaxWidth-this.params.yAxisValuesPadding;
		}
		var trendRightWidth:Number = 0;
		//Now, also check for trend line values that fall on right
		for (i=1; i<=this.numTrendLines; i++) {			
			if(this.trendLines[i].isValid==true && this.trendLines[i].valueOnRight==true){
				//If it's a valid trend line and value is to be shown on right
				//Get the width of the text
				trendObj= createText(true, this.trendLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				trendRightWidth = (trendObj.width>trendRightWidth) ? (trendObj.width) : (trendRightWidth);				
			}
		}
		delete trendObj;
		//Accomodate trend right text width
		if (trendRightWidth>0){					
			canvasWidth = canvasWidth-trendRightWidth-this.params.yAxisValuesPadding;
		}
		//Round them off finally to avoid distorted pixels
		canvasStartX = int(canvasStartX);
		canvasWidth = int(canvasWidth);
		//We finally have canvas Width and canvas Start X
		//-----------------------------------------------------------------------------------//
		//Now, we need to calculate the available Height on the canvas.
		//Available height = total Chart height minus the list below
		// - Chart Top and Bottom Margins
		// - Space for Caption, Sub Caption and caption padding
		// - Height of data labels
		// - xAxisName
		// - Legend (If to be shown at bottom position)
		//Initialize canvasHeight to total height minus margins
		var canvasHeight:Number = this.height-(this.params.chartTopMargin+this.params.chartBottomMargin);
		//Set canvasStartY
		var canvasStartY:Number = this.params.chartTopMargin;
		//Now, if we've to show caption
		if (this.params.caption != "") {
			//Create text field to get height
			var captionObj:Object = createText(true, this.params.caption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.CAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+captionObj.height;
			canvasHeight = canvasHeight-captionObj.height;
			//Create element for caption - to store width & height
			this.elements.caption = returnDataAsElement(0, 0, captionObj.width, captionObj.height);
			delete captionObj;
		}
		//Now, if we've to show sub-caption     
		if (this.params.subCaption != "") {
			//Create text field to get height
			var subCaptionObj:Object = createText(true, this.params.subCaption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.SUBCAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+subCaptionObj.height;
			canvasHeight = canvasHeight-subCaptionObj.height;
			//Create element for sub caption - to store height
			this.elements.subCaption = returnDataAsElement(0, 0, subCaptionObj.width, subCaptionObj.height);
			delete subCaptionObj;
		}
		//Now, if either caption or sub-caption was shown, we also need to adjust caption padding     
		if (this.params.caption != "" || this.params.subCaption != "") {
			//Account for padding
			canvasStartY = canvasStartY+this.params.captionPadding;
			canvasHeight = canvasHeight-this.params.captionPadding;
		}
		//Now, if data labels are to be shown, we need to account for their heights     
		//Data labels can be rendered in 3 ways:
		//1. Normal - no staggering - no wrapping - no rotation
		//2. Wrapped - no staggering - no rotation
		//3. Staggered - no wrapping - no rotation
		//4. Rotated - no staggering - no wrapping
		//Placeholder to store max height
		this.config.maxLabelHeight = 0;
		this.config.labelAreaHeight = 0;
		var labelObj:Object;
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
		if (this.params.labelDisplay == "ROTATE") {
			//Case 4: If the labels are rotated, we iterate through all the string labels
			//provided to us and get the height and store max.
			for (i=1; i<=this.num; i++) {
				//If the label is to be shown
				if (this.categories[i].showLabel) {
					//Set style bold/italic to false and font to embedded font
					labelStyleObj.font = _embeddedFont;
					labelStyleObj.bold = false;
					labelStyleObj.italic = false;
					//Create text box and get height
					labelObj = createText(true, this.categories[i].label, this.tfTestMC, 1, testTFX, testTFY, this.config.labelAngle, labelStyleObj, false, 0, 0);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else if (this.params.labelDisplay == "WRAP") {
			//Case 2 (WRAP): Create all the labels on the chart. Set width as
			//totalAvailableWidth/finalVisibleCount.
			//Set max height as 50% of available canvas height at this point of time. Find all
			//and select the max one.
			var maxLabelWidth:Number = (canvasWidth/finalVisibleCount);
			var maxLabelHeight:Number = (canvasHeight/2);
			//Store it in config for later usage
			this.config.wrapLabelWidth = maxLabelWidth;
			this.config.wrapLabelHeight = maxLabelHeight;
			for (i=1; i<=this.num; i++) {
				//If the label is to be shown
				if (this.categories[i].showLabel) {
					//Create text box and get height
					labelObj = createText(true, this.categories[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, true, maxLabelWidth, maxLabelHeight);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else {
			//Case 1,3: Normal or Staggered Label
			//We iterate through all the labels, and if any of them has &lt or < (HTML marker)
			//embedded in them, we add them to the array, as for them, we'll need to individually
			//create and see the text height. Also, the first element in the array - we set as
			//ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=....
			//Create array to store labels.
			var strLabels:Array = new Array();
			strLabels.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=/*-+~`");
			//Now, iterate through all the labels and for those visible labels, whcih have < sign,
			//add it to array.
			for (i=1; i<=this.num; i++) {
				//If the label is to be shown
				if (this.categories[i].showLabel) {
					if ((this.categories[i].label.indexOf("&lt;")>-1) || (this.categories[i].label.indexOf("<")>-1)) {
						strLabels.push(this.categories[i].label);
					}
				}
			}
			//Now, we've the array for which we've to check height (for each element).
			for (i=0; i<strLabels.length; i++) {
				//Create text box and get height
				labelObj = createText(true, this.categories[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, false, 0, 0);
				//Store the larger
				this.config.maxLabelHeight = (labelObj.height>this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
			}
			//We now have the max label height. If it's staggered, then store accordingly, else
			//simple mode
			if (this.params.labelDisplay == "STAGGER") {
				//Multiply max label height by stagger lines.
				this.config.labelAreaHeight = this.params.staggerLines*this.config.maxLabelHeight;
			} else {
				this.config.labelAreaHeight = this.config.maxLabelHeight;
			}
		}
		if (this.config.labelAreaHeight>0) {
			//Deduct the calculated label height from canvas height
			canvasHeight = canvasHeight-this.config.labelAreaHeight-this.params.labelPadding;
		}
		//Delete objects   
		delete labelObj;
		delete labelStyleObj;
		//Accomodate space for xAxisName (if to be shown);
		if (this.params.xAxisName != "") {
			//Create text field to get height
			var xAxisNameObj:Object = createText(true, this.params.xAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.XAXISNAME), false, 0, 0);
			//Store the height
			canvasHeight = canvasHeight-xAxisNameObj.height-this.params.xAxisNamePadding;
			//Object to store width and height of xAxisName
			this.elements.xAxisName = returnDataAsElement(0, 0, xAxisNameObj.width, xAxisNameObj.height);
			delete xAxisNameObj;
		}
		//We now check whether the form Button is to be shown
		if (this.params.showFormBtn){
			//Width of the form Button
			var btnWidth:Number = this.params.formBtnWidth;
			//Height of the form Button
			var btnHeight:Number = 20;
			//Now deduct the height from the calculated canvas height
			canvasHeight = canvasHeight-btnHeight-this.params.btnPadding;
			//Set the button position
			this.elements.btn = returnDataAsElement(this.width - this.params.chartRightMargin - btnWidth - this.params.btnPadding, this.height - this.params.chartBottomMargin - btnHeight/2- this.params.btnPadding, btnWidth, btnHeight); 
		}
		//We now check whether the restore Button is to be shown
		if (this.params.showRestoreBtn){
			//Width of the restore Button
			var btnWidth:Number = this.params.restoreBtnWidth;
			//Width of the restore Button
			var btnX:Number = this.elements.btn.x-this.params.btnPadding;
			//Height of the restore Button
			var btnHeight:Number = 20;
			if (!this.params.showFormBtn){
				//Now deduct the height from the calculated canvas height
				canvasHeight = canvasHeight-btnHeight-this.params.btnPadding;
				btnX = this.width - this.params.chartRightMargin - this.params.btnPadding;
			}
			//Set the button position
			this.elements.restoreBtn = returnDataAsElement(btnX, this.height - this.params.chartBottomMargin - btnHeight/2- this.params.btnPadding, btnWidth, btnHeight); 
		}
		//We have canvas start Y and canvas height     
		//We now check whether the legend is to be drawn 
		if (this.params.showLegend){
			//Object to store dimensions
			var lgndDim:Object;
			//Create container movie clip for legend
			this.lgndMC = this.cMC.createEmptyMovieClip("Legend",this.dm.getDepth("LEGEND"));
			//Create instance of legend			
			if (this.params.legendPosition=="BOTTOM"){
				//Maximum Height - 50% of stage
				lgnd = new Legend(lgndMC, this.styleM.getTextStyle(this.objects.LEGEND), this.params.legendPosition, canvasStartX + canvasWidth/2, this.height/2, canvasWidth, (this.height-(this.params.chartTopMargin+this.params.chartBottomMargin))*0.5, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor);
			}
			else {
				//Maximum Width - 40% of stage
				lgnd = new Legend(lgndMC, this.styleM.getTextStyle(this.objects.LEGEND), this.params.legendPosition, this.width/2, canvasStartY + canvasHeight/2, (this.width-(this.params.chartLeftMargin+this.params.chartRightMargin))*0.4, canvasHeight, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor);			
			}
			//Feed data set series Name for legend
			for (i=1; i<=this.numDS; i++){
				if (this.dataset[i].includeInLegend && this.dataset[i].seriesName!=""){
					lgnd.addItem(this.dataset[i].seriesName, this.dataset[i].color);
				}
			}			
			//If user has defined a caption for the legend, set it
			if (this.params.legendCaption!=""){
				lgnd.setCaption(this.params.legendCaption);
			}
			//Whether to use circular marker
			lgnd.useCircleMarker(this.params.legendMarkerCircle);
			if (this.params.legendPosition=="BOTTOM"){
				lgndDim = lgnd.getDimensions();
				//Now deduct the height from the calculated canvas height
				canvasHeight = canvasHeight-lgndDim.height-this.params.legendPadding;
				if(this.params.showFormBtn) {
					//Re-set the legend position
					this.lgnd.resetXY(canvasStartX + canvasWidth/2, this.elements.btn.y - this.params.btnPadding - this.elements.btn.h/2 +this.params.legendPadding -lgndDim.height/2);
				}
				else if(this.params.showRestoreBtn) {
					//Re-set the legend position
					this.lgnd.resetXY(canvasStartX + canvasWidth/2, this.elements.restoreBtn.y - this.params.btnPadding - this.elements.restoreBtn.h/2 +this.params.legendPadding -lgndDim.height/2);
				}
				else {
					//Re-set the legend position
					this.lgnd.resetXY(canvasStartX + canvasWidth/2, this.height - this.params.chartBottomMargin - lgndDim.height/2);
				}
			}
			else{
				//Get dimensions
				lgndDim = lgnd.getDimensions();
				//Now deduct the width from the calculated canvas width
				canvasWidth = canvasWidth-lgndDim.width-this.params.legendPadding;
				//Right position
				this.lgnd.resetXY(this.width - this.params.chartRightMargin - lgndDim.width/2, canvasStartY + canvasHeight/2);
			}
		}
		//Create an element to represent the canvas now.
		this.elements.canvas = returnDataAsElement(canvasStartX, canvasStartY, canvasWidth, canvasHeight);		
		//We now need to calculate the position of columns on the chart.
		//Base Plane position - Base plane is the y-plane from which columns start.
		//If there's a 0 value in between yMin,yMax, base plane represents 0 value.
		//Else, it's yMin
		if (this.config.yMax>=0 && this.config.yMin<0) {
			//Negative number present - so set basePlanePos as 0 value
			this.config.basePlanePos = this.getAxisPosition(0, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		} else {
			//No negative numbers - so set basePlanePos as yMin value
			this.config.basePlanePos = this.getAxisPosition(this.config.yMin, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		}
		//Now, calculate the spacing on canvas and individual column width
		var plotSpace:Number = (this.params.plotSpacePercent/100)*this.elements.canvas.w;
		//Block Width
		var blockWidth:Number = (this.elements.canvas.w-plotSpace)/this.num;
		//Individual column space.
		var columnWidth:Number = blockWidth/this.numDS;
		//Max column width can be 50 - so if exceeded, reset width and space
		//Now, there can be an exception if this.params.plotSpacePercent has
		//been defined
		if (columnWidth>50 && (this.params.plotSpacePercent==20)) {
			columnWidth = 50;
			blockWidth = columnWidth*this.numDS;
			plotSpace = this.elements.canvas.w-(this.num*blockWidth);
		}
		//We finally have total plot space and column width   
		//Store it in config
		this.config.plotSpace = plotSpace;
		this.config.blockWidth = blockWidth;
		this.config.columnWidth = columnWidth;		
		//Get space between two blocks
		var interBlockSpace:Number = plotSpace/(this.num+1);
		//Store in config.
		this.config.interBlockSpace= interBlockSpace;
		var dataEndY:Number;
		//Now, store the positions of the columns
		for (i=1; i<=this.num; i++) {
			//Store position of categories
			this.categories[i].x = this.elements.canvas.x+(interBlockSpace*i)+(columnWidth*this.numDS*(i-0.5));
			for (j=1; j<=this.numDS; j++){
				//X-Position
				this.dataset[j].data[i].x = this.elements.canvas.x+(interBlockSpace*i)+columnWidth*(j-0.5) + (columnWidth*this.numDS*(i-1));
				//Set the y position
				this.dataset[j].data[i].y = this.config.basePlanePos;
				//Height for each column
				dataEndY = this.getAxisPosition(this.dataset[j].data[i].value, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
				//Negate to cancel Flash's reverse Y Co-ordinate system
				this.dataset[j].data[i].h = -(dataEndY-this.config.basePlanePos);
				//Width - Deduct 1 from width to allot some space between two columns
				this.dataset[j].data[i].w = (this.params.showColumnShadow && columnWidth>2)?(columnWidth-1):columnWidth;
				//Store value textbox y position
				this.dataset[j].data[i].valTBY = dataEndY;
			}
		}
	}
	/**
	 * recalculatePoints method recalculates required points for div line updation.
	*/
	private function recalculatePoints():Void{
		if (this.config.yMax>=0 && this.config.yMin<0) {
			//Negative number present - so set basePlanePos as 0 value
			this.config.basePlanePos = this.getAxisPosition(0, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		} else {
			//No negative numbers - so set basePlanePos as yMin value
			this.config.basePlanePos = this.getAxisPosition(this.config.yMin, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		}
		var dataEndY:Number;
		//Now, store the positions of the columns
		for (var i:Number=1; i<=this.num; i++) {
			for (var j:Number=1; j<=this.numDS; j++){
				//Set the y position
				this.dataset[j].data[i].y = this.config.basePlanePos;
				//Height for each column
				dataEndY = this.getAxisPosition(this.dataset[j].data[i].updatedValue, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
				//Negate to cancel Flash's reverse Y Co-ordinate system
				this.dataset[j].data[i].h = -(dataEndY-this.config.basePlanePos);
				//Store value textbox y position
				this.dataset[j].data[i].valTBY = dataEndY;
			}
		}
	}
	/**
	 * allotDepths method allots the depths for various chart objects
	 * to be rendered. We do this before hand, so that we can later just
	 * go on rendering chart objects, without swapping.
	*/
	private function allotDepths():Void{
		//Background
		this.dm.reserveDepths("BACKGROUND",1);
		//Click URL Handler
		this.dm.reserveDepths("CLICKURLHANDLER", 1);		
		//Background SWF
		this.dm.reserveDepths("BGSWF", 1);		
		//Canvas
		this.dm.reserveDepths("CANVAS",1);
		//If horizontal grid is to be shown
		if (this.params.showAlternateHGridColor){
			this.dm.reserveDepths("HGRID", 125);
		}
		//Div Lines and their labels
		this.dm.reserveDepths("DIVLINES", 250);
		//Caption
		this.dm.reserveDepths("CAPTION", 1);
		//Sub-caption
		this.dm.reserveDepths("SUBCAPTION", 1);
		//X-Axis Name
		this.dm.reserveDepths("XAXISNAME", 1);
		//Y-Axis Name
		this.dm.reserveDepths("YAXISNAME", 1);
		//Trend lines below plot (lines and their labels)
		this.dm.reserveDepths("TRENDLINESBELOW", this.numTrendLinesBelow);
		this.dm.reserveDepths("TRENDVALUESBELOW", this.numTrendLinesBelow);
		//Vertical div lines
		this.dm.reserveDepths("VLINES", this.numVLines);
		//Data Labels
		this.dm.reserveDepths("DATALABELS", this.num);
		//Data Columns
		this.dm.reserveDepths("DATAPLOT", this.num*this.numDS);
		//Data Drag Columns
		this.dm.reserveDepths("DRAGCOLPLOT", this.num*this.numDS);
		//Zero Plane
		this.dm.reserveDepths("ZEROPLANE", 2);
		//Trend lines below plot (lines and their labels)
		this.dm.reserveDepths("TRENDLINESABOVE", (this.numTrendLines-this.numTrendLinesBelow));
		this.dm.reserveDepths("TRENDVALUESABOVE", (this.numTrendLines-this.numTrendLinesBelow));
		//Canvas Border
		this.dm.reserveDepths("CANVASBORDER", 1);		
		//Data Values
		this.dm.reserveDepths("DATAVALUES", this.num*this.numDS);
		//Legend
		this.dm.reserveDepths("LEGEND", 1);
		//Form Button
		this.dm.reserveDepths("FORMBUTTON", 1);
		//Form Button
		this.dm.reserveDepths("RESTOREBUTTON", 1);
		//Data Drag Column Border
		this.dm.reserveDepths("DRAGCOLBORDER", 1);
		//Dialog Box
		this.dm.reserveDepths("DIALOGBOX", 1);
		//Resize Handler for draggging columns
		this.dm.reserveDepths("RESIZEHANDLER", 1);
	}	
	//--------------- VISUAL RENDERING METHODS -------------------------//
	/**
	* drawHeaders method renders the following on the chart:
	* CAPTION, SUBCAPTION, XAXISNAME, YAXISNAME
	*/
	private function drawHeaders() {
		//Render caption
		if (this.params.caption != "") {
			var captionStyleObj:Object = this.styleM.getTextStyle(this.objects.CAPTION);
			captionStyleObj.align = "center";
			captionStyleObj.vAlign = "bottom";
			var captionObj:Object = createText(false, this.params.caption, this.cMC, this.dm.getDepth("CAPTION"), this.elements.canvas.x+(this.elements.canvas.w/2), this.params.chartTopMargin, 0, captionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(captionObj.tf, this.objects.CAPTION, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.caption.w/2), 0, this.params.chartTopMargin, 0, 100, null, null, null);
			}
			//Apply filters     
			this.styleM.applyFilters(captionObj.tf, this.objects.CAPTION);
			//Delete
			delete captionObj;
			delete captionStyleObj;
		}
		//Render sub caption     
		if (this.params.subCaption != "") {
			var subCaptionStyleObj:Object = this.styleM.getTextStyle(this.objects.SUBCAPTION);
			subCaptionStyleObj.align = "center";
			subCaptionStyleObj.vAlign = "top";
			var subCaptionObj:Object = createText(false, this.params.subCaption, this.cMC, this.dm.getDepth("SUBCAPTION"), this.elements.canvas.x+(this.elements.canvas.w/2), this.elements.canvas.y-this.params.captionPadding, 0, subCaptionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(subCaptionObj.tf, this.objects.SUBCAPTION, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.subCaption.w/2), 0, this.elements.canvas.y-this.params.captionPadding-this.elements.subCaption.h, 0, 100, null, null, null);
			}
			//Apply filters     
			this.styleM.applyFilters(subCaptionObj.tf, this.objects.SUBCAPTION);
			//Delete
			delete subCaptionObj;
			delete subCaptionStyleObj;
		}
		//Render x-axis name     
		if (this.params.xAxisName != "") {
			var xAxisNameStyleObj:Object = this.styleM.getTextStyle(this.objects.XAXISNAME);
			xAxisNameStyleObj.align = "center";
			xAxisNameStyleObj.vAlign = "bottom";
			var xAxisNameObj:Object = createText(false, this.params.xAxisName, this.cMC, this.dm.getDepth("XAXISNAME"), this.elements.canvas.x+(this.elements.canvas.w/2), this.elements.canvas.toY+this.params.labelPadding+this.config.labelAreaHeight+this.params.xAxisNamePadding, 0, xAxisNameStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(xAxisNameObj.tf, this.objects.XAXISNAME, this.macro, this.elements.canvas.x+(this.elements.canvas.w/2)-(this.elements.subCaption.w/2), 0, this.elements.canvas.toY+this.config.labelAreaHeight+this.params.xAxisNamePadding, 0, 100, null, null, null);
			}
			//Apply filters     
			this.styleM.applyFilters(xAxisNameObj.tf, this.objects.XAXISNAME);
			//Delete
			delete xAxisNameObj;
			delete xAxisNameStyleObj;
		}
		//Render y-axis name     
		if (this.params.yAxisName != "") {
			var yAxisNameStyleObj:Object = this.styleM.getTextStyle(this.objects.YAXISNAME);
			//Set alignment parameters
			yAxisNameStyleObj.align = "left";
			yAxisNameStyleObj.vAlign = "middle";
			//If the name is to be rotated
			if (this.params.rotateYAxisName){
				//Set font as the embedded font
				yAxisNameStyleObj.font = _embeddedFont;
				//Set bold/italic to false.
				yAxisNameStyleObj.bold = false;
				yAxisNameStyleObj.italic = false;
				var yAxisNameObj:Object = createText(false, this.params.yAxisName, this.cMC, this.dm.getDepth("YAXISNAME"), this.params.chartLeftMargin, this.elements.canvas.y+(this.elements.canvas.h/2), 270, yAxisNameStyleObj, false, 0, 0);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.params.chartLeftMargin, 0, this.elements.canvas.y+(this.elements.canvas.h/2)+(this.elements.yAxisName.h/2), 0, 100, null, null, null);
				}
			}else{
				//We show horizontal name
				//Adding 1 to this.params.yAxisNameWidth and then passing to avoid line breaks				
				var yAxisNameObj:Object = createText(false, this.params.yAxisName, this.cMC, this.dm.getDepth("YAXISNAME"), this.params.chartLeftMargin, this.elements.canvas.y+(this.elements.canvas.h/2), 0, yAxisNameStyleObj, true, this.params.yAxisNameWidth + 1, this.elements.canvas.h);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.params.chartLeftMargin, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}
			//Apply filters     
			this.styleM.applyFilters(yAxisNameObj.tf, this.objects.YAXISNAME);
			//Delete
			delete yAxisNameObj;
			delete yAxisNameStyleObj;
		}
		//Clear Interval     
		clearInterval(this.config.intervals.headers);
	}
	/**
	* drawLabels method draws the x-axis labels based on the parameters.
	*/
	private function drawLabels() {
		var labelObj:Object;
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
		var labelYShift:Number;
		var staggerCycle:Number = 0;
		var staggerAddFn:Number = 1;
		var depth:Number = this.dm.getDepth("DATALABELS");
		var i:Number;
		for (i=1; i<=this.num; i++) {
			//If the label is to be shown
			if (this.categories[i].showLabel) {
				if (this.params.labelDisplay == "ROTATE") {
					//Set style bold/italic to false and font to embedded font
					labelStyleObj.font = _embeddedFont;
					labelStyleObj.bold = false;
					labelStyleObj.italic = false;
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Create text box and get height
					labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.categories[i].x, this.elements.canvas.toY+this.params.labelPadding, this.config.labelAngle, labelStyleObj, false, 0, 0);
				} else if (this.params.labelDisplay == "WRAP") {
					//Case 2 (WRAP)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.categories[i].x, this.elements.canvas.toY+this.params.labelPadding, 0, labelStyleObj, true, this.config.wrapLabelWidth, this.config.wrapLabelHeight);
				} else if (this.params.labelDisplay == "STAGGER") {
					//Case 3 (Stagger)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Need to get cyclic position for staggered textboxes
					//Matrix formed is of 2*this.params.staggerLines - 2 rows
					var pos:Number = i%(2*this.params.staggerLines-2);
					//Last element needs to be reset
					pos = (pos == 0) ? (2*this.params.staggerLines-2) : pos;
					//Cyclic iteration
					pos = (pos>this.params.staggerLines) ? (this.params.staggerLines-(pos%this.params.staggerLines)) : pos;
					//Get position to 0 base
					pos--;
					//Shift accordingly
					var labelYShift:Number = this.config.maxLabelHeight*pos;
					labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.categories[i].x, this.elements.canvas.toY+this.params.labelPadding+labelYShift, 0, labelStyleObj, false, 0, 0);
				} else {
					//Render normal label
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.categories[i].x, this.elements.canvas.toY+this.params.labelPadding, 0, labelStyleObj, false, 0, 0);
				}				
				//Apply filter
				this.styleM.applyFilters(labelObj.tf, this.objects.DATALABELS);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(labelObj.tf, this.objects.DATALABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
				}
				//Increase depth
				depth++;
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.labels);
	}
	/**
	 * drawColumns method draws the columns on the chart
	*/
	private function drawColumns() {
		//Variables
		var colMC:MovieClip;
		var colDragMC:MovieClip;
		var colDragBorderMC:MovieClip;
		var dragBorderProp:Object;
		//Class Object
		var colIns:DragColumn2D;
		//Depth at which column is drawn
		var colDepth:Number = this.dm.getDepth("DATAPLOT");
		//Depth at which the draggable area of the column is drawn
		var colDragDepth:Number = this.dm.getDepth("DRAGCOLPLOT");
		//Draggable border depth
		var colDragBorderDepth:Number = this.dm.getDepth("DRAGCOLBORDER");
		var i:Number, j:Number, k:Number;
		//Create temporary array to store the div lines
		var divArr:Array = new Array();
		//Create function storage containers for Delegate functions
		var fnRollOver:Function, fnClick:Function;
		//Delegate the column Listener onResizeEnd Function
		colListener.onResizeEnd = Delegate.create(this, onResizeEnd);
		//Delegate the resize Handler Listener for onResizeHRollOver and onResizeHRollOut Functions
		resizeROverListener.onResizeHRollOver = Delegate.create(this, onResizeHRollOver);
		resizeROutListener.onResizeHRollOut = Delegate.create(this, onResizeHRollOut);
		//Create moive clip for the drag border
		colDragBorderMC = this.cMC.createEmptyMovieClip("ColumnDragBorder", colDragBorderDepth);
		//Before creating any instance of the dragColumn2D, we store the divline values 
		//in a static array of the class - needed for snap to div property
		for(k=0;k<this.divLines.length;k++) {
			//Store the div line position in an array ( sorted )
			var divAxisPos:Number = this.getAxisPosition(this.divLines[k].value, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
			//Store it in first position of the array
			divArr.unshift(divAxisPos);
		}
		//Call the static function of the dragColumn2d to store the divLine values
		DragColumn2D.storeDivLineVal(divArr);
		//Iterate through all columns		
		for (i=1; i<=this.numDS; i++){
			for (j=1; j<=this.num; j++){				
				//If defined
				if (this.dataset[i].data[j].isDefined){
					//Create an empty movie clip for this column
					colMC = this.cMC.createEmptyMovieClip("Column_"+i+"_"+j, colDepth);
					//Create an empty movie clip for draggable area of the above column
					colDragMC = this.cMC.createEmptyMovieClip("ColumnDrag_"+i+"_"+j, colDragDepth);
					//Create column instance
					colIns = new DragColumn2D(colMC, colDragMC, colDragBorderMC, this.dataset[i].data[j].w, this.dataset[i].data[j].h, this.params.plotBorderColor, this.params.plotBorderAlpha, this.params.plotBorderThickness, this.dataset[i].data[j].color, this.dataset[i].data[j].alpha, this.dataset[i].data[j].ratio, this.params.plotFillAngle, false, this.dataset[i].data[j].dashed, this.params.plotBorderDashLen, this.params.plotBorderDashGap);
					//Store it in dataset object for Context Menu Snap Property
					this.dataset[i].data[j].colIns = colIns;
					//Draw the column
					colIns.draw();
					//Register a listener to update the display value
					colIns.addEventListener("onResizeEnd", colListener);
					//Add to stack
					this.addToListenerStk(colIns, "onResizeEnd", colListener);
					//Register a listener to show the resize handler
					colIns.addEventListener("onResizeHRollOver", resizeROverListener);
					//Add to stack
					this.addToListenerStk(colIns, "onResizeHRollOver", resizeROverListener);
					//Register a listener to hide the resize handler
					colIns.addEventListener("onResizeHRollOut", resizeROutListener);
					//Add to stack
					this.addToListenerStk(colIns, "onResizeHRollOut", resizeROutListener);
					//Store the drag border properties
					dragBorderProp = new Object();
					dragBorderProp.borderColor = this.dataset[i].dragBorderColor;
					dragBorderProp.borderThickness = this.dataset[i].dragBorderThickness;
					dragBorderProp.borderAlpha = this.dataset[i].dragBorderAlpha;
					dragBorderProp.isNegativeDraggable = this.dataset[i].data[j].isNegativeDraggable;
					dragBorderProp.basePlanePos = this.config.basePlanePos;
					dragBorderProp.index = j;
					dragBorderProp.dsindex = i;
					//Apply dragging options
					if(this.dataset[i].data[j].isDraggable) {
						//Create the draggable area of the column
						colIns.drawDragRectangle(this.dataset[i].data[j].x, this.elements.canvas.y, this.elements.canvas.toY, dragBorderProp, this.config.animation);
						//Set the x and y position of the draggable area
						colDragMC._x = this.dataset[i].data[j].x;
						colDragMC._y = this.dataset[i].data[j].y-this.dataset[i].data[j].h;
					}
					//Set x and y position
					colMC._x = this.dataset[i].data[j].x;
					colMC._y = this.dataset[i].data[j].y;
					//Set the alpha of entire column as the first alpha in list of alpha
					colMC._alpha = this.dataset[i].data[j].alpha[0];
					//Apply animation
					if (this.params.animation && this.config.animationOver==false ) {
						this.styleM.applyAnimation(colMC, this.objects.DATAPLOT, this.macro, this.dataset[i].data[j].x, 0, this.dataset[i].data[j].y, 0, 100, 100, 100, null);
					}
					//Apply filters     
					this.styleM.applyFilters(colMC, this.objects.DATAPLOT);				
					//Event handlers for tool tip
					if (this.params.showToolTip){
						//Create Delegate for roll over function columnOnRollOver
						fnRollOver = Delegate.create(this, columnOnRollOver);
						//Set the index
						fnRollOver.dsindex = i;
						fnRollOver.index = j;
						//Assing the delegates to movie clip handler
						colMC.onRollOver = fnRollOver;
						//Set roll out and mouse move too.
						colMC.onRollOut = colMC.onReleaseOutside = Delegate.create(this, columnOnRollOut);
						colMC.onMouseMove = Delegate.create(this, columnOnMouseMove);
					}
					//Click handler for links - only if link for this column has been defined and click URL
					//has not been defined.
					if (this.dataset[i].data[j].link!="" && this.dataset[i].data[j].link!=undefined && this.params.clickURL==""){
						//Create delegate function
						fnClick = Delegate.create(this, columnOnClick);
						//Set index
						fnClick.dsindex = i;
						fnClick.index = j;
						//Assign
						colMC.onRelease = fnClick;
					}
					else{
						//Do not use hand cursor
						colMC.useHandCursor = (this.params.clickURL=="")?false:true;
					}				
					//Increase depth
					colDepth++;
					colDragDepth++;
				}
			}
		}
		//Set the initial Snapping option
		this.setSnapToDivProp(this.params.snapToDiv, this.params.snapToDivOnly, this.params.doNotSnap, this.params.snapToDivRelaxation);
		//Set animation over
		this.config.animationOver = true;
		//Clear interval
		clearInterval(this.config.intervals.plot);
	}
	/**
	 * drawDialogBox method draws the dialog box and show only when the error generates
	*/
	private function drawDialogBox() {
		//Show the error dialog box
		//We define all the font properties and pass it as parameter to the dialog box class
		var fontProps:Object = new Object();
		fontProps.font = "Verdana";
		fontProps.fontColor= "000000";
		fontProps.fontSize = 10;
		//Create the dialog box
		this.db = new FCErrorDialogBox(this.cMC, this.dm.getDepth("DIALOGBOX"), 0, 0, this.width, this.height, 0);
		//Set the dialog box parameters
		this.db.setParams(110, 250, 20, "E9E9E9", "CCCCCC", 2, fontProps, true);
		//draw the dialog box
		this.db.draw();
		//Hide it initially - show when the error is generated
		this.db.hide();
	}
	/**
	 * drawFormBtn method draw a button and register event for XML generation
	*/
	private function drawFormBtn():Void{
		//Get the depth of the form button
		var depth:Number = this.dm.getDepth("FORMBUTTON");
		//Create a listener for the button
		var btnListener:Object = new Object();
		// Instantiate the form button object
		var btnForm:FCButton = new FCButton(this.cMC, depth);
		//Store the class reference
		var classRef:Object = this;
		var loadVar:LoadVars;
		//Register the listener
		btnListener.click = function(){
			loadVar = new LoadVars();
			//loadVar.strXML = escape(classRef.returnXML());
			loadVar.strXML = classRef.returnXML();
			loadVar.send(classRef.params.formAction, classRef.params.formTarget, classRef.params.formMethod);
		}
		//Set the parameters of the required button
		btnForm.setParams(this.params.formBtnTitle, this.elements.btn.x, this.elements.btn.y, this.elements.btn.h, this.elements.btn.w, 5, this.params.formBtnBgColor, this.params.formBtnBorderColor, "Verdana", this.params.btnTextColor, 10);
		//Draw the button
		btnForm.draw();
		//Show the button
		btnForm.show();
		//Register the event with the button
		btnForm.addEventListener("click", btnListener);
		//Add to stack
		this.addToListenerStk(btnForm, "click", btnListener);
		//Clear interval
		clearInterval(this.config.intervals.formBtn);
	}
	/**
	 * drawRestoreBtn method draw a restore button
	*/
	private function drawRestoreBtn():Void{
		//Get the depth of the form button
		var depth:Number = this.dm.getDepth("RESTOREBUTTON");
		//Create a listener for the button
		var rstrbtnListener:Object = new Object();
		// Instantiate the form button object
		var btnRestore:FCButton = new FCButton(this.cMC, depth);
		//Store the class reference
		var classRef:Object = this;
		var loadVar:LoadVars;
		//Register the listener
		rstrbtnListener.click = function(){
			//Remove all the objects
			classRef.remove();
			//Reinitialize the chart
			classRef.reInit();
			//Re-Render the chart
			classRef.render(true);
		}
		//Set the parameters of the required button
		btnRestore.setParams(this.params.restoreBtnTitle, this.elements.restoreBtn.x-this.elements.restoreBtn.w, this.elements.restoreBtn.y, this.elements.restoreBtn.h, this.elements.restoreBtn.w, 5, this.params.restoreBtnBgColor, this.params.restoreBtnBorderColor, "Verdana", this.params.btnTextColor, 10);
		//Draw the button
		btnRestore.draw();
		//Show the button
		btnRestore.show();
		//Register the event with the button
		btnRestore.addEventListener("click", rstrbtnListener);
		//Add to stack
		this.addToListenerStk(btnRestore, "click", rstrbtnListener);
		//Clear interval
		clearInterval(this.config.intervals.restoreBtn);
	}
	/**
	 * redrawChart method redraw the chart when the axis has been modified
	*/
	private function redrawChart():Void{
		//Hide the tool tip
		this.tTip.hide();
		//Remove any textFields, movieClip or Object rendered before
		this.removeObject();
		//Calculate exact number of div lines
		this.calcDivs();			
		//Recalculate points like basePlanePos and dataset points
		this.recalculatePoints();
		//Calculate trend line positions
		this.calcTrendLinePos();			
		//Draw canvas
		this.drawCanvas();
		//Draw div lines
		this.drawDivLines();
		//Draw the HGrid again
		this.drawHGrid();
		//Draw columns
		this.drawColumns();
		//Data Values
		this.drawValues(false, 1, this.numDS, 1, this.num);
		//Draw trend lines
		this.drawTrendLines();
	}
	/**
	 * drawValues method draws the values on the chart.
	*/
	private function drawValues(isFirstTime:Boolean, startDsIndex:Number, endDsIndex:Number, startIndex:Number, endIndex:Number):Void{
		//Get the values from the arguments
		startDsIndex = getFV(arguments.caller.startDsIndex, startDsIndex);
		endDsIndex = getFV(arguments.caller.endDsIndex, endDsIndex);
		startIndex = getFV(arguments.caller.startIndex, startIndex);
		endIndex = getFV(arguments.caller.endIndex, endIndex);
		//Get value text style
		var valueStyleObj:Object = this.styleM.getTextStyle(this.objects.DATAVALUES);
		//Individual properties
		var isBold:Boolean = valueStyleObj.bold;
		var isItalic:Boolean = valueStyleObj.italic;
		var font:String = valueStyleObj.font;
		var angle:Number = 0;
		//Container object
		var valueObj:MovieClip;
		//Depth
		var depth:Number = this.dm.getDepth("DATAVALUES");
		//Increment the depth value - so that we can modify the value based on the previous depth
		depth += ((startDsIndex-1)*this.num) + (startIndex-1);
		//Loop var
		var i:Number, j:Number;
		var yPos:Number;
		var align:String, vAlign:String;
		////Iterate through all columns
		for (i=startDsIndex; i<=endDsIndex; i++){
			if(!isFirstTime) {
				this.config.valTf[i] = new Array();
			}
			for (j=startIndex; j<=endIndex; j++){
				//If defined and value is to be shown
				if (this.dataset[i].data[j].isDefined && this.dataset[i].data[j].showValue){
					//Get the y position based on placeValuesInside and column height
					if (this.params.placeValuesInside){					
						//Vertical alignment position of the value box
						vAlign = (this.dataset[i].data[j].h>=0)?"bottom":"top";
						yPos = (this.dataset[i].data[j].h>=0)?(this.dataset[i].data[j].valTBY + this.params.valuePadding):(this.dataset[i].data[j].valTBY - this.params.valuePadding);
					}else{
						vAlign = (this.dataset[i].data[j].h>=0)?"top":"bottom";
						yPos = (this.dataset[i].data[j].h>=0)?(this.dataset[i].data[j].valTBY - this.params.valuePadding):(this.dataset[i].data[j].valTBY + this.params.valuePadding);
					}
					//Align position
					align = "center";
					//Convey alignment to rendering object
					valueStyleObj.align = align;
					valueStyleObj.vAlign = vAlign;
					//Now, if the labels are to be rotated
					if (this.params.rotateValues){
						valueStyleObj.bold = false;
						valueStyleObj.italic = false;
						valueStyleObj.font = _embeddedFont;
						angle = 270;
					}else{
						//Normal horizontal label - Store original properties
						valueStyleObj.bold = isBold;
						valueStyleObj.italic = isItalic;
						valueStyleObj.font = font;
						angle = 0;
					}
					valueObj = createText(false, this.dataset[i].data[j].displayValue, this.cMC, depth, this.dataset[i].data[j].x,yPos, angle, valueStyleObj, false, 0, 0);
					if(!isFirstTime) {
						//Store the reference - so that we can modify the content after dragging
						this.config.valTf[i][j] = valueObj.tf;
					}
					//Now, we need to adjust those labels which are falling out of height.
					if (this.params.placeValuesInside && ((this.params.valuePadding+valueObj.height)>=Math.abs(this.dataset[i].data[j].h))){
						//If the values are to be placed inside columns, but the height of the column
						//is less than the height of textbox (+ padding), we show the textbox above/below column
						//For non-rotated values
						if (!this.params.rotateValues){
							//For positive column					
							if (this.dataset[i].data[j].h>=0){
								//Show above
								valueObj.tf._y = this.dataset[i].data[j].y - this.dataset[i].data[j].h - valueObj.height - this.params.valuePadding;
							}else{
								//Negative Column - show below
								valueObj.tf._y = this.dataset[i].data[j].y + Math.abs(this.dataset[i].data[j].h)+ this.params.valuePadding;
							}
						}
						else{
							//For positive column					
							if (this.dataset[i].data[j].h>=0){
								//Show above
								valueObj.tf._y = this.dataset[i].data[j].y - this.dataset[i].data[j].h - this.params.valuePadding;
							}else{
								//Negative Column - show below
								valueObj.tf._y = this.dataset[i].data[j].y + Math.abs(this.dataset[i].data[j].h)+ valueObj.height + this.params.valuePadding;
							}
						}
					}
					//Next, we adjust those labels are falling out of top canvas area
					//For Positive columns only
					if ((!this.params.placeValuesInside) && (this.dataset[i].data[j].h>=0) && ((yPos - valueObj.height)<=this.elements.canvas.y)){
						//Data value is colliding with the upper side of canvas. So we need to place it within
						//the column
						if (!this.params.rotateValues){
							valueObj.tf._y = yPos + (2*this.params.valuePadding);
						}else{
							valueObj.tf._y = yPos + (2*this.params.valuePadding)+ valueObj.height;
						}
					}
					//Now, we adjust those labels are falling out of bottom canvas area
					//For Negative Columns Only
					if ((!this.params.placeValuesInside) && (this.dataset[i].data[j].h<0) && ((yPos + valueObj.height)>=this.elements.canvas.toY)){
						//Data value is colliding with the lower side of canvas. So we need to place it within
						//the column
						if (!this.params.rotateValues){
							valueObj.tf._y = yPos - (2*this.params.valuePadding)- valueObj.height;;
						}else{
							valueObj.tf._y = yPos - (2*this.params.valuePadding);
						}
					}
					//Apply filter
					this.styleM.applyFilters(valueObj.tf, this.objects.DATAVALUES);
					//Apply animation
					if (this.params.animation) {
						this.styleM.applyAnimation(valueObj.tf, this.objects.DATAVALUES, this.macro, valueObj.tf._x, 0, valueObj.tf._y, 0, 100, null, null, null);
					}
				}
				//Increase depth
				depth++;
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.dataValues);
	}
	/**
	 * drawLegend method renders the legend
	*/
	private function drawLegend():Void{
		if (this.params.showLegend){
			this.lgnd.render();
			//Apply filter
			this.styleM.applyFilters(lgndMC, this.objects.LEGEND);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(lgndMC, this.objects.LEGEND, this.macro, null, 0, null, 0, 100, null, null, null);
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.legend);
	}
	/**
	 * setContextMenu method sets the context menu for the chart.
	 * For this chart, the context items are "Print Chart".
	*/
	private function setContextMenu():Void{
		//delegated Functions to add or delete from UL or LL
		var fnOnAddUpperLimit:Function, fnOnSubUpperLimit:Function;
		var fnOnAddLowerLimit:Function, fnOnSubLowerLimit:Function;
		var fnOnSnap:Function, fnOnSnapOnly:Function, fnOnNoSnap:Function;
		//Context Menu Object
		var chartMenu:ContextMenu = new ContextMenu();
		chartMenu.hideBuiltInItems();
		if(this.params.allowAxisChange) {
			//Create a UpperLimit ++ contenxt menu item
			fnOnAddUpperLimit= Delegate.create(this,delegatedULAxis);
			fnOnAddUpperLimit.addToUpperLimit = 1;
			var uprLmtAddCMI:ContextMenuItem = new ContextMenuItem("Increase Upper Limit", fnOnAddUpperLimit);
			//Push uprLmtAdd item.
			chartMenu.customItems.push(uprLmtAddCMI);		
			//Create a UpperLimit -- contenxt menu item
			fnOnSubUpperLimit= Delegate.create(this,delegatedULAxis);
			fnOnSubUpperLimit.addToUpperLimit = 2;
			var uprLmtDelCMI:ContextMenuItem = new ContextMenuItem("Decrease Upper Limit",fnOnSubUpperLimit);
			//Push uprLmtDel item.
			chartMenu.customItems.push(uprLmtDelCMI);		
			//Create a LowerLimit -- contenxt menu item
			fnOnSubLowerLimit= Delegate.create(this,delegatedLLAxis);
			fnOnSubLowerLimit.addToLowerLimit = 2;
			var lwrLmtAddCMI:ContextMenuItem = new ContextMenuItem("Increase Lower Limit",fnOnSubLowerLimit, true);
			//Push lwrLmtAdd item.
			chartMenu.customItems.push(lwrLmtAddCMI);		
			//Create a LowerLimit ++ contenxt menu item
			fnOnAddLowerLimit = Delegate.create(this,delegatedLLAxis);
			fnOnAddLowerLimit.addToLowerLimit = 1;
			var lwrLmtDelCMI:ContextMenuItem = new ContextMenuItem("Decrease Lower Limit",fnOnAddLowerLimit);
			//Push uprLmtDel item.
			chartMenu.customItems.push(lwrLmtDelCMI);		
		}
		//For snap based on relaxation
		fnOnSnap = Delegate.create(this, setSnapToDivProp);
		fnOnSnap.snap = true;
		fnOnSnap.snapOnly = false;
		fnOnSnap.noSnap = false;
		fnOnSnap.snapRelaxation = this.params.snapToDivRelaxation;
		//Create a snapTo Div menu items
		var snapCMI:ContextMenuItem = new ContextMenuItem("Snap To Div",  fnOnSnap, true);
		//Store in config option for enable and disable
		this.config.snapCMI = snapCMI;
		//Push snapToDiv.
		chartMenu.customItems.push(snapCMI);		
		//For snapOnly
		fnOnSnapOnly = Delegate.create(this, setSnapToDivProp);
		fnOnSnapOnly.snap = false;
		fnOnSnapOnly.snapOnly = true;
		fnOnSnapOnly.noSnap = false;
		fnOnSnapOnly.snapRelaxation = this.params.snapToDivRelaxation;
		var snapOnlyCMI:ContextMenuItem = new ContextMenuItem("Snap To Div Only", fnOnSnapOnly);
		//Store in config option for enable and disable
		this.config.snapOnlyCMI = snapOnlyCMI;
		//Push snapToDivOnly option.
		chartMenu.customItems.push(snapOnlyCMI);		
		//For No snap
		fnOnNoSnap = Delegate.create(this, setSnapToDivProp);
		fnOnNoSnap.snap = false;
		fnOnNoSnap.snapOnly = false;
		fnOnNoSnap.noSnap = true;
		fnOnNoSnap.snapRelaxation = this.params.snapToDivRelaxation;
		var noSnapCMI:ContextMenuItem = new ContextMenuItem("Do not Snap", fnOnNoSnap);
		//Store in config option for enable and disable
		this.config.noSnapCMI = noSnapCMI;
		//Push do not snap option.
		chartMenu.customItems.push(noSnapCMI);		
		//Create a print chart contenxt menu item
		var printCMI:ContextMenuItem = new ContextMenuItem("Print Chart",Delegate.create(this,printChart), true);
		//Push print item.
		chartMenu.customItems.push(printCMI);		
		if (this.params.imageSave){
			//Add the export to image option
			chartMenu.customItems.push(super.returnImageSaveMenuItem());		
		}
		if (this.params.showFCMenuItem){
			//Push "About FusionCharts" Menu Item
			chartMenu.customItems.push(super.returnAbtMenuItem());		
		}
		//Assign the menu to cMC movie clip
		this.cMC.menu = chartMenu;		
	}
	/**
	 * returnArray method returns the updated Data in an Array format
	*/
	public function returnArray():Array{
		//This function returns an Array representation of the modified data
		//*** ARRAY OF DATA ***//
		//create the required array
		var arrData:Array = new Array();
		//Initialize the arrData
		for (var i:Number=0; i<=this.num; i++) {
			arrData[i] = new Array();
		}
		arrData[0][0] ="";
		//Now, generate the categories elements
		for (i=1; i<=this.numDS; i++) {
			arrData[0][i] = this.dataset[i].seriesName;
			for (var j:Number=1; j<=this.num; j++) {
				arrData[j][0] = this.categories[j].label;
				if(this.dataset[i].data[j].isDefined) {
					arrData[j][i] = this.dataset[i].data[j].updatedValue;
				} else {
					arrData[j][i] = null;
				}
			}
		}
		return (arrData);
	}
	/**
	 * returnArrayWithID method returns the updated Data in an Array format with ID
	*/
	public function returnArrayWithID():Array{
		//This function returns an Array representation of the modified data
		//*** ARRAY OF DATA ***//
		//create the required array
		var arrData:Array = new Array();
		//Initialize the arrData
		for (var i:Number=0; i<=this.num; i++) {
			arrData[i] = new Array();
		}
		arrData[0][0] ="";
		//Now, generate the categories elements
		for (i=1; i<=this.numDS; i++) {
			arrData[0][i] = this.dataset[i].seriesName;
			for (var j:Number=1; j<=this.num; j++) {
				arrData[j][0] = this.categories[j].label;
				if(this.dataset[i].data[j].isDefined) {
					arrData[j][i] = new Array();
					arrData[j][i][1] = this.dataset[i].data[j].updatedValue;
					arrData[j][i][0] = this.dataset[i].data[j].id;
				} else {
					arrData[j][i][0] = null;
					arrData[j][i][1] = this.dataset[i].data[j].id;
				}
			}
		}
		return (arrData);
	}
	/**
	 * returnXML method returns the updated XML file
	*/
	public function returnXML():String{
		//This function returns the XML representation of the modified data
		//*** XML Generator ***//
		//Generate the <chart> element attributes
		var strXML:String = "<chart>";
		//Now, generate the categories elements
		strXML = strXML+"<categories>";
		for (var i:Number=1; i<=this.num; i++) {
			strXML = strXML+"<category label='"+this.categories[i].label+"' />";
		}
		//End the categories tag - <categories>
		strXML = strXML+"</categories>";
		//--Now generate the Datasets
		for (i=1; i<=this.numDS; i++) {
			//Attach the attributes
			strXML = strXML+"<dataset id='"+this.dataset[i].id+"' seriesName='"+this.dataset[i].seriesName+"' >";
			//Data set generated
			//Now generate the data tags
			for (var j:Number=1; j<=this.num; j++) {
				strXML = strXML+"<set id='"+this.dataset[i].data[j].id+"' value='";
				if(this.dataset[i].data[j].isDefined) {
					strXML += this.dataset[i].data[j].updatedValue+"'/>";
				} else {
					strXML += "'/>";
				}
			}
			//End data set
			strXML = strXML+"</dataset>";
		}
		//End the chart tag
		strXML = strXML+"</chart>";
		return (strXML.toString());
	}
	// -------------------- EVENT HANDLERS --------------------//
	/**
	 * setSnapToDivProp is the delegat-ed event handler method that'll
	 * be invoked when the user Click any of the snapping enabled menu item.
	 * @param	snapToDivFlag		boolean value to indicate snapDiv set or unset.
	 * @param	snapToDivOnlyFlag	boolean value to indicate snapOnly set or unset.
	 * @param	doNotSnapFlag		unset the snapping opiton.
	 * @param	relaxation			value to indicate snapping based on relaxation value
	*/
	private function setSnapToDivProp(snapToDivFlag:Boolean, snapToDivOnlyFlag:Boolean, doNotSnapFlag:Boolean, relaxation:Number):Void {
		//snap properties are stored as an arguments
		this.params.snapToDiv = snapToDivFlag = getFV(arguments.caller.snap, snapToDivFlag);
		this.params.snapToDivOnly = snapToDivOnlyFlag = getFV(arguments.caller.snapOnly, snapToDivOnlyFlag);
		this.params.doNotSnap = doNotSnapFlag = getFV(arguments.caller.noSnap, doNotSnapFlag);
		relaxation = getFN(arguments.caller.snapRelaxation, relaxation);
		//Set the menu item based on the parameters chosen
		if(snapToDivOnlyFlag) {
			this.config.snapCMI.enabled = true;
			this.config.snapOnlyCMI.enabled = false;
			this.config.noSnapCMI.enabled = true;
		}
		else if(snapToDivFlag) {
			this.config.snapCMI.enabled = false;
			this.config.snapOnlyCMI.enabled = true;
			this.config.noSnapCMI.enabled = true;
		}
		else if(doNotSnapFlag){
			this.config.snapCMI.enabled = true;
			this.config.snapOnlyCMI.enabled = true;
			this.config.noSnapCMI.enabled = false;
		}
		//For each instantiated Object - we set the snap to Div property
		for (var i:Number=1; i<=this.numDS; i++){
			for (var j:Number=1; j<=this.num; j++){
				//Call the function to set the snap property
				this.dataset[i].data[j].colIns.setSnapToDivProp(snapToDivFlag, snapToDivOnlyFlag, doNotSnapFlag, relaxation);
			}
		}
		
	}
	/**
	 * onResizeEnd is the delegat-ed event handler method that'll
	 * be invoked when the user finish dragging a particular column. 
	 * This function is invoked, only if the column dragging is ON.
	 * Here, we set all the objects like values, tool tip and height according 
	 * to new values of the column.
	 * @param	evtObj		Event's object for each dragged column.
	*/
	private function onResizeEnd(evtObj):Void {
		//------------VALUE AND DISPLAY VALUE UPDATE------------------
		//update the column with new value and display value
		this.dataset[evtObj.dsindex].data[evtObj.index].updatedValue = this.getValue(Number(evtObj.colHeight), this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		//To avoid exponential numbers while generating the new XML file
		this.dataset[evtObj.dsindex].data[evtObj.index].updatedValue = (Math.abs(this.dataset[evtObj.dsindex].data[evtObj.index].updatedValue)*Math.pow(10,5) <1)?(0):(this.dataset[evtObj.dsindex].data[evtObj.index].updatedValue);
		this.dataset[evtObj.dsindex].data[evtObj.index].displayValue = formatNumber(this.dataset[evtObj.dsindex].data[evtObj.index].updatedValue, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
		//------------SET NEW POSITION------------------
		//Calculate the new Height for the dragged column
		var dataEndY = this.getAxisPosition(this.dataset[evtObj.dsindex].data[evtObj.index].updatedValue, this.config.yMax, this.config.yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		//Negate to cancel Flash's reverse Y Co-ordinate system
		this.dataset[evtObj.dsindex].data[evtObj.index].h = -(dataEndY-this.config.basePlanePos);
		//------------TOOL TIP UPDATE------------------
		//Re create the Tool tip text.
		//Preferential Order - Set Tool Text (No concatenation) > SeriesName + Cat Name + Value
		//If labels have been defined
		var toolText:String = (this.params.seriesNameInToolTip && this.dataset[evtObj.dsindex].seriesName!="")?(this.dataset[evtObj.dsindex].seriesName + this.params.toolTipSepChar):"";
		toolText = toolText + ((this.categories[evtObj.index].toolText!="")?(this.categories[evtObj.index].toolText + this.params.toolTipSepChar):"");
		toolText = toolText + this.dataset[evtObj.dsindex].data[evtObj.index].displayValue;
		//Set the new tool text for Hover option
		this.dataset[evtObj.dsindex].data[evtObj.index].toolText = toolText;
		//------------VALUETB UPDATE------------------
		//Redraw the text in the same depth.
		//Store the new value textbox y position
		this.dataset[evtObj.dsindex].data[evtObj.index].valTBY = dataEndY;
		this.config.valTf[evtObj.dsindex][evtObj.index].removeTextField();
		this.drawValues(true, evtObj.dsindex, evtObj.dsindex, evtObj.index, evtObj.index); 
	}
	/**
	 * onResizeHRollOver is the delegat-ed event handler method that'll
	 * be invoked when the user rolls over the draggable columns.
	 * This function is invoked, only if the column dragging is ON.
	 * @param	evtObj		Event's object for each dragged column.
	*/
	private function onResizeHRollOver(evtObj):Void {
		//Local variables - so that we can access within the event handlers.
		var lResizeHMC:MovieClip = this.config.resizeHMC;
		var chartMC:MovieClip = this.cMC;
		//Hide the mouse
		Mouse.hide();
		//Show resize handler and set the position
		this.config.resizeHMC._x = this.cMC._xmouse;
		this.config.resizeHMC._y = this.cMC._ymouse;
		this.config.resizeHMC._visible = true;
		//Add to Enter Frame stack
		this.addToEnterFrameStk(evtObj.mc);
		//Define on enter frame - as we need the resizeHandler MC to be present
		//instead of the mouse.
		evtObj.mc.onEnterFrame = function() {
			//Set new X and Y Position				
			lResizeHMC._x = chartMC._xmouse;
			lResizeHMC._y = chartMC._ymouse;
			//Update screen for no flicker experience
			updateAfterEvent();
		};
	}
	/**
	 * onResizeHRollOut is the delegat-ed event handler method that'll
	 * be invoked when the user rolls out from the draggable columns.
	 * This function is invoked, only if the column dragging is ON.
	 * @param	evtObj		Event's object for each dragged column.
	*/
	private function onResizeHRollOut(evtObj):Void {
		//delete onEnterFrame
		delete evtObj.mc.onEnterFrame;
		//show the mouse
		Mouse.show();
		//Hide resize handler
		this.config.resizeHMC._visible = false;
	}
	/**
	 * columnOnRollOver is the delegat-ed event handler method that'll
	 * be invoked when the user rolls his mouse over a column. 
	 * This function is invoked, only if the tool tip is to be shown.
	 * Here, we show the tool tip.
	*/
	private function columnOnRollOver():Void{
		//Index of column is stored in arguments.caller.index
		var index:Number = arguments.caller.index;
		var dsindex:Number = arguments.caller.dsindex;
		//Set tool tip text
		this.tTip.setText(this.dataset[dsindex].data[index].toolText);
		//Show the tool tip
		this.tTip.show();
	}
	/**
	 * columnOnRollOut method is invoked when the mouse rolls out
	 * of column. We just hide the tool tip here.
	*/
	private function columnOnRollOut():Void{
		//Hide the tool tip
		this.tTip.hide();
	}
	/*
	 * columnOnMouseMove is called when the mouse position has changed
	 * over column. We reposition the tool tip.
	*/
	private function columnOnMouseMove():Void{
		//Reposition the tool tip only if it's in visible state
		if (this.tTip.visible()){
			this.tTip.rePosition();
		}
	}
	/**
	 * columnOnClick is invoked when the user clicks on a column (if link
	 * has been defined). We invoke the required link.														  
	*/
	private function columnOnClick():Void{
		//Index of column is stored in arguments.caller.index
		var dsindex:Number = arguments.caller.dsindex;
		var index:Number = arguments.caller.index;
		//Invoke the link
		super.invokeLink(this.dataset[dsindex].data[index].link);
	}	
	/**
	 * delegatedULAxis method updates the axis by adding a new DivLine block to the chart.
	*/
	private function delegatedULAxis():Void{
		//Check whether to add or delete from the upper limit
		var flag:Number = arguments.caller.addToUpperLimit;
		this.updateULAxis(flag);
	}
	/**
	 * delegatedLLAxis method updates the axis by adding a new DivLine block to the chart.
	*/
	private function delegatedLLAxis():Void{
		//Check whether to add or delete from the lower limit
		var flag:Number = arguments.caller.addToLowerLimit;
		this.updateLLAxis(flag);
	}
	/**
	 * updateULAxis method updates the axis by adding a new DivLine block to the chart.
	 *	param	caseVal	indicates 3 conditions namely
	 *		1.0 - add according to div line block
	 *		2.0 - delete from upper limit according to div line block
	 *		3.0 - change according to feed in value entered in the limit textfield
	 *	param	updatedValue	value which has been entered (this case is valid only for case 3.0)
	*/
	private function updateULAxis(caseVal:Number, updatedValue:Number):Boolean{
		//Hide resize handler
		this.config.resizeHMC._visible = false;
		//Variables
		//Error Flag to check whether there is any exception generated while changing the limits
		var errorFlag:Boolean = false;
		//If case 1.0 then add to Min value
		if(caseVal==1) {
			//update the yMax of the chart.
			addMaxValue();
			if(this.params.changeDivWithAxis) {
				//Increment the numDivLine
				this.params.numDivLines += 1;
			}
		}
		//Case 2.0 or 3.0
		else if( caseVal ==2 || caseVal ==3) {
			var diffInYMax:Number;
			// In case of 3.0 we need to update according to feed value
			if(caseVal == 3) {
				diffInYMax = updatedValue;
			}
			// In case of 2.0 we need to update according to divLine interval
			else if(caseVal == 2 ){
				diffInYMax = this.config.yMax-Math.abs(this.config.divInterval);
			}
			//Check whether are we allowed to reduce the chart values
			// i.e. if there is any column greater than the new highest value of div line
			for (var i:Number=1; i<=this.numDS; i++){
				for (var j:Number=1; j<=this.num; j++){
					//Check all the dataset value
					if (this.dataset[i].data[j].updatedValue > diffInYMax ){
						//Set the required message
						this.db.setErrorMessage(this.getULErrorMessage());
						//Show the dialog box
						this.db.show();
						//Set the error flag true
						errorFlag = true;
						//break from this loop
						break;
					}
				}
				//We do not iterate anymore as already we found 1 exception
				if(errorFlag) {
					//Break
					break;
				}
			}
			//Only if there is no error and case 2.0 - we subtract the min val and update the chart
			if(!errorFlag && caseVal==2) {
				//update the yMax of the chart.
				subtractMaxValue();
				if(this.params.changeDivWithAxis) {
					//Increment the number of Div Lines if required
					//Decrease the numDivLine
					this.params.numDivLines -= 1;
					this.divLines.length--;
				}
			}
		}
		//If allowed
		if(!errorFlag) {
			//For case 3.0 we set the new entered value as the yMin
			if(caseVal == 3){
				this.config.yMax = updatedValue;
			}
			//We calculate our div lines again for both 2.0 with changeDivWithAxis 
			// property set and case 3.0
			if(this.params.changeDivWithAxis || (caseVal==3)) {
				this.params.yAxisMinValue = this.config.yMin;
				//Update flags, as we're not internally setting the div lines
				//and our calcDivs needs to sort it into different cases. Here,
				//it will now go into Case 2,3,4 of the calculating function
				this.config.yMinGiven = true;
				this.config.yMaxGiven = true;
				//Special case for case 3.0 as we can't adjust the div lines
				if(caseVal == 3){
					this.params.adjustDiv = false;					
				}
				//Store axis range
				this.config.range = Math.abs(this.config.yMax-this.config.yMin);
			}
			//Redraw the chart for all the cases
			this.redrawChart();
		}
		return errorFlag;
	}
	/**
	 * updateLLAxis method updates the axis by deleting a DivLine block from the chart.
	 *	param	caseVal	indicates 3 conditions namely
	 *		1.0 - add according to div line block
	 *		2.0 - delete from upper limit according to div line block
	 *		3.0 - change according to feed in value entered in the limit textfield
	 *	param	updatedValue	value which has been entered (this case is valid only for case 3.0)
	*/
	private function updateLLAxis(caseVal:Number, updatedValue:Number):Boolean{
		//Hide resize handler
		this.config.resizeHMC._visible = false;
		//Variables
		var errorFlag:Boolean = false;
		//If case 1.0 then add to Min value
		if(caseVal==1) {
			//update the yMax of the chart.
			addMinValue();
			//If we need to add Div Lines too
			if(this.params.changeDivWithAxis) {
				//Increment the numDivLine
				this.params.numDivLines += 1;
			}
		}
		//Case 2.0 or 3.0
		else if( caseVal ==2 || caseVal ==3) {
			var diffInYMin:Number;
			// In case of 3.0 we need to update according to feed value
			if(caseVal == 3) {
				diffInYMin = updatedValue;
			}
			// In case of 2.0 we need to update according to divLine interval
			else if(caseVal == 2 ){
				diffInYMin = this.config.yMin+Math.abs(this.config.divInterval);
			}
			//Check whether are we allowed to reduce the chart values
			// i.e. if there is any column greater than the new highest value of div line
			for (var i:Number=1; i<=this.numDS; i++){
				for (var j:Number=1; j<=this.num; j++){
					//Check all the dataset value
					if (this.dataset[i].data[j].updatedValue < diffInYMin ){
						// Set the required error message
						this.db.setErrorMessage(this.getLLErrorMessage());
						//Show the dialog box - we the above error message
						this.db.show();
						//Set the error flag - to show the error dialog box
						errorFlag = true;
						//Break from this loop
						break;
					}
				}
				//We do not iterate anymore as already an exception has been generated
				if(errorFlag) {
					//Break
					break;
				}
			}
			//Only if there is no error and case 2.0 - we subtract the min val and update the chart
			if(!errorFlag && caseVal==2) {
				//update the yMin of the chart.
				subtractMinValue();
				if(this.params.changeDivWithAxis) {
					//Increment the number of Div Lines if required
					//Decrease the numDivLine
					this.params.numDivLines -= 1;
					this.divLines.length--;
				}
			}
		}
		//If no error
		if(!errorFlag) {
			//For case 3.0 we set the new entered value as the yMin
			if(caseVal == 3){
				//Reset the number of div lines
				this.config.yMin = updatedValue;
			}
			//We calculate our div lines again for both 2.0 with changeDivWithAxis 
			// property set and case 3.0
			if(this.params.changeDivWithAxis || (caseVal==3)) {
				this.params.yAxisMaxValue = this.config.yMax;
				//Update flags, as we're not internally setting the div lines
				//and our calcDivs needs to sort it into different cases. Here,
				//it will now go into Case 2,3,4 of the calculating function
				this.config.yMinGiven = true;
				this.config.yMaxGiven = true;
				//Special case for case 3.0 as we can't adjust the div lines
				if(caseVal == 3){
					this.params.adjustDiv = false;					
				}
				//Store axis range
				this.config.range = Math.abs(this.config.yMax-this.config.yMin);
			}
			//Redraw the chart - for all the cases
			this.redrawChart();
		}
		return errorFlag;
	}
	/**
	 * reInit method re-initializes the chart. This method is basically called
	 * when the user changes chart data through JavaScript. In that case, we need
	 * to re-initialize the chart, set new XML data and again render.
	*/
	public function reInit():Void{
		//Invoke super class's reInit
		super.reInit();
		//Now initialize things that are pertinent to this class
		//but not defined in super class.
		this.categories = new Array();
		this.dataset = new Array();
		//Initialize the number of data elements present
		this.numDS = 0;
		this.num = 0;
		this.lgnd.reset();
		//Restore animation
		this.params.animation = this.config.animation;
		this.config.animation = false;
		//Stack - to handle all the enter frame while re-initializing the chart
		var movieRef:Object;
		//Delete all the onEnterFrames of the movieclip
		while (this.config.stkEnterFrameLength > 0) {
			movieRef = this.deleteFromEnterFrameStk();
			if (movieRef._name != "") {
				delete movieRef.onEnterFrame;
			}
			this.config.stkEnterFrameLength--;
		}
		//Remove all the listeners
		while (this.config.stkListenerLength > 0) {
			this.config.stkListener[this.config.stkListenerLength].obj.removeEventListener(this.config.stkListener[this.config.stkListenerLength].lType, this.config.stkListener[this.config.stkListenerLength].lHandler);
			this.config.stkListenerLength--;
		}
		//Reinitialize the stack array and set length to 0
		this.config.stkEnterFrame = new Array();
		this.config.stkEnterFrameLength =0;
		this.config.stkListener = new Array();
		this.config.stkListenerLength =0;
		//Array to store the valueTB
		this.config.valTf = new Array();
	}
	/**
	 * removeObject method removes the unnecessary textfields from the movie.
	*/
	private function removeObject():Void{
		var tObj:Object = new Object();
		//remove all the div Line textfields
		var startDepth:Number = this.dm.getDepth("DIVLINES");
		var zeroLineDepth:Number = this.dm.getDepth("ZEROPLANE");
		var endDepth:Number = startDepth+249;
		//clear the chart objects already rendered (with depth starting from startDepth to endDepth)
		for (tObj in this.cMC) {
			//Get a reference to all objects present in the current timeline
			var obj:Object = this.cMC[tObj];
			//If the object is a movieClip and it's depth is between our required depths
			if ((obj.getDepth()<=endDepth) && (obj.getDepth()>=startDepth)) {
				obj.removeTextField();
			}
			if(obj.getDepth()==zeroLineDepth || obj.getDepth()==zeroLineDepth+1) {
				obj.removeTextField();
				obj.removeMovieClip();
			}
			delete obj;
		}
		//remove the HGrid movieclips
		startDepth = this.dm.getDepth("HGRID");
		endDepth = startDepth+124;
		//clear the chart objects already rendered (with depth starting from startDepth to endDepth)
		for (tObj in this.cMC) {
			//Get a reference to all objects present in the current timeline
			var obj:Object = this.cMC[tObj];
			//If the object is a movieClip and it's depth is between our required depths
			if ((obj.getDepth()<=endDepth) && (obj.getDepth()>=startDepth)) {
				obj.removeMovieClip();
			}
			delete obj;
		}
	}
	/**
	 * remove method removes the chart by clearing the chart movie clip
	 * and removing any listeners. 
	*/
	public function remove():Void {
		super.remove();
		//Remove class pertinent objects
		this.lgnd.destroy();
		lgndMC.removeMovieClip();
		//Remove the Error Dialog Box
		this.db.destroy();
	}	
}

