/**
 * CircumplexChart chart extends the Chart class to render a 
 * 2D Circumplex Chart.
 */
// Import the Delegate class
import mx.utils.Delegate;
//Parent SingleYAxisChart Class
import com.fusioncharts.core.SingleYAxisChart;
//Utils class
import com.fusioncharts.helper.Utils;
//Error class
import com.fusioncharts.helper.FCError;
//Import Logger Class
import com.fusioncharts.helper.Logger;
//Legend Class
import com.fusioncharts.helper.Legend;
// Import the MathExt class
import com.fusioncharts.extensions.MathExt;
//Import the Style Object
import com.fusioncharts.core.StyleObject;
class com.fusioncharts.core.charts.CircumplexChart extends SingleYAxisChart {
	//Version number (if different from super Chart class)
	//private var _version:String = "3.0.0";
	//Instance variables
	//Container for data
	private var group:Array;
	//Color range array 
	private var colorRange:Array;
	//OverLay data container
	private var overlayGroup:Array;
	//Reference to legend component of chart
	private var lgnd:Legend;
	//Reference to legend movie clip
	private var lgndMC:MovieClip;
	//numGroup keeps a count of number of Groups provided to the chart
	private var numGroup:Number;
	//numSection keeps a count of number of Section provided to the chart
	private var numSection:Number;
	//numColorRange keeps a count of number of color range provided to the chart
	private var numColorRange:Number;
	//numOverlayGroup keeps a count of number of overlay groups provided to the chart
	private var numOverlayGroup:Number;
	//List of chart objects
	private var _arrObjects:Array;
	// XML object 
	private var xmlData:XML;
	//
	/**
	 * Constructor function. We invoke the super class'
	 * constructor and then set the objects for this chart.
	*/
	function CircumplexChart(targetMC:MovieClip, depth:Number, width:Number, height:Number, x:Number, y:Number, debugMode:Boolean, lang:String, scaleMode:String, registerWithJS:Boolean, DOMId:String) {
		//Invoke the super class constructor
		super (targetMC, depth, width, height, x, y, debugMode, lang, scaleMode, registerWithJS, DOMId);
		//Log additional information to debugger
		//We log version from this class, so that if this class version
		//is different, we can log it
		this.log("Version", _version, Logger.LEVEL.INFO);
		this.log("Chart Type", "CircumPlex Chart", Logger.LEVEL.INFO);
		//List Chart Objects and set them
		_arrObjects = new Array("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "CENTERLABEL", "GROUPLABELS", "SECTIONLABELS", "SPIKES", "DATAPLOT", "OVERLAY", "CIRCUMOUTERCIRCLE", "DIVLINES", "TOOLTIP");
		super.setChartObjects(_arrObjects);
		//Initialize the arrays
		this.group = new Array();
		this.colorRange = new Array();
		this.overlayGroup= new Array();
		//Counter
		this.numGroup = 0;
		this.numSection = 0;
		this.numColorRange = 0;
		this.numOverlayGroup =0;
	}
	// -------------------- CORE CHART METHODS -------------------------- //
	/**
	 * render method is the single call method that does the rendering of chart:
	 * - Parsing XML
	 * - Calculating values and co-ordinates
	 * - Visual layout and rendering
	 * - Event handling
	*/
	public function render():Void {
		//Parse the XML Data document
		this.parseXML();
		//Now, if the number of data elements is 0, we show pertinent
		//error.
		if (this.numGroup == 0) {
			tfAppMsg = this.renderAppMessage(_global.getAppMessage("NODATA", this.lang));
			//Add a message to log.
			this.log("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn't any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI><LI>You might be using a Single Series Chart .swf file instead of Multi-series .swf file and providing multi-series data or vice-versa.</LI>", Logger.LEVEL.ERROR);
			//Expose rendered method
			this.exposeChartRendered();
		} else {
			//Set style defaults
			this.setStyleDefaults();
			//Detect number scales
			this.detectNumberScales();
			//Calculate the axis limits
			this.calculateAxisLimits();
			//Calculate Points
			this.calculatePoints();
			//Allot the depths for various charts objects now
			this.allotDepths();
			//Feed macro values
			this.feedMacros();
			//Set tool tip parameter
			this.setToolTipParam();
			//-------- Start Visual Rendering Now ------//
			//Draw background
			this.drawBackground();
			// set the global URL click
			this.drawClickURLHandler();
			// load the background SWF, if any
			this.loadBgSWF();
			//Update timer
			this.timeElapsed = (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.BACKGROUND) : 0;
			//Draw headers - caption and sub-caption
			this.config.intervals.headers = setInterval(Delegate.create(this, drawHeaders), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.CAPTION, this.objects.SUBCAPTION) : 0;
			//Call the method to render chart circle.
			this.config.intervals.circle = setInterval(Delegate.create(this, drawChart), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.CIRCUMCIRCLE) : 0;
			//Call the draw method to render spikes.
			this.config.intervals.spikes = setInterval(Delegate.create(this, drawSpikes), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.SPIKES) : 0;
			//Call the unified draw method to render circular div lines in the chart.
			this.config.intervals.divLines = setInterval(Delegate.create(this, drawCircularDivLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DIVLINES) : 0;
			//Call the unified draw method to render chart.
			this.config.intervals.plot = setInterval(Delegate.create(this, drawPlot), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DATAPLOT) : 0;
			this.config.intervals.overLay = setInterval(Delegate.create(this, drawOverlay), this.timeElapsed);
			//Call the unified draw method to render chart.
			this.config.intervals.label = setInterval(Delegate.create(this, setLabels), this.timeElapsed);
			//Legend
			this.config.intervals.legend = setInterval(Delegate.create(this, drawLegend), this.timeElapsed);
			//Remove application message
			this.removeAppMessage(this.tfAppMsg);
			//Dispatch event that the chart has loaded.
			this.config.intervals.renderedEvent = setInterval(Delegate.create(this, exposeChartRendered) , this.timeElapsed);
			//Render context menu
			//We do not put context menu interval as we need the menu to appear
			//right from start of the play.
			this.setContextMenu();
		}
	}
	/**
	 * allotDepths method allots the depths for various chart objects
	 * to be rendered. We do this before hand, so that we can later just
	 * go on rendering chart objects, without swapping.
	*/
	private function allotDepths():Void {
		//Background
		this.dm.reserveDepths("BACKGROUND", 1);
		//Click URL Handler
		this.dm.reserveDepths("CLICKURLHANDLER", 1);
		//Background SWF
		this.dm.reserveDepths("BGSWF", 1);
		//Caption
		this.dm.reserveDepths("CAPTION", 1);
		//Sub-caption
		this.dm.reserveDepths("SUBCAPTION", 1);
		//CircumCircle
		this.dm.reserveDepths("CIRCUMOUTERCIRCLE", 1);
		//Data plot Container
		this.dm.reserveDepths("DATAPLOT", 1);
		//DivLines
		this.dm.reserveDepths("DIVLINES", this.numColorRange);
		//CircumCircle's Spikes
		this.dm.reserveDepths("SPIKES", 1);
		//Overlay MC Container
		this.dm.reserveDepths("DATAOVERLAY", 1);
		//Circum Center Circle
		this.dm.reserveDepths("CIRCUMCENTERCIRCLE", 1);
		//Center label
		this.dm.reserveDepths("CENTERLABEL", 1);
		//labels
		this.dm.reserveDepths("GROUPLABELS", this.numGroup);
		//Section Labels
		this.dm.reserveDepths("SECTIONLABELS", this.numGroup*this.numSection);
		//Axis Limits
		this.dm.reserveDepths("AXISLABELS", this.numColorRange+2);
	}
	/**
	 * setStyleDefaults method sets the default values for styles or
	 * extracts information from the attributes and stores them into
	 * style objects.
	*/
	private function setStyleDefaults():Void {
		/**
		 * For the 2D Pie chart, we need to set defaults for the
		 * following object - property combinations:
		 * CAPTION - FONT
		 * SUBCAPTION - FONT
		 * GROUPLABELS - FONT
		 * SECTIONLABELS -FONT
		 * TOOLTIP - FONT
		 * DATAPLOT - Default Animation (Alpha)
		 * CIRCUMCIRCLE - Default Animation (Alpha)
		 * DIVLINES - Default Animation (Alpha)
		 */
		//Default font object for Caption
		//-----------------------------------------------------------------//
		var captionFont = new StyleObject();
		captionFont.name = "_SdCaptionFont";
		captionFont.align = "center";
		captionFont.valign = "top";
		captionFont.bold = "1";
		captionFont.font = this.params.baseFont;
		captionFont.size = this.params.baseFontSize;
		captionFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.CAPTION, captionFont, this.styleM.TYPE.FONT, null);
		delete captionFont;
		//-----------------------------------------------------------------//
		//Default font object for SubCaption
		//-----------------------------------------------------------------//
		var subCaptionFont = new StyleObject();
		subCaptionFont.name = "_SdSubCaptionFont";
		subCaptionFont.align = "center";
		subCaptionFont.valign = "top";
		subCaptionFont.bold = "1";
		subCaptionFont.font = this.params.baseFont;
		subCaptionFont.size = this.params.baseFontSize;
		subCaptionFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.SUBCAPTION, subCaptionFont, this.styleM.TYPE.FONT, null);
		delete subCaptionFont;
		//-----------------------------------------------------------------//
		//Default font object for GroupLabels
		//-----------------------------------------------------------------//
		var grpLabelsFont = new StyleObject();
		grpLabelsFont.name = "_SdGrpLabelsFont";
		grpLabelsFont.align = "center";
		grpLabelsFont.valign = "middle";
		grpLabelsFont.bold = "1";
		grpLabelsFont.font = this.params.outCnvBaseFont;
		grpLabelsFont.size = this.params.outCnvBaseFontSize;
		grpLabelsFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.GROUPLABELS, grpLabelsFont, this.styleM.TYPE.FONT, null);
		delete grpLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for SectionLabels
		//-----------------------------------------------------------------//
		var sectionLabelsFont = new StyleObject();
		sectionLabelsFont.name = "_SdSectionLabelsFont";
		sectionLabelsFont.align = "center";
		sectionLabelsFont.valign = "middle";
		sectionLabelsFont.font = this.params.outCnvBaseFont;
		sectionLabelsFont.size = this.params.outCnvBaseFontSize;
		sectionLabelsFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.SECTIONLABELS, sectionLabelsFont, this.styleM.TYPE.FONT, null);
		delete sectionLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for ToolTip
		//-----------------------------------------------------------------//
		var toolTipFont = new StyleObject();
		toolTipFont.name = "_SdToolTipFont";
		toolTipFont.font = this.params.baseFont;
		toolTipFont.size = this.params.baseFontSize;
		toolTipFont.color = this.params.baseFontColor;
		toolTipFont.bgcolor = this.params.toolTipBgColor;
		toolTipFont.bordercolor = this.params.toolTipBorderColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TOOLTIP, toolTipFont, this.styleM.TYPE.FONT, null);
		delete toolTipFont;
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for CircumCircle
		//-----------------------------------------------------------------//
		if (this.params.showShadow) {
			var circleShadow = new StyleObject();
			circleShadow.name = "_SdCircleShadow";
			circleShadow.angle = 45;
			//If we do not have to show Circle shadow
			circleShadow.alpha = this.params.shadowAlpha;
			circleShadow.color = this.params.shadowColor;
			//Over-ride     
			this.styleM.overrideStyle(this.objects.CIRCUMCIRCLE, circleShadow, this.styleM.TYPE.SHADOW, null);
			delete circleShadow;
		}
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for Legend
		//-----------------------------------------------------------------//
		if (this.params.legendShadow)
		{
			var legendShadow = new StyleObject ();
			legendShadow.name = "_SdLegendShadow";
			legendShadow.distance = 2;
			legendShadow.alpha = 90;
			legendShadow.angle = 45;
			//Over-ride
			this.styleM.overrideStyle (this.objects.LEGEND, legendShadow, this.styleM.TYPE.SHADOW, null);
			delete legendShadow;
		}
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for DataPlot
		//-----------------------------------------------------------------//
		if (this.params.showShadow) {
			var dataPlotShadow = new StyleObject();
			dataPlotShadow.name = "_SdDataPlotShadow";
			dataPlotShadow.angle = 45;
			//If we do not have to show slice shadow
			dataPlotShadow.alpha = this.params.shadowAlpha;
			dataPlotShadow.color = this.params.shadowColor;
			//Over-ride     
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			delete dataPlotShadow;
		}
		//-----------------------------------------------------------------//                
		//Default Animation object for Dataplot, CircumCircle and DivLines (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation) {
			//We need scale animation objects.
			//1. xscale for data plot						
			var xScaleAnim = new StyleObject();
			xScaleAnim.name = "_SdAnimXScale";
			xScaleAnim.param = "_xscale";
			xScaleAnim.easing = "regular";
			xScaleAnim.wait = 0;
			xScaleAnim.start = 0;
			xScaleAnim.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle(this.objects.CIRCUMCIRCLE, xScaleAnim, this.styleM.TYPE.ANIMATION, "_xscale");
			this.styleM.overrideStyle(this.objects.DIVLINES, xScaleAnim, this.styleM.TYPE.ANIMATION, "_xscale");
			this.styleM.overrideStyle(this.objects.DATAPLOT, xScaleAnim, this.styleM.TYPE.ANIMATION, "_xscale");
			delete xScaleAnim;
			//2. yscale for data plot						
			var yScaleAnim = new StyleObject();
			yScaleAnim.name = "_SdAnimYScale";
			yScaleAnim.param = "_yscale";
			yScaleAnim.easing = "regular";
			yScaleAnim.wait = 0;
			yScaleAnim.start = 0;
			yScaleAnim.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle(this.objects.CIRCUMCIRCLE, yScaleAnim, this.styleM.TYPE.ANIMATION, "_yscale");
			this.styleM.overrideStyle(this.objects.DIVLINES, yScaleAnim, this.styleM.TYPE.ANIMATION, "_yscale");
			this.styleM.overrideStyle(this.objects.DATAPLOT, yScaleAnim, this.styleM.TYPE.ANIMATION, "_yscale");
			delete yScaleAnim;
		}
		//-----------------------------------------------------------------//                
		//Default Animation object for Spikes and Overlay (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation) {
			//We need alpha animation objects.
			//1. alpha for data plot						
			var alphaAnim= new StyleObject();
			alphaAnim.name = "_SdAnimAlpha";
			alphaAnim.param = "_alpha";
			alphaAnim.easing = "regular";
			alphaAnim.wait = 0;
			alphaAnim.start = 0;
			alphaAnim.duration = 0.7;
			//Over-ride 
			this.styleM.overrideStyle(this.objects.SPIKES, alphaAnim, this.styleM.TYPE.ANIMATION, "_alpha");
			this.styleM.overrideStyle(this.objects.OVERLAY, alphaAnim, this.styleM.TYPE.ANIMATION, "_alpha");
			delete alphaAnim;
		}
		//-----------------------------------------------------------------//                                                                                                                                                                                    
	}
	// ----------------- DATA READING, PARSING AND STORING -----------------//
	/**
	 * parseXML method parses the XML data, sets defaults and validates
	 * the attributes before storing them to data storage objects.
	*/
	private function parseXML():Void {
		//Get the element nodes
		var arrDocElement:Array = this.xmlData.childNodes;
		//Loop variables
		var i:Number;
		var j:Number;
		var k:Number;
		var l:Number;
		//Section's XMLNode
		var sectionNode:XMLNode;
		//Look for <graph> element
		for (i=0; i<arrDocElement.length; i++) {
			//If it's a <graph> element, proceed.
			//Do case in-sensitive mathcing by changing to upper case
			if (arrDocElement[i].nodeName.toUpperCase() == "GRAPH" || arrDocElement[i].nodeName.toUpperCase() == "CHART") {
				//Extract attributes of <graph> element
				this.parseAttributes(arrDocElement[i]);
				//Now, get the child nodes - first level nodes
				var arrLevel1Nodes:Array = arrDocElement[i].childNodes;
				//Iterate through all level 1 nodes.
				for (j=0; j<arrLevel1Nodes.length; j++) {
					if (arrLevel1Nodes[j].nodeName.toUpperCase() == "COLORRANGE") {
						//Means the node contains the color ranges
						//So, extract the data
						var arrLevel2Nodes:Array = arrLevel1Nodes[j].childNodes;
						//Iterate through each of the nodes now.
						for (k=0; k<=arrLevel2Nodes.length; k++) {
							//If its a color XML tag
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "COLOR") {
								this.numColorRange++;
								//Color node.
								var colorNode:XMLNode = arrLevel2Nodes[k];
								//Get attributes array
								var colorAtts:Array = this.getAttributesArray(colorNode);
								//Store attributes
								var colorVal:Number = this.getSetValue(colorAtts["value"]);
								//Name
								var colorLabel:Number = getFV(colorAtts["label"], colorAtts["name"], "");
								//Alpha
								var colorAlpha:Number = getFN(colorAtts["alpha"], 100);
								//Dash properties
								var dashLen:Number = getFN(colorAtts["dashlen"], 5);
								var dashGap:Number = getFN(colorAtts["dashgap"], 5);
								//Border
								var borderAlpha:Number = getFN(colorAtts["borderalpha"], 100);
								var borderThickness:Number = getFN(colorAtts["borderthickness"], 1);
								var borderColor:String = getFV(colorAtts["bordercolor"], "000000");
								var dashed:Boolean = toBoolean(getFN(colorAtts["dashed"], 1));
								var includeInLegend:Boolean = toBoolean(getFN(colorAtts["includeinlegend"], 1));
								//If the color value is correct
								if(!isNaN(colorVal)) {
									//Store in a multidimensional array
									this.colorRange.push({value:colorVal, color: colorAtts["color"], alpha: colorAlpha, borderColor:borderColor, borderThickness:borderThickness, borderAlpha:borderAlpha, dashed:dashed, dashLen:dashLen, dashGap:dashGap, includeInLegend: includeInLegend, label:colorLabel});
								}
							}
						}
						//Sort the array based on the value parameter
						this.colorRange.sortOn(["value"], Array.NUMERIC);
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "PRIMARY") {
						//Get reference to child node.
						arrLevel2Nodes = arrLevel1Nodes[j].childNodes;
						//Iterate through all child-nodes of PRIMARY element
						//and search for GROUP node
						for (k=0; k<arrLevel2Nodes.length; k++) {
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "GROUP") {
								//Increment
								this.numGroup++;
								//Primary node.
								var groupNode:XMLNode = arrLevel2Nodes[k];
								//Get attributes array
								var grpAtts:Array = this.getAttributesArray(groupNode);
								//Create storage object in group array
								this.group[this.numGroup] = new Object();
								//Store attributes
								this.group[this.numGroup].label = getFV(grpAtts["label"], "");
								this.group[this.numGroup].showLabel = toBoolean(getFN(grpAtts["showlabel"], this.params.showGroupLabels));
								this.group[this.numGroup].color = getFV(grpAtts["color"], this.defColors.getColor());
								this.group[this.numGroup].bgColor = getFV(grpAtts["bgcolor"], this.params.outerCircleFillColor);
								this.group[this.numGroup].includeInLegend = toBoolean(getFN(grpAtts["includeinlegend"], 1));
								//Create data array under it.
								this.group[this.numGroup].section = new Array();
								//Get reference to child node.
								var arrLevel3Nodes:Array = arrLevel2Nodes[k].childNodes;
								//Iterate through all child-nodes of GROUP element
								//and search for SECTION node
								//Counter
								var sectionCount:Number = 0;
								for (l=0; l<arrLevel3Nodes.length; l++) {
									if (arrLevel3Nodes[l].nodeName.toUpperCase() == "SECTION") {
										//Set Node. So extract the data.
										//Update counter
										sectionCount++;
										//Get reference to node.
										sectionNode = arrLevel3Nodes[l];
										//Get attributes
										var atts:Array;
										atts = this.getAttributesArray(sectionNode);
										//Now, get value.
										var sectionValue:Number = this.getSetValue(atts["value"]);
										var sectionLabel:String = getFV(atts["label"], atts["name"], "");
										//We do NOT unescape the link, as this will be done
										//in invokeLink method for the links that user clicks.
										var sectionLink:String = getFV(atts["link"], "");
										var sectionToolText:String = getFV(atts["tooltext"], atts["hovertext"]);
										var sectionLegendText:String = getFV(atts["legendtext"], sectionLabel);
										var sectionColor:String = getFV(atts["color"], this.group[this.numGroup].color);
										var sectionAlpha:Number = getFN(atts["alpha"], 100);
										var sectionShowLabel:Boolean = toBoolean(getFN(atts["showlabel"], this.params.showSectionLabels));
										var includeInLegend:Boolean = toBoolean(getFN(atts["includeinlegend"], 1));
										//Store all these attributes as object.						
										this.group[this.numGroup].section[sectionCount] = this.returnDataAsObject(sectionValue, sectionLabel, sectionColor, sectionAlpha, sectionToolText, sectionLink, sectionShowLabel, sectionLegendText, includeInLegend);
									}
								}
								//Update global counter
								this.group[this.numGroup].numSection = sectionCount;
								if (sectionCount>this.numSection) {
									this.numSection = sectionCount;
								}
							}
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "OVERLAY") {
						//OVERLAY node.
						var overlayNode:XMLNode = arrLevel1Nodes[j];
						//Get attributes array
						var olAtts:Array = this.getAttributesArray(overlayNode);
						this.params.overlayThickness = getFN(olAtts["thickness"], this.params.overlayThickness);
						this.params.overlayAlpha = getFN(olAtts["alpha"], this.params.overlayAlpha);
						this.params.overlayColor = formatColor(getFV(olAtts["color"], this.params.overlayColor));
						//Get reference to child node.
						arrLevel2Nodes = arrLevel1Nodes[j].childNodes;
						//Iterate through all child-nodes of PRIMARY element
						//and search for GROUP node
						for (k=0; k<arrLevel2Nodes.length; k++) {
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "GROUP") {
								//Increment
								this.numOverlayGroup++;
								//Overlay's Group node.
								var groupNode:XMLNode = arrLevel2Nodes[k];
								//Get attributes array
								var grpAtts:Array = this.getAttributesArray(groupNode);
								//Create storage object in group array
								this.overlayGroup[this.numOverlayGroup] = new Object();
								//Store attributes
								this.overlayGroup[this.numOverlayGroup].color = getFV(grpAtts["color"], this.defColors.getColor());
								//Create data array under it.
								this.overlayGroup[this.numOverlayGroup].section = new Array();
								//Get reference to child node.
								var arrLevel3Nodes:Array = arrLevel2Nodes[k].childNodes;
								//Iterate through all child-nodes of GROUP element
								//and search for SECTION node
								//Counter
								var sectionCount:Number = 0;
								for (l=0; l<arrLevel3Nodes.length; l++) {
									if (arrLevel3Nodes[l].nodeName.toUpperCase() == "SECTION") {
										//Set Node. So extract the data.
										//Update counter
										sectionCount++;
										//Get reference to node.
										sectionNode = arrLevel3Nodes[l];
										//Get attributes
										var atts:Array;
										atts = this.getAttributesArray(sectionNode);
										//Now, get value.
										var sectionValue:Number = this.getSetValue(atts["value"]);
										//Store all these attributes as object.						
										this.overlayGroup[this.numOverlayGroup].section[sectionCount] = new Object();
										this.overlayGroup[this.numOverlayGroup].section[sectionCount].value = sectionValue;
									}
								}
								//Update global counter
								this.overlayGroup[this.numOverlayGroup].numSection = sectionCount;
							}
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "STYLES") {
						//Styles Node - extract child nodes
						var arrStyleNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the style nodes to extract style information
						super.parseStyleXML(arrStyleNodes);
					}
				}
			}
		}
		//Delete all temporary objects used for parsing XML Data document
		delete sectionNode;
		delete arrDocElement;
		delete arrLevel1Nodes;
		delete arrLevel2Nodes;
		delete arrLevel3Nodes;
	}
	/** 
	 * parseAttributes method parses the attributes and stores them in
	 * chart storage objects.
	 * Starting ActionScript 2, the parsing of XML attributes have also
	 * become case-sensitive. However, prior versions of FusionCharts
	 * supported case-insensitive attributes. So we need to parse all
	 * attributes as case-insensitive to maintain backward compatibility.
	 * To do so, we first extract all attributes from XML, convert it into
	 * lower case and then store it in an array. Later, we extract value from
	 * this array.
	 * @param	graphElement	XML Node containing the <graph> element
	 *							and it's attributes	 
	*/
	private function parseAttributes(graphElement:XMLNode):Void {
		//Array to store the attributes
		var atts:Array = this.getAttributesArray(graphElement);
		//NOW IT'S VERY NECCESARY THAT WHEN WE REFERENCE THIS ARRAY
		//TO GET AN ATTRIBUTE VALUE, WE SHOULD PROVIDE THE ATTRIBUTE
		//NAME IN LOWER CASE. ELSE, UNDEFINED VALUE WOULD SHOW UP.
		//Extract attributes pertinent to this chart
		//Which palette to use?
		this.params.palette = getFN(atts["palette"], 1);
		//Whether to show about FusionCharts Menu Item - by default set to on
		this.params.showFCMenuItem = toBoolean(getFN (atts ["showfcmenuitem"] , 1));
		// ---------- PADDING AND SPACING RELATED ATTRIBUTES ----------- //
		//captionPadding = Space between caption/subcaption and canvas start Y
		this.params.captionPadding = getFN(atts["captionpadding"], 10);
		//Label padding - Vertical space between the labels and canvas end position
		this.params.grpLabelPadding = getFN(atts["grplabelpadding"], atts["labelspadding"], 15);
		this.params.sectionLabelPadding = getFN(atts["sectionlabelpadding"], atts["labelspadding"], 5);
		//Padding of legend from right/bottom side of canvas
		this.params.legendPadding = getFN(atts["legendpadding"], 6);
		//Chart Margins - Empty space at the 4 sides
		this.params.chartLeftMargin = getFN(atts["chartleftmargin"], 25);
		this.params.chartRightMargin = getFN(atts["chartrightmargin"], 15);
		this.params.chartTopMargin = getFN(atts["charttopmargin"], 15);
		this.params.chartBottomMargin = getFN(atts["chartbottommargin"], 15);
		// -------------------------- HEADERS ------------------------- //
		//Chart Caption and sub Caption
		this.params.caption = getFV(atts["caption"], "");
		this.params.subCaption = getFV(atts["subcaption"], "");
		//Adaptive yMin - if set to true, the y min will be based on the values
		//provided. It won't be set to 0 in case of all positive values
		this.params.setAdaptiveYMin = toBoolean (getFN (atts ["setadaptiveymin"] , 0));
		//Whether to set animation for entire chart.
		this.config.animation = this.params.animation=toBoolean(getFN(atts["animation"], 1));
		//Whether to set the default chart animation
		this.params.defaultAnimation = toBoolean(getFN(atts["defaultanimation"], 1));
		//Configuration to set whether to show the labels   
		this.params.showLabels = toBoolean(getFN(atts["showlabels"], atts["shownames"], 1));
		this.params.showGroupLabels = toBoolean(getFN(atts["showgrouplabels"], atts["showgroupnames"], this.params.showLabels));
		this.params.showSectionLabels = toBoolean(getFN(atts["showsectionlabels"], atts["showsectionnames"], this.params.showLabels));
		//Click URL
		this.params.clickURL = getFV(atts["clickurl"], "");
		// ------------------------- COSMETICS -----------------------------//
		//Background properties - Gradient
		this.params.bgColor = getFV(atts["bgcolor"], this.defColors.get2DBgColor(this.params.palette));
		this.params.bgAlpha = getFV(atts["bgalpha"], this.defColors.get2DBgAlpha(this.params.palette));
		this.params.bgRatio = getFV(atts["bgratio"], this.defColors.get2DBgRatio(this.params.palette));
		this.params.bgAngle = getFV(atts["bgangle"], this.defColors.get2DBgAngle(this.params.palette));
		//Border Properties of chart
		this.params.showBorder = toBoolean(getFN(atts["showborder"], 1));
		this.params.borderColor = formatColor(getFV(atts["bordercolor"], this.defColors.get2DBorderColor(this.params.palette)));
		this.params.borderThickness = getFN(atts["borderthickness"], 1);
		this.params.borderAlpha = getFN(atts["borderalpha"], this.defColors.get2DBorderAlpha(this.params.palette));
		//Background swf
		this.params.bgSWF = getFV(atts["bgswf"], "");
		this.params.bgSWFAlpha = getFN(atts["bgswfalpha"], 100);
		//Plot cosmetic properties
		this.params.showPlotBorder = toBoolean(getFN(atts["showplotborder"], 1));
		this.params.plotBorderColor = formatColor(getFV(atts["plotbordercolor"], this.defColors.get2DPlotBorderColor(this.params.palette)));
		this.params.plotBorderThickness = getFN(atts["plotborderthickness"], 0);
		this.params.plotBorderAlpha = getFN(atts["plotborderalpha"], (this.params.showPlotBorder == true) ? 95 : 0);
		//Legend properties		
		this.params.showLegend = toBoolean(getFN(atts["showlegend"], 1));
		this.params.legendContains = getFV(atts["legendcontains"], "COLORRANGE");
		//Alignment position
		this.params.legendPosition = getFV(atts["legendposition"], "BOTTOM");
		//Legend position can be either RIGHT or BOTTOM -Check for it
		this.params.legendPosition = (this.params.legendPosition.toUpperCase() == "RIGHT") ? "RIGHT" : "BOTTOM";
		this.params.legendBorderColor = formatColor(getFV(atts["legendbordercolor"], this.defColors.get2DLegendBorderColor(this.params.palette)));
		this.params.legendBorderThickness = getFN(atts["legendborderthickness"], 1);
		this.params.legendBorderAlpha = getFN(atts["legendborderalpha"], 100);
		this.params.legendBgColor = getFV(atts["legendbgcolor"], this.defColors.get2DLegendBgColor(this.params.palette));
		this.params.legendBgAlpha = getFN(atts["legendbgalpha"], 100);
		this.params.legendShadow = toBoolean(getFN(atts["legendshadow"], 1));
		this.params.legendAllowDrag = toBoolean(getFN(atts["legendallowdrag"], 0));
		this.params.legendScrollBgColor = formatColor(getFV(atts["legendscrollbgcolor"], "CCCCCC"));
		this.params.legendScrollBarColor = formatColor(getFV(atts["legendscrollbarcolor"], this.params.legendBorderColor));
		this.params.legendScrollBtnColor = formatColor(getFV(atts["legendscrollbtncolor"], this.params.legendBorderColor));
		//Tool Tip - Show/Hide, Background Color, Border Color, Separator Character
		this.params.showToolTip = toBoolean(getFN(atts["showtooltip"], atts["showhovercap"], 1));
		this.params.groupNameInToolTip = toBoolean(getFN(atts["groupnameintooltip"], 1));
		this.params.sectionNameInToolTip= toBoolean(getFN(atts["sectionnameintooltip"], 1));
		this.params.toolTipBgColor = formatColor(getFV(atts["tooltipbgcolor"], atts["hovercapbgcolor"], atts["hovercapbg"], this.defColors.get2DToolTipBgColor(this.params.palette)));
		this.params.toolTipBorderColor = formatColor(getFV(atts["tooltipbordercolor"], atts["hovercapbordercolor"], atts["hovercapborder"], this.defColors.get2DToolTipBorderColor(this.params.palette)));
		this.params.toolTipSepChar = getFV(atts["tooltipsepchar"], atts["hovercapsepchar"], ", ");
		//Shadow properties
		this.params.showShadow = toBoolean(getFN(atts["showshadow"], 1));
		//Font Properties
		this.params.baseFont = getFV(atts["basefont"], "Verdana");
		this.params.baseFontSize = getFN(atts["basefontsize"], 10);
		this.params.baseFontColor = formatColor(getFV(atts["basefontcolor"], this.defColors.get2DBaseFontColor(this.params.palette)));
		this.params.outCnvBaseFont = getFV(atts["outcnvbasefont"], this.params.baseFont);
		this.params.outCnvBaseFontSize = getFN(atts["outcnvbasefontsize"], this.params.baseFontSize);
		this.params.outCnvBaseFontColor = formatColor(getFV(atts["outcnvbasefontcolor"], this.params.baseFontColor));
		//CircumPlex related properties
		this.params.centerRadius = atts["centerradius"];
		this.params.outerRadius = atts["outerradius"];
		this.params.centerLabel = getFV(atts["centerlabel"], "");
		this.params.centerFillColor = formatColor(getFV(atts["centerfillcolor"], "FF5904"));
		this.params.centerFillAlpha = getFN(atts["centerfillalpha"], 100);
		this.params.outerCircleFillColor = formatColor(getFV(atts["outercirclefillcolor"], this.defColors.get2DCanvasBgColor(this.params.palette)));
		this.params.outerCircleFillAlpha = getFN(atts["outercirclefillalpha"], this.defColors.get2DCanvasBgAlpha(this.params.palette));
		//Circle Border properties
		this.params.showCircleBorder = toBoolean(getFN(atts["circleplotborder"], 1));
		this.params.circleBorderColor = formatColor(getFV(atts["circlebordercolor"], "000000"));
		this.params.circleBorderThickness = getFN(atts["circleborderthickness"], 1);
		this.params.circleBorderAlpha = getFN(atts["circleborderalpha"], (this.params.showCircleBorder == true) ? 100 : 0);
		//Spike Border properties
		this.params.showMajorSpikeBorder = toBoolean(getFN(atts["showmajorspikeborder"], 1));
		this.params.majorSpikeBorderColor = formatColor(getFV(atts["majorspikebordercolor"], "000000"));
		this.params.majorSpikeBorderThickness = getFN(atts["majorspikeborderthickness"], 3);
		this.params.majorSpikeBorderAlpha = getFN(atts["majorspikeborderalpha"], (this.params.showMajorSpikeBorder == true) ? 100 : 0);
		this.params.showMinorSpikeBorder = toBoolean(getFN(atts["showminorspikeborder"], 1));
		this.params.minorSpikeBorderColor = formatColor(getFV(atts["minorspikebordercolor"], "000000"));
		this.params.minorSpikeBorderThickness = getFN(atts["minorspikeborderthickness"], 1);
		this.params.minorSpikeBorderAlpha = getFN(atts["minorspikeborderalpha"], (this.params.showMinorSpikeBorder == true) ? 100 : 0);
		//Over border properties
		this.params.overlayColor = formatColor(getFV(atts["overlaycolor"], "000000"));
		this.params.overlayThickness = getFN(atts["overlaythickness"], 3);
		this.params.overlayAlpha = getFN(atts["overlayalpha"], 100);
		//Axis Limits
		this.params.showAxisLimits = toBoolean(getFN(atts["showaxislimits"], 1));
		this.params.axisLabelBgColor = getFV(atts["axislabelbgcolor"], "CCCCCC");
		// ------------------------- NUMBER FORMATTING ---------------------------- //
		//Option whether the format the number (using Commas)
		this.params.formatNumber = toBoolean(getFN(atts["formatnumber"], 1));
		//Option to format number scale
		this.params.formatNumberScale = toBoolean(getFN(atts["formatnumberscale"], 0));
		//Number Scales
		this.params.defaultNumberScale = getFV(atts["defaultnumberscale"], "");
		this.params.numberScaleUnit = getFV(atts["numberscaleunit"], "K,M");
		this.params.numberScaleValue = getFV(atts["numberscalevalue"], "1000,1000");
		//Number prefix and suffix
		this.params.numberPrefix = getFV(atts["numberprefix"], "");
		this.params.numberSuffix = getFV(atts["numbersuffix"], "");
		//Decimal Separator Character
		this.params.decimalSeparator = getFV(atts["decimalseparator"], ".");
		//Thousand Separator Character
		this.params.thousandSeparator = getFV(atts["thousandseparator"], ",");
		//Input decimal separator and thousand separator. In some european countries,
		//commas are used as decimal separators and dots as thousand separators. In XML,
		//if the user specifies such values, it will give a error while converting to
		//number. So, we accept the input decimal and thousand separator from user, so that
		//we can covert it accordingly into the required format.
		this.params.inDecimalSeparator = getFV(atts["indecimalseparator"], "");
		this.params.inThousandSeparator = getFV(atts["inthousandseparator"], "");
		//Decimal Precision (number of decimal places to be rounded to)
		this.params.decimals = getFV(atts["decimals"], atts["decimalprecision"]);
		//Force Decimal Padding
		this.params.forceDecimals = toBoolean(getFN(atts["forcedecimals"], 0));
	}
	/**
	 * returnDataAsObject method creates an object out of the parameters
	 * passed to this method. The idea is that we store each data point
	 * as an object with multiple (flexible) properties. So, we do not 
	 * use a predefined class structure. Instead we use a generic object.
	 */
	private function returnDataAsObject(dataValue:Number, dataLabel:String, dataColor:String, dataAlpha:Number, dataToolText:String, dataLink:String, dataShowLabel:Boolean, dataLegendText:String, includeInLegend:Boolean):Object {
		//Create a container
		var dataObj:Object = new Object();
		//Store the values
		dataObj.value = (isNaN (dataValue)) ?0 : dataValue;
		dataObj.label = dataLabel;
		dataObj.color = dataColor;
		dataObj.alpha = dataAlpha;
		dataObj.toolText = dataToolText;
		dataObj.link = dataLink;
		dataObj.showLabel = dataShowLabel;
		dataObj.legendText = dataLegendText;
		dataObj.includeInLegend = includeInLegend;
		//If the given number is not a valid number or it's missing
		//set appropriate flags for this data point
		dataObj.isDefined = true;
		//dataObj.position is reserved for storing coordinates of the pie
		dataObj.startX = 0;
		dataObj.startY = 0;
		dataObj.endX = 0;
		dataObj.endY = 0;
		dataObj.angle = 0;
		dataObj.tfX = 0;
		dataObj.tfY = 0;
		//Return the container
		return dataObj;
	}
	/**
	* getMaxDataValue method gets the maximum y-axis data value present
	* in the data.
	*	@return	The maximum value present in the data provided.
	*/
	private function getMaxDataValue () : Number 
	{
		var maxValue : Number;
		var firstNumberFound : Boolean = false;
		var i : Number, j : Number;
		for (i=1; i<=this.numGroup; i++) {
			for (j=1; j<=this.group[i].numSection; j++) 
			{
				//By default assume the first non-null number to be maximum
				if (firstNumberFound == false)
				{
					if (this.group[i].section[j].isDefined == true)
					{
						//Set the flag that "We've found first non-null number".
						firstNumberFound = true;
						//Also assume this value to be maximum.
						maxValue = this.group[i].section[j].value;
					}
				} else 
				{
					//If the first number has been found and the current data is defined, compare
					if (this.group[i].section[j].isDefined)
					{
						//Store the greater number
						maxValue = (this.group[i].section[j].value > maxValue) ? this.group[i].section[j].value : maxValue;
					}
				}
			}
		}
		return maxValue;
	}
	/**
	* getMinDataValue method gets the minimum y-axis data value present
	* in the data
	*	@reurns		The minimum value present in data
	*/
	private function getMinDataValue () : Number 
	{
		var minValue : Number;
		var firstNumberFound : Boolean = false;
		var i : Number, j : Number;
		for (i=1; i<=this.numGroup; i++) {
			for (j=1; j<=this.group[i].numSection; j++) 
			{
				//By default assume the first non-null number to be minimum
				if (firstNumberFound == false)
				{
					if (this.group[i].section[j].isDefined == true)
					{
						//Set the flag that "We've found first non-null number".
						firstNumberFound = true;
						//Also assume this value to be minimum.
						minValue = this.group[i].section[j].value;
					}
				} else 
				{
					//If the first number has been found and the current data is defined, compare
					if (this.group[i].section[j].isDefined)
					{
						//Store the lesser number
						minValue = (this.group[i].section[j].value < minValue) ? this.group[i].section[j].value : minValue;
					}
				}
			}
		}
		return minValue;
	}
	/**
	* calculateAxisLimits method sets the axis limits for the chart.
	* It gets the minimum and maximum value specified in data and
	* based on that it calls super.getAxisLimits();
	*/
	private function calculateAxisLimits() : Void 
	{
		this.getAxisLimits (this.getMaxDataValue () , this.getMinDataValue () , false, ! this.params.setAdaptiveYMin);
	}
	// ---------------- CALCULATION AND OPTIMIZATION -----------------//
	/**
	* calculatePoints method calculates the various points on the chart.
	*/
	private function calculatePoints():Void {
		//Loop variable
		var i:Number;
		var j:Number;
		//Format all the numbers on the chart and store their display values
		//We format and store here itself, so that later, whenever needed,
		//we just access displayValue instead of formatting once again.
		//Also set tool tip text values
		var toolText:String;
		for (i=1; i<=this.numGroup; i++) {
			for (j=1; j<=this.group[i].numSection; j++) {
				//Format and store
				this.group[i].section[j].displayValue = formatNumber(this.group[i].section[j].value, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
				//Tool tip text.
				//Preferential Order - Set Tool Text (No concatenation) > SeriesName + Cat Name + Value
				if (this.group[i].section[j].toolText == undefined || this.group[i].section[j].toolText == "") {
					//If the tool tip text is not already defined
					//If labels have been defined
					toolText = (this.params.groupNameInToolTip && this.group[i].label != "") ? (this.group[i].label+this.params.toolTipSepChar) : "";
					toolText += (this.params.sectionNameInToolTip && this.group[i].section[j].label != "") ? (this.group[i].section[j].label+this.params.toolTipSepChar) : "";
					toolText = toolText+this.group[i].section[j].displayValue;
					this.group[i].section[j].toolText = toolText;
				}
			}
		}
		//We now need to calculate the available Width on the canvas.
		//Available width = total Chart width minus the list below
		// - Left and Right Margin
		// - yAxisName (if to be shown)
		// - yAxisValues
		// - Trend line display values (both left side and right side).
		// - Legend (If to be shown at right)
		var canvasWidth:Number = this.width-(this.params.chartLeftMargin+this.params.chartRightMargin);
		//Set canvas startX
		var canvasStartX:Number = this.params.chartLeftMargin;
		//We need to take into consideration the width of labels now.
		var grpLabelFontObj:Object = this.styleM.getTextStyle(this.objects.GROUPLABELS);
		//Iterate through the labels to be placed on left side of circum circle
		//and get their width
		var maxLabelWLeft:Number = 0;
		for (i=1; i<=int(this.numGroup/2); i++) {
			if (this.group[i].showLabel) {
				//Create text field to get width
				var labelObj:Object = createText(true, this.group[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, grpLabelFontObj, false, 0, 0);
				//Store the greater width
				maxLabelWLeft = Math.max(maxLabelWLeft, labelObj.width);
				delete labelObj;
			}
			for (j=1; j<=this.group[i].numSection; j++) {
				if (this.group[i].section[j].showLabel) {
					//Create text field to get width
					var labelObj:Object = createText(true, this.group[i].section[j].label, this.tfTestMC, 1, testTFX, testTFY, 0, grpLabelFontObj, false, 0, 0);
					//Store the greater width
					maxLabelWLeft = Math.max(maxLabelWLeft, labelObj.width);
					delete labelObj;
				}
			}
		}
		//Now, iterate through labels that are to be placed on right side of radar
		var maxLabelWRight:Number = 0;
		for (i=int(this.numGroup/2)+1; i<=this.numGroup; i++) {
			if (this.group[i].showLabel) {
				//Create text field to get width
				var labelObj:Object = createText(true, this.group[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, grpLabelFontObj, false, 0, 0);
				//Store the greater width
				maxLabelWRight = Math.max(maxLabelWRight, labelObj.width);
				delete labelObj;
			}
			for (j=1; j<=this.group[i].numSection; j++) {
				if (this.group[i].section[j].showLabel) {
					//Create text field to get width
					var labelObj:Object = createText(true, this.group[i].section[j].label, this.tfTestMC, 1, testTFX, testTFY, 0, grpLabelFontObj, false, 0, 0);
					//Store the greater width
					maxLabelWRight = Math.max(maxLabelWRight, labelObj.width);
					delete labelObj;
				}
			}
		}
		//Round them off finally to avoid distorted pixels    
		canvasStartX = int(canvasStartX+maxLabelWLeft);
		canvasWidth = int(canvasWidth-(maxLabelWLeft+maxLabelWRight));
		//Only if there is 1 Label drawn at bottom - we add the label Padding also
		if(maxLabelWRight !=0) {
			canvasWidth -= this.params.grpLabelPadding;
		}
		//Only if there is 1 Label drawn at top - we add the label Padding also
		if(maxLabelWLeft !=0) {
			canvasWidth -= this.params.grpLabelPadding;
			canvasStartX = int(canvasStartX+this.params.grpLabelPadding);
		}
		//Initialize canvasHeight to total height minus margins
		var canvasHeight:Number = this.height-(this.params.chartTopMargin+this.params.chartBottomMargin);
		//Set canvasStartY
		var canvasStartY:Number = this.params.chartTopMargin;
		//Now calculate the maximum height for the label
		var maxLabelHTop:Number = 0;
		var maxLabelHBottom:Number = 0;
		for (i=1; i<=this.numGroup; i++) {
			if (i == 1 || i == this.numGroup) {
				if (this.group[i].showLabel) {
					//Create text field to get width
					var labelObj:Object = createText(true, this.group[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, grpLabelFontObj, false, 0, 0);
					//Store the greater width
					maxLabelHTop = Math.max(maxLabelHTop, labelObj.height);
					delete labelObj;
				}
			} else {
				if (this.group[i].showLabel) {
					//Create text field to get width
					var labelObj:Object = createText(true, this.group[i].label, this.tfTestMC, 1, testTFX, testTFY, 0, grpLabelFontObj, false, 0, 0);
					//Store the greater width
					maxLabelHBottom = Math.max(maxLabelHBottom, labelObj.height);
					delete labelObj;
				}
			}
		}
		//Round them off finally to avoid distorted pixels    
		canvasStartY = int(canvasStartY+maxLabelHTop);
		canvasHeight = int(canvasHeight-(maxLabelHBottom+maxLabelHTop));
		//Only if there is 1 Label drawn at bottom - we add the label Padding also
		if(maxLabelHBottom !=0) {
			canvasHeight -= this.params.grpLabelPadding;
		}
		//Only if there is 1 Label drawn at top - we add the label Padding also
		if(maxLabelHTop !=0) {
			canvasHeight -= this.params.grpLabelPadding;
			canvasStartY = int(canvasStartY+this.params.grpLabelPadding);
		}
		//We finally have canvas Width and canvas Start X
		//-----------------------------------------------------------------------------------//
		//Now, we need to calculate the available Height on the canvas.
		//Available height = total Chart height minus the list below
		// - Chart Top and Bottom Margins
		// - Space for Caption, Sub Caption and caption padding
		// - Height of data labels
		// - xAxisName
		// - Legend (If to be shown at bottom position)
		//Now, if we've to show caption
		if (this.params.caption != "") {
			//Create text field to get height
			var captionObj:Object = createText(true, this.params.caption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.CAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+captionObj.height;
			canvasHeight = canvasHeight-captionObj.height;
			//Create element for caption - to store width & height
			this.elements.caption = returnDataAsElement(0, 0, captionObj.width, captionObj.height);
			delete captionObj;
		}
		//Now, if we've to show sub-caption          
		if (this.params.subCaption != "") {
			//Create text field to get height
			var subCaptionObj:Object = createText(true, this.params.subCaption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.SUBCAPTION), false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY+subCaptionObj.height;
			canvasHeight = canvasHeight-subCaptionObj.height;
			//Create element for sub caption - to store height
			this.elements.subCaption = returnDataAsElement(0, 0, subCaptionObj.width, subCaptionObj.height);
			delete subCaptionObj;
		}
		//Now, if either caption or sub-caption was shown, we also need to adjust caption padding          
		if (this.params.caption != "" || this.params.subCaption != "") {
			//Account for padding
			canvasStartY = canvasStartY+this.params.captionPadding;
			canvasHeight = canvasHeight-this.params.captionPadding;
		}
		//We have canvas start Y and canvas height      
		//We now check whether the legend is to be drawn 
		if (this.params.showLegend) {
			//Object to store dimensions
			var lgndDim:Object = lgnd.getDimensions();
			//Create container movie clip for legend
			this.lgndMC = this.cMC.createEmptyMovieClip("Legend", this.dm.getDepth("LEGEND"));
			//Create instance of legend			
			if (this.params.legendPosition == "BOTTOM") {
				//Maximum Height - 50% of stage
				lgnd = new Legend(lgndMC, this.styleM.getTextStyle(this.objects.LEGEND), this.params.legendPosition, canvasStartX+canvasWidth/2, this.height/2, canvasWidth, (this.height-(this.params.chartTopMargin+this.params.chartBottomMargin))*0.5, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor);
			} else {
				//Maximum Width - 40% of stage
				lgnd = new Legend(lgndMC, this.styleM.getTextStyle(this.objects.LEGEND), this.params.legendPosition, this.width/2, canvasStartY+canvasHeight/2, (this.width-(this.params.chartLeftMargin+this.params.chartRightMargin))*0.4, canvasHeight, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor);
			}
			//Feed data set series Name for legend
			if(this.params.legendContains.toUpperCase() == "GROUP") {
				for (i=1; i<=this.numGroup; i++) {
					if (this.group[i].includeInLegend && this.group[i].label != "") {
						lgnd.addItem(this.group[i].label, this.group[i].color);
					}
				}
			}
			else if(this.params.legendContains.toUpperCase() == "SECTION") {
				for (i=1; i<=this.numGroup; i++) {
					for (j=1; j<=this.group[i].numSection; j++) {
						if (this.group[i].section[j].includeInLegend && this.group[i].section[j].legendText != "") {
							lgnd.addItem(this.group[i].section[j].legendText, this.group[i].section[j].color);
						}
					}
				}
			}
			else {
				for (i=0; i<this.numColorRange; i++) {
					if (this.colorRange[i].includeInLegend && this.colorRange[i].label != "" && (this.colorRange[i].color != "" && this.colorRange[i].color != undefined)) {
						lgnd.addItem(this.colorRange[i].label, this.colorRange[i].color);
					}
				}
			}
			if (this.params.legendPosition == "BOTTOM") {
				lgndDim = lgnd.getDimensions();
				//Now deduct the height from the calculated canvas height
				canvasHeight = canvasHeight-lgndDim.height-this.params.legendPadding;
				//Re-set the legend position
				this.lgnd.resetXY(canvasStartX+canvasWidth/2, this.height-this.params.chartBottomMargin-lgndDim.height/2);
			} else {
				//Get dimensions
				lgndDim = lgnd.getDimensions();
				//Now deduct the width from the calculated canvas width
				canvasWidth = canvasWidth-lgndDim.width-this.params.legendPadding;
				//Right position
				this.lgnd.resetXY(this.width-this.params.chartRightMargin-lgndDim.width/2, canvasStartY+canvasHeight/2);
			}
		}
		//Create an element to represent the canvas now. 
		this.elements.canvas = returnDataAsElement(canvasStartX, canvasStartY, canvasWidth, canvasHeight);
		//Now, the circum circle will take the smaller of canvas width or height available.
		var circumCircleRadius:Number = Math.min(canvasWidth, canvasHeight*0.9)/2;
		this.params.centerRadius = getFN(this.params.centerRadius, circumCircleRadius*0.2);
		//Get preferential
		this.params.outerRadius = getFN(this.params.outerRadius, circumCircleRadius);
		//Now, store the circumcircle center
		this.elements.circumCircle = returnDataAsElement(canvasStartX+this.elements.canvas.w/2, canvasStartY+this.params.outerRadius+(this.elements.canvas.h-2*this.params.outerRadius)/2, this.params.outerRadius, this.params.outerRadius);
		//Calculate group angles
		this.config.groupAngle = 360/this.numGroup;
		//Now, we need to calculate the position of the categories & data plots
		var grpEndPoint:Object, grpStartPoint:Object, grpTFPoint:Object;
		var dataStartPoint:Object, dataEndPoint:Object, dataTFPoint:Object;
		for (i=1; i<=this.numGroup; i++) {
			//StartAngle for each group
			this.group[i].startAngle = (this.config.groupAngle*(i-1))+90;
			//Calculate the start point position of the group Spike - major Spike of the chart
			grpStartPoint= this.calculatePoint(this.elements.circumCircle.x, this.elements.circumCircle.y, this.params.centerRadius, this.group[i].startAngle);
			this.group[i].startX = grpStartPoint.x;
			this.group[i].startY = grpStartPoint.y;
			grpEndPoint = this.calculatePoint(this.elements.circumCircle.x, this.elements.circumCircle.y, this.params.outerRadius, this.group[i].startAngle);
			this.group[i].endX = grpEndPoint.x;
			this.group[i].endY = grpEndPoint.y;
			//Now calculate the position of the group label
			grpTFPoint  = this.calculatePoint(this.elements.circumCircle.x, this.elements.circumCircle.y, this.params.outerRadius+this.params.grpLabelPadding, this.group[i].startAngle+this.config.groupAngle/2);
			this.group[i].tfX = grpTFPoint.x;
			this.group[i].tfY = grpTFPoint.y;
			//calculate the segment angle
			this.group[i].sectionAngle = this.config.groupAngle/this.group[i].numSection;
			for (j=1; j<=this.group[i].numSection; j++) {
				//Store the angle
				this.group[i].section[j].angle = this.group[i].startAngle+(this.group[i].sectionAngle*j);
				//Calculate the distance from the centre
				dataStartPoint = this.calculatePoint(this.elements.circumCircle.x, this.elements.circumCircle.y, this.params.centerRadius, this.group[i].startAngle+(this.group[i].sectionAngle*j));
				//Store the starting X value of the SPIKES
				this.group[i].section[j].startX = dataStartPoint.x;
				this.group[i].section[j].startY = dataStartPoint.y;
				//Calculate the end position of the SPIKES
				dataEndPoint = this.calculatePoint(this.elements.circumCircle.x, this.elements.circumCircle.y, this.params.outerRadius, this.group[i].startAngle+(this.group[i].sectionAngle*j));
				//Store in the section object
				this.group[i].section[j].endX = dataEndPoint.x;
				this.group[i].section[j].endY = dataEndPoint.y;
				//Now calculate the position of the group label
				dataTFPoint  = this.calculatePoint(this.elements.circumCircle.x, this.elements.circumCircle.y, this.params.outerRadius+this.params.sectionLabelPadding, this.group[i].startAngle+(this.group[i].sectionAngle*j-(this.group[i].sectionAngle/2)));
				this.group[i].section[j].tfX = dataTFPoint.x;
				this.group[i].section[j].tfY = dataTFPoint.y;
			}
		}
		//Traverse through the list of colorRange
		for(i=0; i<this.numColorRange; i++) {
			//Check if the value is less than the min value
			if(this.colorRange[i].value<this.config.yMin) {
				this.colorRange[i].value = this.config.yMin;
			}
			//Check if the value is more than the max value
			if(this.colorRange[i].value>this.config.yMax) {
				this.colorRange[i].value = this.config.yMax;
			}
			//Check if 2 values are same
			if(this.colorRange[i].value == this.colorRange[i-1].value) {
				this.colorRange.splice(i, 1);
				this.numColorRange--;
			}
			//Format and store
			this.colorRange[i].displayValue = formatNumber(this.colorRange[i].value, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
		}
	}
	/**
	 * feedMacros method feeds macros and their respective values
	 * to the macro instance. This method is to be called after
	 * calculatePoints, as we set the canvas and chart co-ordinates
	 * in this method, which is known to us only after calculatePoints.
	 * WE OVER-RIDE THE CHART CLASS METHOD BECAUSE CANVAS IS NOT DEFINED
	 * FOR A CircumPlex CHART. SO, WE JUST ASSUME THE VALUES OF FULL PLOT AREA.
	 *	@returns	Nothing
	*/
	private function feedMacros():Void {
		//Feed macros one by one
		//Chart dimension macros
		this.macro.addMacro("$chartStartX", this.x);
		this.macro.addMacro("$chartStartY", this.y);
		this.macro.addMacro("$chartWidth", this.width);
		this.macro.addMacro("$chartHeight", this.height);
		this.macro.addMacro("$chartEndX", this.width);
		this.macro.addMacro("$chartEndY", this.height);
		this.macro.addMacro("$chartCenterX", this.width/2);
		this.macro.addMacro("$chartCenterY", this.height/2);
		//Canvas dimension macros
		this.macro.addMacro("$canvasStartX", this.x);
		this.macro.addMacro("$canvasStartY", this.y);
		this.macro.addMacro("$canvasWidth", this.width);
		this.macro.addMacro("$canvasHeight", this.height);
		this.macro.addMacro("$canvasEndX", this.width);
		this.macro.addMacro("$canvasEndY", this.height);
		this.macro.addMacro("$canvasCenterX", this.width/2);
		this.macro.addMacro("$canvasCenterY", this.height/2);
	}
	// -------------- VISUAL RENDERING METHODS ---------------------//
	/**
	* drawHeaders method renders the following on the chart:
	* CAPTION, SUBCAPTION
	*/
	private function drawHeaders() {
		//Sub-caption start y positio
		var subCaptionY:Number = this.params.chartTopMargin;
		//Render caption
		if (this.params.caption != "") {
			var captionStyleObj:Object = this.styleM.getTextStyle(this.objects.CAPTION);
			captionStyleObj.align = "center";
			captionStyleObj.vAlign = "bottom";
			var captionObj:Object = createText(false, this.params.caption, this.cMC, this.dm.getDepth('CAPTION'), (this.width/2), this.params.chartTopMargin, 0, captionStyleObj, false, 0, 0);
			//Add for sub-caption y position
			subCaptionY = subCaptionY+captionObj.height;
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(captionObj.tf, this.objects.CAPTION, this.macro, captionObj.tf._x, 0, captionObj.tf._y, 0, 100, null, null, null);
			}
			//Apply filters                                                                                                                                                                                                 
			this.styleM.applyFilters(captionObj.tf, this.objects.CAPTION);
			//Delete
			delete captionObj;
			delete captionStyleObj;
		}
		//Render sub caption                                                                                                                                                                                                 
		if (this.params.subCaption != "") {
			var subCaptionStyleObj:Object = this.styleM.getTextStyle(this.objects.SUBCAPTION);
			subCaptionStyleObj.align = "center";
			subCaptionStyleObj.vAlign = "bottom";
			var subCaptionObj:Object = createText(false, this.params.subCaption, this.cMC, this.dm.getDepth('SUBCAPTION'), (this.width/2), subCaptionY, 0, subCaptionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(subCaptionObj.tf, this.objects.SUBCAPTION, this.macro, subCaptionObj.tf._x, 0, subCaptionObj.tf._y, 0, 100, null, null, null);
			}
			//Apply filters                                                                                                                                                                                                 
			this.styleM.applyFilters(subCaptionObj.tf, this.objects.SUBCAPTION);
			//Delete
			delete subCaptionObj;
			delete subCaptionStyleObj;
		}
		//Clear interval                                                                                                                                                                                            
		clearInterval(this.config.intervals.headers);
	}
	/**
	 * drawDashedArc method is called to draw dashed border
	 * @param	mc				MovieClip in which we need the dashed arc to be drawn
	 * @param	x				Starting X position of the arc
	 * @param	y				Starting Y position of the arc
	 * @param	startAngle		Starting angle of the arc
	 * @param	arc				sweepangle of the arc
	 * @param	radius			outer Radius of the arc from the center
	 * @param	borderThickness	thickness at which we need the arc
	 * @param	borderColor		color of the arc to be drawn
	 * @param	borderAlpha		border alpha
	 */
	private function drawDashedArc(mc:MovieClip, x:Number, y:Number, startAngle:Number, arc:Number, radius:Number, borderThickness:Number, borderColor:Number, borderAlpha:Number):Void {
		var xcenter:Number = x;
		var ycenter:Number = y;
		//-------------- C A L C U L A T E --------------
		var dashCurveLength:Number = 5;
		var dashAng:Number = MathExt.toDegrees(dashCurveLength/radius);
		var endBorderAlpha:Number = 0;
		var endAng:Number = startAngle+arc;
		var loops:Number = Math.round(arc/dashAng);
		if (arc != 360) {
			// need odd value of 'loops' so that curve both, starts and ends, with dashes 
			loops = (Math.floor(loops/2) == loops/2) ? loops+1 : loops;
		} else {
			// need even value of 'loops' so that curve starts with dash but ends with blank space
			loops = (Math.floor(loops/2) == loops/2) ? loops : loops+1;
		}
		// recalculating dashAng and approximating for optimization
		dashAng = MathExt.toRadians(MathExt.toNearestTwip(arc/loops));
		//------------------------
		var loopsLine:Number = Math.floor(radius/dashCurveLength);
		// need odd value of 'loops'
		loopsLine = (Math.floor(loopsLine/2) == loopsLine/2) ? loopsLine+1 : loopsLine;
		var dx:Number = MathExt.toNearestTwip(radius/loopsLine);
		//--------------- FUNCTION ------------------
		// rounding off upto 2 significant digits after decimal point
		var roundOff = function (num:Number):Number {
			return Math.floor(num*100)/100;
		};
		//---------------  D R A W  -----------------
		mc.moveTo(xcenter, ycenter);
		// dashed line along starting angle is drawn
		for (var i:Number = 1; i<=loopsLine; ++i) {
			var alpha:Number = (Math.floor(i/2) == i/2) ? 0 : endBorderAlpha;
			mc.lineStyle(borderThickness, borderColor, alpha);
			//
			var endX:Number = roundOff(xcenter+i*dx*Math.cos(startAngle));
			var endY:Number = roundOff(ycenter+i*dx*Math.sin(startAngle));
			//
			mc.lineTo(endX, endY);
		}
		// dashed curve part is drawn
		for (var i:Number = 1; i<=loops; ++i) {
			var alpha:Number = (Math.floor(i/2) == i/2) ? 0 : borderAlpha;
			mc.lineStyle(borderThickness, borderColor, alpha);
			//
			var endX:Number = roundOff(xcenter+radius*Math.cos(startAngle+i*dashAng));
			var endY:Number = roundOff(ycenter+radius*Math.sin(startAngle+i*dashAng));
			//
			var e:Number = radius/Math.cos(dashAng/2);
			var b:Number = startAngle+i*dashAng-dashAng/2;
			//
			var controlX:Number = roundOff(xcenter+e*Math.cos(b));
			var controlY:Number = roundOff(ycenter+e*Math.sin(b));
			//
			mc.curveTo(controlX, controlY, endX, endY);
		}
		// dashed line along starting angle is drawn
		for (var i:Number = loopsLine-1; i>=0; --i) {
			var alpha:Number = (Math.floor(i/2) == i/2) ? endBorderAlpha : 0;
			mc.lineStyle(borderThickness, borderColor, alpha);
			//
			var endX:Number = roundOff(xcenter+i*dx*Math.cos(endAng));
			var endY:Number = roundOff(ycenter+i*dx*Math.sin(endAng));
			//
			mc.lineTo(endX, endY);
		}
	}
	/**
	* drawArc method draw an arc of specified angle
	 * @param	mc				MovieClip in which we need the arc to be drawn
	 * @param	x				Starting X position of the arc
	 * @param	y				Starting Y position of the arc
	 * @param	startAngle		Starting angle of the arc
	 * @param	arc				sweepangle of the arc
	 * @param	radius			X outer Radius of the arc from the center
	 * @param	yRadius			Y outer Radius of the arc from the center
	*/
	private function drawArc(mc:MovieClip, x:Number, y:Number, startAngle:Number, arc:Number, radius:Number, yRadius:Number) {
		// ==============
		// x, y = center point of the wedge.
		// startAngle = starting angle in degrees.
		// arc = sweep of the wedge. Negative values draw clockwise.
		// radius = radius of wedge. If [optional] yRadius is defined, then radius is the x radius.
		// yRadius = [optional] y radius for wedge.
		// if yRadius is undefined, yRadius = radius
		if (yRadius == undefined) {
			yRadius = radius;
		}
		// Init vars     
		var segAngle, theta, angle, angleMid, segs, ax, ay, bx, by, cx, cy;
		// limit sweep to reasonable numbers
		if (Math.abs(arc)>360) {
			arc = 360;
		}
		// Flash uses 8 segments per circle, to match that, we draw in a maximum     
		// of 45 degree segments. First we calculate how many segments are needed
		// for our arc.
		segs = Math.ceil(Math.abs(arc)/45);
		// Now calculate the sweep of each segment.
		segAngle = arc/segs;
		// The math requires radians rather than degrees. To convert from degrees
		// use the formula (degrees/180)*Math.PI to get radians.
		theta = -(segAngle/180)*Math.PI;
		// convert angle startAngle to radians
		angle = -(startAngle/180)*Math.PI;
		// draw the curve in segments no larger than 45 degrees.
		if (segs>0) {
			// draw a line from the center to the start of the curve
			ax = x+Math.cos(startAngle/180*Math.PI)*radius;
			ay = y+Math.sin(-startAngle/180*Math.PI)*yRadius;
			//mc.moveTo(ax, ay);
			//If we have more than 1 totalSlices, then we draw line to the center
			// Loop for drawing curve segments
			for (var i = 1; i<=segs; i++) {
				angle += theta;
				angleMid = angle-(theta/2);
				bx = x+Math.cos(angle)*radius;
				by = y+Math.sin(angle)*yRadius;
				cx = x+Math.cos(angleMid)*(radius/Math.cos(theta/2));
				cy = y+Math.sin(angleMid)*(yRadius/Math.cos(theta/2));
				mc.curveTo(cx, cy, bx, by);
			}
		}
	}
	/**
	* drawSlice method draws a single slice within the chart
	 * @param	mc				MovieClip in which we need the pie slice to be drawn
	 * @param	x				Starting X position of the slice
	 * @param	y				Starting Y position of the slice
	 * @param	radius			X outer Radius of the arc from the center
	 * @param	innerRadius		inner Radius of the arc from the center
	 * @param	startAngle		Starting angle of the slice
	 * @param	arcAngle		sweepangle of the arc
	 * @param	fillColor		filling color of the slice
	 * @param	alpha			alpha of the filling slice
	 * @param	borderThickness	border thickness at which we need the slice
	 * @param	borderColor		border color of the slice to be drawn
	 * @param	borderAlpha		border alpha
	 * @param	drawingColumn	Boolean value to indicate whether the slice for the circulated column or the circum circle
	 							Optimizing by not drawing a slice for 360 degree arcs
	 * @param	drawUpperArc	Boolean value to indicate whether we need upper arc to be drawn with border properties.
	 							This property is use to show border only for the last color range of the circulated column
	*/
	private function drawSlice(mc:MovieClip, x:Number, y:Number, radius:Number, innerRadius:Number, startAngle:Number, arcAngle:Number, fillColor:Number, alpha:Number, borderColor:String, borderThickness:Number, borderAlpha:Number, drawingColumn:Boolean, drawUpperArc:Boolean) {
		//This function draws a pie
		mc.lineStyle(borderThickness, parseInt(borderColor, 16), borderAlpha);
		mc.beginFill(fillColor, alpha);
		var ax = x+Math.cos(startAngle/180*Math.PI)*radius;
		var ay = y+Math.sin(-startAngle/180*Math.PI)*radius;
		mc.moveTo(ax, ay);
		//Only if we are drawing the circular column
		if(drawingColumn) {
			//Only if it is not the upper most arc of the column
			if(!drawUpperArc)  {
				mc.lineStyle(borderThickness, parseInt(borderColor, 16), 0);
			}
		}
		this.drawArc(mc, x, y, startAngle, arcAngle, radius, radius);
		//Only if we are drawing the circulated column slice 
		if(drawingColumn) {
			mc.lineStyle(borderThickness, parseInt(borderColor, 16), borderAlpha);
			ax = x+Math.cos((arcAngle+startAngle)/180*Math.PI)*innerRadius;
			ay = y+Math.sin(-(arcAngle+startAngle)/180*Math.PI)*innerRadius;
			mc.lineTo(ax, ay);
			mc.lineStyle(borderThickness, parseInt(borderColor, 16), 0);
			this.drawArc(mc, x, y, (startAngle+arcAngle), -arcAngle, innerRadius);
			mc.lineStyle(borderThickness, parseInt(borderColor, 16), borderAlpha);		
			ax = x+Math.cos(startAngle/180*Math.PI)*radius;
			ay = y+Math.sin(-startAngle/180*Math.PI)*radius;
			mc.lineTo(ax, ay);
		}
		mc.endFill();		
	}
	/** 
	 * drawOverlay method draws the overlay around the circle
	*/
	private function drawOverlay():Void {
		//This function renders the overlay
		//Loop Variable
		var i:Number;
		var j:Number;
		//Position variable
		var ax:Number, ay:Number;
		//First defined index radius
		var firstDataRadius:Number;
		//Depth of the pie
		var depth:Number = this.dm.getDepth("DATAOVERLAY");
		//Dataradius
		var dataRadius:Number= 0;
		//startAngle
		var startAngle:Number= 90;
		//Create the Overlay
		var mcOverlay:MovieClip = this.cMC.createEmptyMovieClip("Overlay", depth);
		//Number of overlay cannot be more than the number of primary groups
		if(this.numOverlayGroup > this.numGroup) {
			this.numOverlayGroup = this.numGroup;
		}
		//Draw the over lay
		for (i=1; i<=this.numOverlayGroup; i++) {
			//Now for every section
			for (j=1; j<=this.overlayGroup[i].numSection; j++) {
				//Overlay value cannot be more than the yMax or less than yMin
				if(this.overlayGroup[i].section[j].value > this.config.yMax ) { 
					this.overlayGroup[i].section[j].value = this.config.yMax;
				}
				if(this.overlayGroup[i].section[j].value < this.config.yMin ) { 
					this.overlayGroup[i].section[j].value = this.config.yMin;
				}
				//Calculate the distance from the centre
				dataRadius = this.getAxisPosition (this.overlayGroup[i].section[j].value, this.config.yMax, this.config.yMin, this.params.outerRadius-this.params.centerRadius, 0, true, 0)+this.params.centerRadius;
				//first draw the arc
				mcOverlay.lineStyle(this.params.overlayThickness, parseInt(this.params.overlayColor, 16), this.params.overlayAlpha);
				//Calculate the position
				ax = Math.cos(startAngle/180*Math.PI)*dataRadius;
				ay = Math.sin(-startAngle/180*Math.PI)*dataRadius;
				if(i == 1 && j == 1) {
					//Initially move to first section
					mcOverlay.moveTo(ax, ay);
					firstDataRadius  = dataRadius;
				} else {
					//Other times draw a line to next section
					mcOverlay.lineTo(ax, ay);
				}
				this.drawArc(mcOverlay, 0, 0, startAngle, this.group[i].sectionAngle, dataRadius, dataRadius);
				//Set the position
				mcOverlay._x = this.elements.circumCircle.x;
				mcOverlay._y = this.elements.circumCircle.y;
				startAngle += this.group[i].sectionAngle;
			}
		}
		//if we have maximum number of overlay
		//draw a line to first section
		if(this.numOverlayGroup == this.numGroup) {
			//Calculate the position
			ax = Math.cos(startAngle/180*Math.PI)*firstDataRadius;
			ay = Math.sin(-startAngle/180*Math.PI)*firstDataRadius;
			mcOverlay.lineTo(ax, ay);
			//Set the position
			mcOverlay._x = this.elements.circumCircle.x;
			mcOverlay._y = this.elements.circumCircle.y;
		}
		//Apply animation
		if (this.params.animation) {
			this.styleM.applyAnimation(mcOverlay, this.objects.OVERLAY, this.macro, mcOverlay._x, 0, mcOverlay._y, 0, 100, 100, 100, null);
		}
		//Clear sequence interval
		clearInterval(this.config.intervals.overLay);
	}
	/** 
	 * drawPlot method draws the actual circular columns inside the circum circle chart
	*/
	private function drawPlot():Void {
		//Loop Variable
		var i:Number;
		var j:Number;
		var k:Number;
		var depthCounter:Number = 0;
		//Create function storage containers for Delegate functions
		var fnRollOver:Function, fnClick:Function;
		//Depth of the pie
		var depth:Number = this.dm.getDepth("DATAPLOT");
		//Dataradius
		var dataRadius:Number= 0;
		var prevValue:Number= 0;
		var prevPos:Number= 0;
		var colorCode:String;
		//Create the Dataplot container
		var mcPlotCont:MovieClip = this.cMC.createEmptyMovieClip("PlotCont", depth);
		//This function renders the chart
		for (i=1; i<=this.numGroup; i++) {
			this.group[i].section[0] = new Object();
			//Store the Group Position as the start and end position 
			this.group[i].section[0].startX = this.group[i].startX;
			this.group[i].section[0].startY = this.group[i].startY;
			this.group[i].section[0].endX = this.group[i].endX;
			this.group[i].section[0].endY = this.group[i].endY;
			//Now for every section
			for (j=1; j<=this.group[i].numSection; j++,depthCounter++) {
				//Now for every dataplot create a MC within the container
				var mcPlot:MovieClip = mcPlotCont.createEmptyMovieClip("Plot_"+i+"_"+j, depthCounter);
				//Store the previous Value - so that we draw only the required slice
				prevValue = this.config.yMin;
				//initially it will be from the outer part of the center radius
				prevPos = this.params.centerRadius;
				//Depending upon the colorRange given we draw the DataPlots with different Colors
				for(k=0;k<this.numColorRange;k++) {
					if( this.colorRange[k].color=="" || this.colorRange[k].color== undefined) {
						colorCode = this.group[i].section[j].color;
					}
					else {
						colorCode = this.colorRange[k].color;
					}
					//Calculate the data radius for each section
					if((this.group[i].section[j].value) > (this.colorRange[k].value)) { 
						//Calculate the data radius
						dataRadius = this.getAxisPosition (this.colorRange[k].value, this.config.yMax, this.config.yMin, this.params.outerRadius-this.params.centerRadius, 0, true, 0);
						//reduce it with the last drawn slice - based on the colorRange
						dataRadius -= this.getAxisPosition (prevValue, this.config.yMax, this.config.yMin, this.params.outerRadius-this.params.centerRadius, 0, true, 0);
						//Finally draw the remain slice of the column
						this.drawSlice(mcPlot, 0, 0, dataRadius+prevPos, prevPos, this.group[i].startAngle+((j-1)*this.group[i].sectionAngle), this.group[i].sectionAngle, parseInt(colorCode, 16), this.colorRange[k].alpha, this.params.plotBorderColor, this.params.plotBorderThickness, this.params.plotBorderAlpha, true, false);			
						//Set the position
						mcPlot._x = this.elements.circumCircle.x;
						mcPlot._y = this.elements.circumCircle.y;
					}
					else {
						//If it is the slice not defined under the color range
						dataRadius = this.getAxisPosition (this.group[i].section[j].value, this.config.yMax, this.config.yMin, this.params.outerRadius-this.params.centerRadius, 0, true, 0);
						//Reduce it with the last drawn slice
						dataRadius -= this.getAxisPosition (prevValue, this.config.yMax, this.config.yMin, this.params.outerRadius-this.params.centerRadius, 0, true, 0);
						//Finally draw the slice
						this.drawSlice(mcPlot, 0, 0, dataRadius+prevPos, prevPos, this.group[i].startAngle+((j-1)*this.group[i].sectionAngle), this.group[i].sectionAngle, parseInt(colorCode, 16), this.colorRange[k].alpha, this.params.plotBorderColor, this.params.plotBorderThickness, this.params.plotBorderAlpha, true, true);			
						//Set the position
						mcPlot._x = this.elements.circumCircle.x;
						mcPlot._y = this.elements.circumCircle.y;
						//Store the last value of the column Slice
						prevValue = this.colorRange[k].value;
						break;
					}
					prevValue = this.colorRange[k].value;
					prevPos += dataRadius;
				}
				//Only when the colorRange is not define we draw the whole slice based on the GROUP COLOR
				if(this.numColorRange== 0 || prevValue<this.group[i].section[j].value) { 
					//Since there can be a case when a slice exceeds the color range value
					//In that case we take the remainder color of the slice as the GROUP COLOR
					//and is genralized with the slice whose colorRange is undefined
					dataRadius = this.getAxisPosition (this.group[i].section[j].value-prevValue, this.config.yMax, this.config.yMin, this.params.outerRadius-this.params.centerRadius, 0, true, 0);
					this.drawSlice(mcPlot, 0, 0, dataRadius+prevPos, prevPos, this.group[i].startAngle+((j-1)*this.group[i].sectionAngle), this.group[i].sectionAngle, parseInt(this.group[i].section[j].color, 16), this.group[i].section[j].alpha, this.params.plotBorderColor, this.params.plotBorderThickness, this.params.plotBorderAlpha, true, true);			
					//Set the position
					mcPlot._x = this.elements.circumCircle.x;
					mcPlot._y = this.elements.circumCircle.y;
				}
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(mcPlot, this.objects.DATAPLOT, this.macro, mcPlot._x, 0, mcPlot._y, 0, 100, 100, 100, null);
				}
				//Apply filters     
				this.styleM.applyFilters(mcPlot, this.objects.DATAPLOT);				
				//Event handlers for tool tip
				if (this.params.showToolTip){
					//Create Delegate for roll over function sliceOnRollOver
					fnRollOver = Delegate.create(this, sliceOnRollOver);
					//Set the index
					fnRollOver.grpIndex = i;
					fnRollOver.sectionIndex = j;
					//Assing the delegates to movie clip handler
					mcPlot.onRollOver = fnRollOver;
					//Set roll out and mouse move too.
					mcPlot.onRollOut = mcPlot.onReleaseOutside = Delegate.create(this, sliceOnRollOut);
					mcPlot.onMouseMove = Delegate.create(this, sliceOnMouseMove);
				}
				//Click handler for links - only if link for this column has been defined and click URL
				//has not been defined.
				if (this.group[i].section[j].link!="" && this.group[i].section[j].link!=undefined && this.params.clickURL==""){
					//Create delegate function
					fnClick = Delegate.create(this, sliceOnClick);
					//Set index
					fnClick.grpIndex = i;
					fnClick.sectionIndex = j;
					//Assign
					mcPlot.onRelease = fnClick;
				}
				else{
					//Do not use hand cursor
					mcPlot.useHandCursor = (this.params.clickURL=="")?false:true;
				}				
			}
		}
		//Clear sequence interval
		clearInterval(this.config.intervals.plot);
	}
	/** 
	 * drawSpikes method draws the Spikes inside the circum circle using the other
	 * methods of this class.
	*/
	private function drawSpikes():Void {
		//Loop Variable
		var i:Number;
		var j:Number;
		//Depth of the pie
		var depth:Number = this.dm.getDepth("SPIKES");
		//Create the MC for the Spike
		var mcSpikes:MovieClip = this.cMC.createEmptyMovieClip("Spikes", depth);
		//This function renders the Spikes
		for (i=1; i<=this.numGroup; i++) {
			//Set the line style of the Spikes
			mcSpikes.lineStyle(this.params.majorSpikeBorderThickness, parseInt(this.params.majorSpikeBorderColor, 16), this.params.majorSpikeBorderAlpha);			
			//Move to initial Position
			mcSpikes.moveTo(this.group[i].startX, this.group[i].startY);
			//Draw the Major Spike
			mcSpikes.lineTo(this.group[i].endX, this.group[i].endY);
			for (j=1; j<this.group[i].numSection; j++) {
				//For each section draw the minor Spikes
				mcSpikes.lineStyle(this.params.minorSpikeBorderThickness, parseInt(this.params.minorSpikeBorderColor, 16), this.params.minorSpikeBorderAlpha);
				mcSpikes.moveTo(this.group[i].section[j].startX, this.group[i].section[j].startY);
				mcSpikes.lineTo(this.group[i].section[j].endX, this.group[i].section[j].endY);
			}
		}
		//Apply animation
		if (this.params.animation) {
			this.styleM.applyAnimation(mcSpikes, this.objects.SPIKES, this.macro, this.elements.circumCircle.x, 0, this.elements.circumCircle.y, 0, 100, 100, 100, null);
		}
		//Clear sequence interval
		clearInterval(this.config.intervals.spikes);
	}
	/** 
	 * drawChart method draws the circum circles - center and the outer radius of the chart
	*/
	private function drawChart():Void {
		//This function renders the chart
		//Depth of the Outer Circle
		var depth:Number = this.dm.getDepth("CIRCUMOUTERCIRCLE");
		//Create the outer circle
		var mcCircle:MovieClip = this.cMC.createEmptyMovieClip("outerCircle", depth);
		for (var i:Number=1; i<=this.numGroup; i++) {
			this.drawSlice(mcCircle, 0, 0, this.params.outerRadius, 0, this.group[i].startAngle, this.config.groupAngle, parseInt(this.group[i].bgColor, 16), this.params.outerCircleFillAlpha, this.params.circleBorderColor, this.params.circleBorderThickness, this.params.circleBorderAlpha, true);
			//Set the position
			mcCircle._x = this.elements.circumCircle.x;
			mcCircle._y = this.elements.circumCircle.y;
		}
		//Apply animation
		if (this.params.animation) {
			this.styleM.applyAnimation(mcCircle, this.objects.CIRCUMCIRCLE, this.macro, this.elements.circumCircle.x, 0, this.elements.circumCircle.y, 0, 100, 100, 100, null);
		}
		//Apply filters     
		this.styleM.applyFilters(mcCircle, this.objects.CIRCUMCIRCLE);
		//Now draw the center circle
		depth = this.dm.getDepth("CIRCUMCENTERCIRCLE");		
		mcCircle = this.cMC.createEmptyMovieClip("CenterCircle", depth);
		this.drawSlice(mcCircle, 0, 0 , this.params.centerRadius, 0, 0, 360, parseInt(this.params.centerFillColor, 16), this.params.centerFillAlpha, this.params.circleBorderColor, this.params.circleBorderThickness, this.params.circleBorderAlpha, false);
		//Set the position
		mcCircle._x = this.elements.circumCircle.x;
		mcCircle._y = this.elements.circumCircle.y;
		//Apply animation
		if (this.params.animation) {
			this.styleM.applyAnimation(mcCircle, this.objects.CIRCUMCIRCLE, this.macro, this.elements.circumCircle.x, 0, this.elements.circumCircle.y, 0, 100, 100, 100, null);
		}
		//Apply filters     
		this.styleM.applyFilters(mcCircle, this.objects.CIRCUMCIRCLE);
		//Clear sequence interval
		clearInterval(this.config.intervals.circle);
	}
	/** 
	 * drawCircularDivLines method draws the divline in a circular fashion
	*/
	private function drawCircularDivLines():Void {
		//Loop Variable
		var i:Number;
		//Depth of the DivLine
		var depth:Number = this.dm.getDepth("DIVLINES");
		//Traverse through the list of colorRange
		for(i=0; i<this.numColorRange; i++) {
			//Create the MC for each Circular DivLine
			var mcDivLine:MovieClip = this.cMC.createEmptyMovieClip("DivLine_"+i, depth);
			var dataRadius:Number = this.getAxisPosition (this.colorRange[i].value, this.config.yMax, this.config.yMin, this.params.outerRadius-this.params.centerRadius, 0, true, 0);			
			//Call the arc function to draw the divlines
			this.drawDashedArc(mcDivLine, 0, 0, 0, 360, this.params.centerRadius+dataRadius, this.colorRange[i].borderThickness, this.colorRange[i].borderColor, this.colorRange[i].borderAlpha);	
			mcDivLine._x = this.elements.circumCircle.x;
			mcDivLine._y = this.elements.circumCircle.y;
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(mcDivLine, this.objects.DIVLINES, this.macro, this.elements.circumCircle.x, 0, this.elements.circumCircle.y, 0, 100, 100, 100, null);
			}
			//Increase the depth
			depth++;
		}
		
		//Clear sequence interval
		clearInterval(this.config.intervals.divLines);
	}
	/**
	 * calculatePoint method calculates a point from the given point with a specified distance.
	*/
	private function calculatePoint(fromX:Number, fromY:Number, distance:Number, angle:Number):Object {
		//This function calculates the x and y co-ordinates of a point at an angular distance of "distance,angle" from the base point fromX, fromY
		//Convert the angle into radians
		angle = angle*(Math.PI/180);
		var xPos:Number = fromX+(distance*Math.cos(angle));
		var yPos:Number = fromY-(distance*Math.sin(angle));
		return ({x:xPos, y:yPos});
	}
	/**
	 * setLabels method sets the label for each pie slice around the center point of pie
	*/
	private function setLabels():Void {
		//This method sets the labels for the chart
		//Get the depths for each label definition
		var grpDepth:Number = this.dm.getDepth("GROUPLABELS");
		var sectionDepth:Number = this.dm.getDepth("SECTIONLABELS");
		var centerLabelDepth:Number = this.dm.getDepth("CENTERLABEL");
		//Loop Variable
		var i:Number;
		var j:Number;
		//Get the style objects of the labels
		var grpLabelStyleObj:Object = this.styleM.getTextStyle(this.objects.GROUPLABELS);
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.SECTIONLABELS);
		//Create the center text field
		var labelObj:Object = createText(false, this.params.centerLabel, this.cMC, centerLabelDepth, this.elements.circumCircle.x, this.elements.circumCircle.y, 0, grpLabelStyleObj, false, 0, 0);
		//Apply filter
		this.styleM.applyFilters(labelObj.tf, this.objects.CENTERLABEL);
		//Apply animation
		if (this.params.animation) {
			this.styleM.applyAnimation(labelObj.tf, this.objects.CENTERLABEL, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
		}
		//Create the axis limits
		if(this.params.showAxisLimits) {
			//Only if required
			this.setAxisLimits();
		}
		//Set the rest of the labels
		for (i=1; i<=this.numGroup; i++, grpDepth++) {
			//Only if the group label is required
			if (this.group[i].showLabel) {
				if ((this.group[i].startAngle+this.config.groupAngle/2) > 90 && (this.group[i].startAngle+this.config.groupAngle/2) < 270)
				{
					grpLabelStyleObj.align = "right";
				} else 
				{
					if ((this.group[i].startAngle+this.config.groupAngle/2) == 90 || (this.group[i].startAngle+this.config.groupAngle/2) == 270)
					{
						grpLabelStyleObj.align = "center";
					} else 
					{
						grpLabelStyleObj.align = "left";
					}
				}
				grpLabelStyleObj.vAlign = "middle";
				//Create text field
				labelObj = createText(false, this.group[i].label, this.cMC, grpDepth, this.group[i].tfX, this.group[i].tfY, 0, grpLabelStyleObj, false, 0, 0);
				//Apply filter
				this.styleM.applyFilters(labelObj.tf, this.objects.GROUPLABELS);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(labelObj.tf, this.objects.GROUPLABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
				}
			}
			for (j=1; j<=this.group[i].numSection; j++, sectionDepth++) 
			{
				//Only if the section label is required
				if (this.group[i].section[j].showLabel) {
					//Calculate the alignment of the sectionLabel depending upon the position with respect to canvas in the chart
					if ((this.group[i].startAngle+(this.group[i].sectionAngle*j)) > 90 && (this.group[i].startAngle+(this.group[i].sectionAngle*j))  < 270)
					{
						labelStyleObj.align = "right";
					} else 
					{
						if ((this.group[i].startAngle+(this.group[i].sectionAngle*j)) == 90 || (this.group[i].startAngle+(this.group[i].sectionAngle*j)) == 270)
						{
							labelStyleObj.align = "center";
						} else 
						{
							labelStyleObj.align = "left";
						}
					
					}
					//Tweak to solve the label placement
					if(this.group[i].sectionAngle < 10) { 
						labelStyleObj.align = "center";
					}
					labelStyleObj.vAlign = "middle";
					//Create text field
					labelObj = createText(false, this.group[i].section[j].label, this.cMC, sectionDepth, this.group[i].section[j].tfX, this.group[i].section[j].tfY, 0, labelStyleObj, false, 0, 0);
					//Apply filter
					this.styleM.applyFilters(labelObj.tf, this.objects.SECTIONLABELS);
					//Apply animation
					if (this.params.animation) {
						this.styleM.applyAnimation(labelObj.tf, this.objects.SECTIONLABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
					}
				}
			}
		}
		//Clear the interval
		clearInterval(this.config.intervals.label);
	}
	/**
	 * setAxisLimits method sets the axis limits if required
	*/
	private function setAxisLimits():Void {
		//This method sets the labels for the chart
		var axisLabelDepth:Number = this.dm.getDepth("AXISLABELS");
		//Loop Variable
		var i:Number;
		var j:Number;
		//Get the reference to the style object
		//we apply the same style as the section labels
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.SECTIONLABELS);
		//Set the alignment to left of Spike
		labelStyleObj.align = "left";
		labelStyleObj.bgColor = this.params.axisLabelBgColor;
		//Create the lower end text field
		//Get the display value for the Min Value
		var yMinDispVal:String = formatNumber(this.config.yMin, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
		var labelObj:Object = createText(false, yMinDispVal, this.cMC, axisLabelDepth++, this.group[1].startX, this.group[1].startY, 0, labelStyleObj, false, 0, 0);
		//Apply filter
		this.styleM.applyFilters(labelObj.tf, this.objects.SECTIONLABELS);
		//Apply animation
		if (this.params.animation) {
			this.styleM.applyAnimation(labelObj.tf, this.objects.SECTIONLABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
		}
		//Create the upper end text field
		//Set the alignment to top
		labelStyleObj.vAlign = "top";
		//Create the object 
		//Get the display value for the Max Value
		var yMaxDispVal:String = formatNumber(this.config.yMax, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
		var labelObj:Object = createText(false, yMaxDispVal, this.cMC, axisLabelDepth++, this.group[1].endX, this.group[1].endY, 0, labelStyleObj, false, 0, 0);
		//Apply filter
		this.styleM.applyFilters(labelObj.tf, this.objects.SECTIONLABELS);
		//Apply animation
		if (this.params.animation) {
			this.styleM.applyAnimation(labelObj.tf, this.objects.SECTIONLABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
		}
		//reset the vetical Alignment for the circular div lines
		labelStyleObj.vAlign = "middle";
		//Set the rest of the labels
		for (i=0; i<this.numColorRange; i++, axisLabelDepth++) {
			//Get the position
			var dataRadius:Number = this.getAxisPosition (this.colorRange[i].value, this.config.yMax, this.config.yMin, this.params.outerRadius-this.params.centerRadius, 0, true, 0)+this.params.centerRadius;			
			//Create a new text field object
			var labelObj:Object = createText(false, this.colorRange[i].displayValue, this.cMC, axisLabelDepth, this.elements.circumCircle.x, this.elements.circumCircle.y-dataRadius, 0, labelStyleObj, false, 0, 0);
			//Apply filter
			this.styleM.applyFilters(labelObj.tf, this.objects.SECTIONLABELS);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(labelObj.tf, this.objects.SECTIONLABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
			}
		}
	}
	/**
	 * drawLegend method renders the legend
	*/
	private function drawLegend():Void {
		if (this.params.showLegend) {
			this.lgnd.render();
			//Apply filter
			this.styleM.applyFilters(lgndMC, this.objects.LEGEND);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(lgndMC, this.objects.LEGEND, this.macro, null, 0, null, 0, 100, null, null, null);
			}
		}
		//Clear interval 
		clearInterval(this.config.intervals.legend);
	}
	/**
	 * setContextMenu method is called only once initially
	 * to set right click behavior and optios.
	 */
	private function setContextMenu():Void {
		// ContextMenu instance is created
		var cmCustom:ContextMenu = new ContextMenu();
		// hide the default menu items
		cmCustom.hideBuiltInItems();
		if (this.params.showFCMenuItem){
			//Push "About FusionCharts" Menu Item
			cmCustom.customItems.push(super.returnAbtMenuItem());		
		}
		// applying the custom menu formed to the chart movieclip ... vital for multichart display in one swf 
		this.cMC.menu = cmCustom;
	}
	// -------------------- EVENT HANDLERS --------------------//
	/**
	 * sliceOnRollOver is the delegat-ed event handler method that'll
	 * be invoked when the user rolls his mouse over a circulated column. 
	 * This function is invoked, only if the tool tip is to be shown.
	 * Here, we show the tool tip.
	*/
	private function sliceOnRollOver():Void{
		//Index of slice is stored in arguments.caller.index
		var grpIndex:Number = arguments.caller.grpIndex;
		var sectionIndex:Number = arguments.caller.sectionIndex;
		//Set tool tip text
		this.tTip.setText(this.group[grpIndex].section[sectionIndex].toolText);
		//Show the tool tip
		this.tTip.show();
	}
	/**
	 * sliceOnRollOut method is invoked when the mouse rolls out
	 * of slice. We just hide the tool tip here.
	*/
	private function sliceOnRollOut():Void{
		//Hide the tool tip
		this.tTip.hide();
	}
	/*
	 * sliceOnMouseMove is called when the mouse position has changed
	 * over slice. We reposition the tool tip.
	*/
	private function sliceOnMouseMove():Void{
		//Reposition the tool tip only if it's in visible state
		if (this.tTip.visible()){
			this.tTip.rePosition();
		}
	}
	/**
	 * sliceOnClick is invoked when the user clicks on a slice (if link
	 * has been defined). We invoke the required link.														  
	*/
	private function sliceOnClick():Void{
		//Index of slice is stored in arguments.caller.index
		var grpIndex:Number = arguments.caller.grpIndex;
		var sectionIndex:Number = arguments.caller.sectionIndex;
		//Invoke the link
		super.invokeLink(this.group[grpIndex].section[sectionIndex].link);
	}	
	/**
	 * reInit method re-initializes the chart. This method is basically called
	 * when the user changes chart data through JavaScript. In that case, we need
	 * to re-initialize the chart, set new XML data and again render.
	*/
	public function reInit():Void {
		//Invoke super class's reInit
		super.reInit();
		//Now initialize things that are pertinent to this class
		//but not defined in super class.
		//Initialize the arrays
		this.group = new Array();
		this.colorRange = new Array();
		this.overlayGroup= new Array();
		//Counter
		this.numGroup = 0;
		this.numSection = 0;
		this.numColorRange = 0;
		this.numOverlayGroup =0;
	}
	/**
	 * remove method removes the chart by clearing the chart movie clip
	 * and removing any listeners. However, the logger still stays on.
	 * To remove the logger too, you need to call destroy method of chart.
	*/
	public function remove():Void {
		//Call super remove
		super.remove();
	}
	/**
	 * destroy method destroys the chart by removing the chart movie clip,
	 * logger movie clip, and removing any listeners. 
	*/
	public function destroy():Void {
		//Destroy chart
		super.destroy();
		//Now destroy anything additional pertinent to this chart, but
		//not included as a part of parent Chart class.
	}
}
