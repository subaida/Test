 /**
* @class CandleStickChart
* @author InfoSoft Global (P) Ltd. www.InfoSoftGlobal.com
* @version 3.0
*
* Copyright (C) InfoSoft Global Pvt. Ltd. 2005-2006
*
* CandleStickChart chart extends the Chart class to render a
* Candle-stick Chart.
*/
//Import Chart class
import com.fusioncharts.core.Chart;
//Parent SingleYAxis2DVerticalChart Class
import com.fusioncharts.core.SingleYAxis2DVerticalChart;
//Error class
import com.fusioncharts.helper.FCError;
//Import Logger Class
import com.fusioncharts.helper.Logger;
//Style Object
import com.fusioncharts.core.StyleObject;
//Delegate
import mx.utils.Delegate;
//Legend Class
import com.fusioncharts.helper.Legend;
//Extensions
import com.fusioncharts.extensions.ColorExt;
import com.fusioncharts.extensions.StringExt;
import com.fusioncharts.extensions.MathExt;
import com.fusioncharts.extensions.DrawingExt;
//Column 2D
import com.fusioncharts.core.chartobjects.Column2D;
class com.fusioncharts.core.charts.CandleStickChart extends Chart 
{
	//Version number (if different from super Chart class)
	//private var _version:String = "3.0.0";
	//Instance variables
	//List of chart objects
	private var _arrObjects : Array;
	private var xmlData : XML;
	//----- Data containers -----
	//Array to store x-axis categories (labels)
	private var categories : Array;
	//To store data
	private var data : Array;
	//Storage for Price div lines
	private var pDivLines : Array;
	//Storage for Volume div lines
	private var vDivLines : Array;
	//Array to store trend sets
	private var trendset : Array;
	//Trend lines - Normal
	private var trendLines : Array;
	//Trend lines - Vertical
	private var vTrendLines : Array;
	//----- Indexers ------
	//Number of data sets
	private var num : Number;
	//Number of categories
	private var numCat : Number;
	//Number of trend sets
	private var numTS : Number;
	private var numTSData : Number = 0;
	//numTrendLines stores the number of trend lines (normal - horizontal)
	private var numTrendLines : Number = 0;
	//Number of trend lines below - (normal - horizontal)
	private var numTrendLinesBelow : Number = 0;
	//Number of vertical trend lines
	private var numVTrendLines : Number = 0;
	//---- Movie Clip Containers -----
	//Reference to legend component of chart
	private var lgnd : Legend;
	//Reference to legend movie clip
	private var lgndMC : MovieClip;
	//Number of items to be added to legend
	private var numLegendItems : Number = 0;
	/**
	* Constructor function. We invoke the super class'
	* constructor and then set the objects for this chart.
	*/
	function CandleStickChart (targetMC : MovieClip, depth : Number, width : Number, height : Number, x : Number, y : Number, debugMode : Boolean, lang : String, scaleMode:String, registerWithJS:Boolean, DOMId:String)
	{
		//Invoke the super class constructor
		super (targetMC, depth, width, height, x, y, debugMode, lang, scaleMode, registerWithJS, DOMId);
		//Log additional information to debugger
		//We log version from this class, so that if this class version
		//is different, we can log it
		this.log ("Version", _version, Logger.LEVEL.INFO);
		this.log ("Chart Type", "Candle Stick Chart", Logger.LEVEL.INFO);
		//List Chart Objects and set them
		_arrObjects = new Array ("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "PYAXISNAME", "VYAXISNAME", "DIVLINES", "YAXISVALUES", "HGRID", "DATALABELS", "DATAVALUES", "TRENDLINES", "TRENDVALUES", "VTRENDLINES", "VTRENDVALUES", "PRICEPLOT", "VOLUMEPLOT", "TRENDSETS", "ANCHORS", "TOOLTIP", "VLINES", "LEGEND");
		super.setChartObjects (_arrObjects);
		//Initialize the containers for chart
		this.categories = new Array ();
		this.data = new Array ();
		this.pDivLines = new Array ();
		this.vDivLines = new Array ();
		this.trendset = new Array ();
		this.trendLines = new Array ();
		this.vTrendLines = new Array ();
		//Initialize the indexes
		this.num = 0;
		this.numCat = 0;
		this.numTS = 0;
		this.numTSData = 0;
		this.numTrendLines = 0;
		this.numTrendLinesBelow = 0;
		this.numVTrendLines = 0;
		this.numLegendItems = 0;
		//Whether to show volume part - by default false
		this.config.showVolume = false;
	}
	/**
	* render method is the single call method that does the rendering of chart:
	* - Parsing XML
	* - Calculating values and co-ordinates
	* - Visual layout and rendering
	* - Event handling
	*/
	public function render () : Void 
	{
		//Parse the XML Data document
		this.parseXML ();
		//Now, if the number of data elements is 0, we show pertinent
		//error.
		if (this.num == 0)
		{
			tfAppMsg = this.renderAppMessage (_global.getAppMessage ("NODATA", this.lang));
			//Add a message to log.
			this.log ("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn't any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI>", Logger.LEVEL.ERROR);
			//Expose rendered method
			this.exposeChartRendered();
		} else 
		{
			//Detect number scales
			this.detectNumberScales ();
			//Calculate the axis limits
			this.calculateAxisLimits ();
			//Calculate div lines for price
			this.calcPDivs ();
			//Calculate div lines for volume
			this.calcVDivs ();
			//Set Style defaults
			this.setStyleDefaults ();
			//Validate trend lines
			this.validateTrendLines ();
			//Allot the depths for various charts objects now
			this.allotDepths ();
			//Calculate canvas co-ordinates
			this.calcCanvasCoords ();
			//Calculate Points
			this.calculatePoints ();
			//Calculate trend line positions
			this.calcTrendLinePos ();
			//Feed macro values
			this.feedMacros ();
			//Remove application message
			this.removeAppMessage (this.tfAppMsg);
			//Set tool tip parameter
			this.setToolTipParam ();
			//-----Start Visual Rendering Now------//
			//Draw background
			this.drawBackground ();
			//Set click handler
			this.drawClickURLHandler ();
			//Load background SWF
			this.loadBgSWF ();
			//Draw roll over band
			this.drawRollOverBand ();
			//Update timer
			this.timeElapsed = (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.BACKGROUND) : 0;
			//Draw canvas
			this.config.intervals.PCanvas = setInterval (Delegate.create (this, drawPCanvas) , this.timeElapsed);
			this.config.intervals.VCanvas = setInterval (Delegate.create (this, drawVCanvas) , this.timeElapsed);
			//Draw headers
			this.config.intervals.headers = setInterval (Delegate.create (this, drawHeaders) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.CANVAS, this.objects.CAPTION, this.objects.SUBCAPTION, this.objects.PYAXISNAME, this.objects.VYAXISNAME) : 0;
			//Draw div lines
			this.config.intervals.pDivLines = setInterval (Delegate.create (this, drawPDivLines) , this.timeElapsed);
			this.config.intervals.vDivLines = setInterval (Delegate.create (this, drawVDivLines) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.DIVLINES, this.objects.YAXISVALUES) : 0;
			//Horizontal grids
			this.config.intervals.pHGrid = setInterval (Delegate.create (this, drawPHGrid) , this.timeElapsed);
			this.config.intervals.vHGrid = setInterval (Delegate.create (this, drawVHGrid) , this.timeElapsed);
			//Draw vertical div lines
			this.config.intervals.vLine = setInterval (Delegate.create (this, drawVLines) , this.timeElapsed);
			//Draw trend lines
			this.config.intervals.vTrend = setInterval (Delegate.create (this, drawVTrendLines) , this.timeElapsed);
			this.config.intervals.trend = setInterval (Delegate.create (this, drawTrendLines) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.HRGID, this.objects.VLINES, this.objects.TRENDLINES, this.objects.VTRENDLINES, this.objects.TRENDVALUES, this.objects.VTRENDVALUES) : 0;
			//Draw labels
			this.config.intervals.labels = setInterval (Delegate.create (this, drawLabels) , this.timeElapsed);
			//Draw price chart
			this.config.intervals.pricePlot = setInterval (Delegate.create (this, drawPriceChart) , this.timeElapsed);
			this.config.intervals.volumePlot = setInterval (Delegate.create (this, drawVolumeChart) , this.timeElapsed);
			//Legend
			this.config.intervals.legend = setInterval (Delegate.create (this, drawLegend) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation && (this.num > 1)) ? this.styleM.getMaxAnimationTime (this.objects.DATALABELS, this.objects.PRICEPLOT, this.objects.VOLUMEPLOT, this.objects.LEGEND) : 0;
			//Data Values
			this.config.intervals.dataValues = setInterval (Delegate.create (this, drawValues) , this.timeElapsed);
			//Anchors
			this.config.intervals.anchors = setInterval (Delegate.create (this, drawAnchors) , this.timeElapsed);
			//Trend sets
			this.config.intervals.trendSets = setInterval (Delegate.create (this, drawTrendSets) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation && (this.numTS >= 1)) ? this.styleM.getMaxAnimationTime (this.objects.TRENDSETS) : 0;
			//Dispatch event that the chart has loaded.
			this.config.intervals.renderedEvent = setInterval(Delegate.create(this, exposeChartRendered) , this.timeElapsed);
			//Render context menu
			//We do not put context menu interval as we need the menu to appear
			//right from start of the play.
			this.setContextMenu ();
		}
	}
	// ------------------- DATA OBJECT CONTAINERS ---------------------------//
	/**
	* returnDataAsObject method creates an object out of the parameters
	* passed to this method. The idea is that we store each data point
	* as an object with multiple (flexible) properties. So, we do not
	* use a predefined class structure. Instead we use a generic object.
	*	@param	open		Opening price.
	*	@param	close		Closing price.
	*	@param	high		High price.
	*	@param	low			Low price.
	*	@param	volume		Volume of transaction
	*	@param	x			X-index (for horizontal position)
	*	@param	color		Fill color
	*	@param	borderColor	Border Color (for candle, line, bar).
	*	@param	alpha		Alpha of the data.
	*	@param	toolText	Tool tip text (if specified).
	*	@param	link		Link (if any) for the data.
	*	@param	valueText	Text which will be displayed as value.
	*	@param	isDashed	Flag whether the line would be dashed.
	*	@return			An object encapsulating all these properies.
	*/
	private function returnDataAsObject (open : Number, close : Number, high : Number, low : Number, volume : Number, x : Number, color : String, borderColor : String, alpha : Number, toolText : String, link : String, valueText : String, isDashed : Boolean) : Object 
	{
		//Create a container
		var dataObj : Object = new Object ();
		//Store the values
		dataObj.open = open;
		dataObj.close = close;
		dataObj.high = high;
		dataObj.low = low;
		dataObj.volume = volume;
		dataObj.xv = x;
		dataObj.color = color;
		dataObj.borderColor = borderColor;
		dataObj.alpha = alpha;
		dataObj.toolText = toolText;
		dataObj.link = link;
		dataObj.valueText = valueText;
		dataObj.dashed = isDashed;
		//Position parameters
		//X & Y Position of data point
		dataObj.x = 0;
		dataObj.y = 0;
		//X & Y Position of value tb
		dataObj.valTBX = 0;
		dataObj.valTBY = 0;
		//Return the container
		return dataObj;
	}
	/**
	* returnDataAsCat method returns data of a <category> element as
	* an object
	*	@param	label		Label of the category.
	*	@param	xv			X-value of the category
	*	@param	showLabel	Whether to show the label of this category.
	*	@param	toolText	Tool-text for the category
	*	@param	showLine	Whether to show vertical line
	*	@param	lineDashed	Whether vertical line is dashed
	*	@return			A container object with the given properties
	*/
	private function returnDataAsCat (label : String, xv : Number, showLabel : Number, toolText : String, showLine : Boolean, lineDashed : Boolean) : Object 
	{
		//Create container object
		var catObj : Object = new Object ();
		catObj.label = label;
		catObj.xv = xv;
		catObj.showLabel = ((showLabel == 1) && (label != undefined) && (label != null) && (label != "")) ? true : false;
		catObj.toolText = toolText;
		catObj.showLine = showLine;
		catObj.lineDashed = lineDashed;
		//X and Y Position
		catObj.x = 0;
		catObj.y = 0;
		//Valid
		catObj.isValid = true;
		//Return container
		return catObj;
	}
	/**
	* returnDataAsTrendSetObject method creates an object out of the parameters
	* passed to this method. The idea is that we store each trend-set point
	* as an object with multiple (flexible) properties. So, we do not
	* use a predefined class structure. Instead we use a generic object.
	*	@param	x		x-Index
	*	@param	value	Value
	*	@return			An object encapsulating all these properies.
	*/
	private function returnDataAsTrendSetObject (x : Number, value : Number) : Object 
	{
		//Create a container
		var tsObj : Object = new Object ();
		//Store the values
		tsObj.xv = x;
		tsObj.value = value;
		//Position parameters
		//X & Y Position of data point
		tsObj.x = 0;
		tsObj.y = 0;
		//Return the container
		return tsObj;
	}
	/**
	* returnDataAsTrendObj method takes in functional parameters, and creates
	* an object to represent the trend line as a unified object.
	*	@param	startValue		Starting value of the trend line.
	*	@param	endValue		End value of the trend line (if different from start)
	*	@param	displayValue	Display value for the trend (if custom).
	*	@param	color			Color of the trend line
	*	@param	thickness		Thickness (in pixels) of line
	*	@param	alpha			Alpha of the line
	*	@param	isTrendZone		Flag to control whether to show trend as a line or block(zone)
	*	@param	showOnTop		Whether to show trend over data plot or under it.
	*	@param	isDashed		Whether the line would appear dashed.
	*	@param	dashLen			Length of dash (if isDashed selected)
	*	@param	dashGap			Gap of dash (if isDashed selected)
	*	@return				An object encapsulating these values.
	*/
	private function returnDataAsTrendObj (startValue : Number, endValue : Number, displayValue : String, color : String, thickness : Number, alpha : Number, isTrendZone : Boolean, showOnTop : Boolean, isDashed : Boolean, dashLen : Number, dashGap : Number) : Object 
	{
		//Create an object that will be returned.
		var rtnObj : Object = new Array ();
		//Store parameters as object properties
		rtnObj.startValue = startValue;
		rtnObj.endValue = endValue;
		rtnObj.displayValue = displayValue;
		rtnObj.color = color;
		rtnObj.thickness = thickness;
		rtnObj.alpha = alpha;
		rtnObj.isTrendZone = isTrendZone;
		rtnObj.showOnTop = showOnTop;
		rtnObj.isDashed = isDashed;
		rtnObj.dashLen = dashLen;
		rtnObj.dashGap = dashGap;
		//Flag whether trend line is proper
		rtnObj.isValid = true;
		//Return
		return rtnObj;
	}
	/**
	* returnDataAsPDivLine method returns the data provided to the method
	* as a div line object for the primary axis.
	*	@param	value	Value of div line
	*	@return		An object with the parameters of div line
	*/
	private function returnDataAsPDivLine (value : Number) : Object 
	{
		//Create a new object
		var divLineObject = new Object ();
		divLineObject.value = value;
		//Display value
		//Now, if numbers are to be restricted to decimal places,
		if (this.config.formatPDivDecimals)
		{
			//Round off the div line value to this.params.yAxisValueDecimals precision
			divLineObject.displayValue = this.formatNumber (value, this.params.formatNumber, this.params.yAxisValueDecimals, false, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
		} else 
		{
			//Set decimal places as 10, so that none of the decimals get stripped off
			divLineObject.displayValue = this.formatNumber (value, this.params.formatNumber, 10, false, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
		}
		//Flag to show values
		divLineObject.showValue = true;
		return divLineObject;
	}
	/**
	* returnDataAsVDivLine method returns the data provided to the method
	* as a div line object for the volume axis.
	*	@param	value	Value of div line
	*	@return		An object with the parameters of div line
	*/
	private function returnDataAsVDivLine (value : Number) : Object 
	{
		//Create a new object
		var divLineObject = new Object ();
		divLineObject.value = value;
		//Display value
		//Now, if numbers are to be restricted to decimal places,
		if (this.config.formatVDivDecimals == true)
		{
			//Round off the div line value to this.params.yAxisValueDecimals precision
			divLineObject.displayValue = this.formatNumber (value, this.params.vFormatNumber, this.params.vYAxisValueDecimals, false, this.params.vFormatNumberScale, this.params.vDefaultNumberScale, this.config.vnsv, this.config.vnsu, this.params.vNumberPrefix, this.params.vNumberSuffix);
		} else 
		{
			//Set decimal places as 10, so that none of the decimals get stripped off
			divLineObject.displayValue = this.formatNumber (value, this.params.vFormatNumber, 10, false, this.params.vFormatNumberScale, this.params.vDefaultNumberScale, this.config.vnsv, this.config.vnsu, this.params.vNumberPrefix, this.params.vNumberSuffix);
		}
		//Flag to show values
		divLineObject.showValue = true;
		return divLineObject;
	}
	//-------------------------------------------------------------------------------//
	/**
	* parseXML method parses the XML data, sets defaults and validates
	* the attributes before storing them to data storage objects.
	*/
	private function parseXML () : Void 
	{
		//Get the element nodes
		var arrDocElement : Array = this.xmlData.childNodes;
		//Loop variable
		var i : Number;
		var j : Number;
		var k : Number;
		//Look for <graph> element
		for (i = 0; i < arrDocElement.length; i ++)
		{
			//If it's a <graph> element, proceed.
			//Do case in-sensitive mathcing by changing to upper case
			if (arrDocElement [i].nodeName.toUpperCase () == "GRAPH" || arrDocElement [i].nodeName.toUpperCase () == "CHART")
			{
				//Extract attributes of <graph> element
				this.parseAttributes (arrDocElement [i]);
				//Now, get the child nodes - first level nodes
				//Level 1 nodes can be - CATEGORIES, DATA, TRENDSET, TRENDLINES, STYLES etc.
				var arrLevel1Nodes : Array = arrDocElement [i].childNodes;
				var setNode : XMLNode;
				//Iterate through all level 1 nodes.
				for (j = 0; j < arrLevel1Nodes.length; j ++)
				{
					if (arrLevel1Nodes [j].nodeName.toUpperCase () == "CATEGORIES")
					{
						//Categories Node.
						var categoriesNode : XMLNode = arrLevel1Nodes [j];
						//Convert attributes to array
						var categoriesAtt : Array = this.getAttributesArray (categoriesNode);
						//Extract attributes of this node.
						this.params.catFont = getFV (categoriesAtt ["font"] , this.params.outCnvBaseFont);
						this.params.catFontSize = getFN (categoriesAtt ["fontsize"] , this.params.outCnvBaseFontSize);
						this.params.catFontColor = formatColor (getFV (categoriesAtt ["fontcolor"] , this.params.outCnvBaseFontColor));
						//Category vertical lines
						this.params.catVerticalLineColor = formatColor (getFV (categoriesAtt ["verticallinecolor"] , this.defColors.get2DDivLineColor (this.params.palette)));
						this.params.catVerticalLineThickness = getFN (categoriesAtt ["verticallinethickness"] , 1);
						this.params.catVerticalLineAlpha = getFN (categoriesAtt ["verticallinealpha"] , this.defColors.get2DDivLineAlpha (this.params.palette));
						this.params.catVerticalLineDashed = toBoolean (getFN (categoriesAtt ["verticallinedashed"] , 0));
						this.params.catVerticalLineDashLen = getFN (categoriesAtt ["verticallinedashlen"] , 4);
						this.params.catVerticalLineDashGap = getFN (categoriesAtt ["verticallinedashgap"] , 2);
						//Get reference to child node.
						var arrLevel2Nodes : Array = arrLevel1Nodes [j].childNodes;
						//Iterate through all child-nodes of CATEGORIES element
						//and search for CATEGORY or VLINE node
						for (k = 0; k < arrLevel2Nodes.length; k ++)
						{
							if (arrLevel2Nodes [k].nodeName.toUpperCase () == "CATEGORY")
							{
								//Category Node.
								//Update counter
								this.numCat ++;
								//Extract attributes
								var categoryNode : XMLNode = arrLevel2Nodes [k];
								var categoryAtt : Array = this.getAttributesArray (categoryNode);
								//Category label.
								var catLabel : String = getFV (categoryAtt ["label"] , categoryAtt ["name"] , "");
								//X-value
								var catX : Number = this.getSetValue (categoryAtt ["x"]);
								var catShowLabel : Number = getFN (categoryAtt ["showlabel"] , categoryAtt ["showname"] , this.params.showLabels);
								var catToolText : String = getFV (categoryAtt ["tooltext"] , categoryAtt ["hovertext"] , catLabel);
								var catShowLine : Boolean = toBoolean (getFN (categoryAtt ["showverticalline"] , categoryAtt ["sl"] , 1));
								var catLineDashed : Boolean = toBoolean (getFN (categoryAtt ["linedashed"] , this.params.catVerticalLineDashed));
								//If x value for category has has not been provided, we won't add it
								if (isNaN (catX))
								{
									this.numCat --;
								} else 
								{
									//Store it in data container.
									this.categories [this.numCat] = this.returnDataAsCat (catLabel, catX, catShowLabel, catToolText, catShowLine, catLineDashed);
								}
							}
						}
					} else if (arrLevel1Nodes [j].nodeName.toUpperCase () == "DATASET")
					{
						//Data set nodes sub-nodes contain the actual data
						var dataNodes : Array = arrLevel1Nodes [j].childNodes;
						//Now iterate through dataNodes to find <SET> nodes
						for (k = 0; k < dataNodes.length; k ++)
						{
							//If it's set node
							if (dataNodes [k].nodeName.toUpperCase () == "SET")
							{
								//Increase count
								this.num ++;
								//Get attributes array
								var setAtts : Array = this.getAttributesArray (dataNodes [k]);
								//Get all attributes
								var setOpen : Number = getFN (setAtts ["open"] , - 1);
								var setClose : Number = getFN (setAtts ["close"] , - 1);
								var setHigh : Number = getFN (setAtts ["high"] , - 1);
								var setLow : Number = getFN (setAtts ["low"] , - 1);
								var setVolume : Number = getFN (setAtts ["volume"] , - 1);
								//Now, if volume is not -1, we update our this.config.showVolume flag
								if ( ! this.config.showVolume && setVolume != - 1)
								{
									this.config.showVolume = true;
								}
								//X-position of set
								var setX : Number = getFN (setAtts ["x"] , this.num);
								//Color and border color
								var setColor : String = setAtts ["color"];
								//Border color applies to candle border, bar plot, line plot.
								var setBorderColor : String = setAtts ["bordercolor"];
								//Alpha
								var setAlpha : Number = getFN (setAtts ["alpha"] , 100);
								var setToolText : String = setAtts ["tooltext"];
								var setLink : String = getFV (setAtts ["link"] , "");
								var setValueText : String = getFV (setAtts ["valuetext"] , "");
								var setDashed : Boolean = toBoolean (getFN (setAtts ["dashed"] , 0));
								//Now, we set proper colors
								//Now, if close is higher than open i.e., bull, we'll use bullBorderColor & bullFillColor as the defaults
								if (setClose >= setOpen)
								{
									setColor = formatColor (getFV (setColor, this.params.bullFillColor));
									setBorderColor = formatColor (getFV (setBorderColor, this.params.bullBorderColor));
								} else 
								{
									//Else, we'll use bearBorderColor & bearFillColor
									setColor = formatColor (getFV (setColor, this.params.bearFillColor));
									setBorderColor = formatColor (getFV (setBorderColor, this.params.bearBorderColor));
								}
								//Flag whether we should add this data
								var addData : Boolean = true;
								//Checks for valid data.
								//1. If data is to be plotted as Candle or Bar and we do not have any of the 4 values, void it.
								//2. If data is to be plotted as Line with closing as plot, and if missing, void it
								//3. If data is to be plotted as Line with opening as plot, and if missing, void it
								if (this.params.plotPriceAs == "CANDLESTICK" || this.params.plotPriceAs == "BAR")
								{
									if (setOpen == - 1 || setClose == - 1 || setHigh == - 1 || setClose == - 1)
									{
										addData = false;
									}
								}
								if ((this.params.plotPriceAs == "LINE") && (this.params.plotClosingPrice == true) && (setClose == - 1))
								{
									addData = false;
								}
								if ((this.params.plotPriceAs == "LINE") && (this.params.plotClosingPrice == false) && (setOpen == - 1))
								{
									addData = false;
								}
								//Now, based on flag, add data
								if (addData)
								{
									this.data [this.num] = this.returnDataAsObject (setOpen, setClose, setHigh, setLow, setVolume, setX, setColor, setBorderColor, setAlpha, setToolText, setLink, setValueText, setDashed);
								}else
								{
									//Decrement index
									this.num --;
								}
							}
						}
					} else if (arrLevel1Nodes [j].nodeName.toUpperCase () == "TRENDSET")
					{
						//Increment
						this.numTS ++;
						//trendset node.
						var trendSetNode : XMLNode = arrLevel1Nodes [j];
						//Get attributes array
						var tsAtts : Array = this.getAttributesArray (trendSetNode);
						//Create storage object in dataset array
						this.trendset [this.numTS] = new Object ();
						//Store attributes
						this.trendset [this.numTS].name = getFV (tsAtts ["name"] , "");
						this.trendset [this.numTS].color = formatColor (getFV (tsAtts ["color"] , this.params.trendSetColor, this.defColors.getColor ()));
						this.trendset [this.numTS].alpha = getFN (tsAtts ["alpha"] , this.params.trendSetAlpha);
						this.trendset [this.numTS].thickness = getFN (tsAtts ["thickness"] , this.params.trendSetThickness);
						//Whether to include this trend-set in legend?
						this.trendset [this.numTS].includeInLegend = toBoolean (getFN (tsAtts ["includeinlegend"] , 1));
						//Increase count of legend items, if this is to be included in legend
						if (this.trendset [this.numTS].includeInLegend)
						{
							numLegendItems ++;
						}
						//Line dash properties
						this.trendset [this.numTS].dashed = toBoolean (getFN (tsAtts ["dashed"] , this.params.trendSetDashed));
						//Dash Properties
						this.trendset [this.numTS].dashLen = getFN (tsAtts ["dashlen"] , this.params.trendSetDashLen);
						this.trendset [this.numTS].dashGap = getFN (tsAtts ["dashgap"] , this.params.trendSetDashGap);
						//Create data array under it.
						this.trendset [this.numTS].data = new Array ();
						//Get reference to child node.
						var arrLevel2Nodes : Array = arrLevel1Nodes [j].childNodes;
						//Iterate through all child-nodes of TRENDSET element
						//and search for SET node
						//Counter
						var setCount : Number = 0;
						for (k = 0; k < arrLevel2Nodes.length; k ++)
						{
							if (arrLevel2Nodes [k].nodeName.toUpperCase () == "SET")
							{
								//Set Node. So extract the data.
								//Update counter
								setCount ++;
								numTSData ++;
								//Get reference to node.
								setNode = arrLevel2Nodes [k];
								//Get attributes
								var atts : Array;
								atts = this.getAttributesArray (setNode);
								//Now, get value.
								var setValue : Number = this.getSetValue (atts ["value"]);
								//X-Position
								var setX : Number = this.getSetValue (atts ["x"]);
								//If both are numbers, only then add
								if (isNaN (setValue) || isNaN (setX))
								{
									setCount --;
								}else
								{
									//Add
									this.trendset [this.numTS].data [setCount] = this.returnDataAsTrendSetObject (setX, setValue);
								}
							}
							//Store number of items in this trend-set in the array
							this.trendset [this.numTS].num = setCount;
						}
					} else if (arrLevel1Nodes [j].nodeName.toUpperCase () == "STYLES")
					{
						//Styles Node - extract child nodes
						var arrStyleNodes : Array = arrLevel1Nodes [j].childNodes;
						//Parse the style nodes to extract style information
						super.parseStyleXML (arrStyleNodes);
					} else if (arrLevel1Nodes [j].nodeName.toUpperCase () == "TRENDLINES")
					{
						//Trend lines node
						var arrTrendNodes : Array = arrLevel1Nodes [j].childNodes;
						//Parse the trend line nodes
						this.parseHTrendLineXML (arrTrendNodes);
					} else if (arrLevel1Nodes [j].nodeName.toUpperCase () == "VTRENDLINES")
					{
						//Vertical Trend lines node
						var arrTrendNodes : Array = arrLevel1Nodes [j].childNodes;
						//Parse the trend line nodes
						this.parseVTrendLineXML (arrTrendNodes);
					}
				}
			}
		}
		//Delete all temporary objects used for parsing XML Data document
		delete setNode;
		delete arrDocElement;
		delete arrLevel1Nodes;
		delete arrLevel2Nodes;
	}
	/**
	* parseAttributes method parses the attributes and stores them in
	* chart storage objects.
	* Starting ActionScript 2, the parsing of XML attributes have also
	* become case-sensitive. However, prior versions of FusionCharts
	* supported case-insensitive attributes. So we need to parse all
	* attributes as case-insensitive to maintain backward compatibility.
	* To do so, we first extract all attributes from XML, convert it into
	* lower case and then store it in an array. Later, we extract value from
	* this array.
	* @param	graphElement	XML Node containing the <graph> element
	*							and it's attributes
	*/
	private function parseAttributes (graphElement : XMLNode) : Void 
	{
		//Array to store the attributes
		var atts : Array = this.getAttributesArray (graphElement);
		//NOW IT'S VERY NECCESARY THAT WHEN WE REFERENCE THIS ARRAY
		//TO GET AN ATTRIBUTE VALUE, WE SHOULD PROVIDE THE ATTRIBUTE
		//NAME IN LOWER CASE. ELSE, UNDEFINED VALUE WOULD SHOW UP.
		//Extract attributes pertinent to this chart
		//Which palette to use?
		this.params.palette = getFN (atts ["palette"] , 3)
		//Whether to show about FusionCharts Menu Item - by default set to on
		this.params.showFCMenuItem = toBoolean(getFN (atts ["showfcmenuitem"] , 1));
		// ---------- PADDING AND SPACING RELATED ATTRIBUTES ----------- //
		//captionPadding = Space between caption/subcaption and canvas start Y
		this.params.captionPadding = getFN (atts ["captionpadding"] , 10);
		//Canvas Padding is the space between the canvas left/right border
		//and first/last data point
		this.params.canvasPadding = getFN (atts ["canvaspadding"] , 10);
		//Padding for y-axis name - from left
		this.params.yAxisNamePadding = getFN (atts ["yaxisnamepadding"] , 5);
		//Y-Axis Values padding - Horizontal space between the axis edge and
		//y-axis values or trend line values (on left/right side).
		this.params.yAxisValuesPadding = getFN (atts ["yaxisvaluespadding"] , 2);
		//Label padding - Vertical space between the labels and canvas end position
		this.params.labelPadding = getFN (atts ["labelpadding"] , atts ["labelspadding"] , 3);
		//Value padding - vertical space between the anchors and start of value textboxes
		this.params.valuePadding = getFN (atts ["valuepadding"] , 2);
		//Padding of legend from bottom side of canvas
		this.params.legendPadding = getFN (atts ["legendpadding"] , 12);
		//Percentage space on the plot area
		this.params.plotSpacePercent = getFN (atts ["plotspacepercent"] , 30);
		//Chart Margins - Empty space at the 4 sides
		this.params.chartLeftMargin = getFN (atts ["chartleftmargin"] , 15);
		this.params.chartRightMargin = getFN (atts ["chartrightmargin"] , 15);
		this.params.chartTopMargin = getFN (atts ["charttopmargin"] , 15);
		this.params.chartBottomMargin = getFN (atts ["chartbottommargin"] , 15);
		// -------------------------- HEADERS ------------------------- //
		//Chart Caption and sub Caption
		this.params.caption = getFV (atts ["caption"] , "");
		this.params.subCaption = getFV (atts ["subcaption"] , "");
		//Y Axis Names
		//Y-axis name for price
		this.params.PYAxisName = getFV (atts ["pyaxisname"] , "");
		//Y-axis name for volume
		this.params.VYAxisName = getFV (atts ["vyaxisname"] , "");
		//Adaptive yMin - if set to true, the y min will be based on the values
		//provided. It won't be set to 0 in case of all positive values
		this.params.setAdaptiveYMin = toBoolean (getFN (atts ["setadaptiveymin"] , 1));
		// --------------------- CONFIGURATION ------------------------- //
		//The upper and lower limits of y and x axis
		//Price y-axis
		this.params.PYAxisMinValue = atts ["pyaxisminvalue"];
		this.params.PYAxisMaxValue = atts ["pyaxismaxvalue"];
		//Volume y-axis
		this.params.VYAxisMinValue = getFN (atts ["vyaxisminvalue"] , 0);
		this.params.VYAxisMaxValue = atts ["vyaxismaxvalue"];
		//X-axis
		this.params.xAxisMinValue = atts ["xaxisminvalue"];
		this.params.xAxisMaxValue = atts ["xaxismaxvalue"];
		//Whether to set animation for entire chart.
		this.params.animation = toBoolean (getFN (atts ["animation"] , 1));
		//Whether to set the default chart animation
		this.params.defaultAnimation = toBoolean (getFN (atts ["defaultanimation"] , 1));
		//Configuration to set whether to show the labels
		this.params.showLabels = toBoolean (getFN (atts ["showlabels"] , atts ["shownames"] , 1));
		//Label Display Mode - WRAP, STAGGER, ROTATE or NONE
		this.params.labelDisplay = getFV (atts ["labeldisplay"] , "WRAP");
		//Remove spaces and capitalize
		this.params.labelDisplay = StringExt.removeSpaces (this.params.labelDisplay);
		this.params.labelDisplay = this.params.labelDisplay.toUpperCase ();
		//Option to show vertical x-axis labels
		this.params.rotateLabels = getFV (atts ["rotatelabels"] , atts ["rotatenames"]);
		//Whether to rotate values
		this.params.rotateValues = getFV (atts ["rotatevalues"] , 0);
		//Whether to slant label (if rotated)
		this.params.slantLabels = toBoolean (getFN (atts ["slantlabels"] , atts ["slantlabel"] , 0));
		//Angle of rotation based on slanting
		this.config.labelAngle = (this.params.slantLabels == true) ? 315 : 270;
		//If rotateLabels has been explicitly specified, we assign ROTATE value to this.params.labelDisplay
		this.params.labelDisplay = (this.params.rotateLabels == "1") ? "ROTATE" : this.params.labelDisplay;
		//Step value for labels - i.e., show all labels or skip every x label
		this.params.labelStep = int (getFN (atts ["labelstep"] , 1));
		//Cannot be less than 1
		this.params.labelStep = (this.params.labelStep < 1) ? 1 : this.params.labelStep;
		//Number of stagger lines
		this.params.staggerLines = int (getFN (atts ["staggerlines"] , 2));
		//Cannot be less than 2
		this.params.staggerLines = (this.params.staggerLines < 2) ? 2 : this.params.staggerLines;
		//Option to show/hide y-axis values
		this.params.showYAxisValues = getFN (atts ["showyaxisvalues"] , atts ["showyaxisvalue"] , 1);
		//Y-axis value step- i.e., show all y-axis or skip every x(th) value
		this.params.yAxisValuesStep = int (getFN (atts ["yaxisvaluesstep"] , atts ["yaxisvaluestep"] , 1));
		//Cannot be less than 1
		this.params.yAxisValuesStep = (this.params.yAxisValuesStep < 1) ? 1 : this.params.yAxisValuesStep;
		//Whether to automatically adjust div lines
		this.params.adjustDiv = toBoolean (getFN (atts ["adjustdiv"] , 1));
		//Whether to rotate y-axis name
		this.params.rotateYAxisName = toBoolean (getFN (atts ["rotateyaxisname"] , 1));
		//Max width to be alloted to y-axis name - No defaults, as it's calculated later.
		this.params.yAxisNameWidth = atts ["yaxisnamewidth"];
		//Click URL
		this.params.clickURL = getFV (atts ["clickurl"] , "");
		//Candle properties
		//What should price information be plotted as - CANDLESTICK, LINE or BAR
		this.params.plotPriceAs = getFV (atts ["plotpriceas"] , "CANDLESTICK");
		//Capitalize
		this.params.plotPriceAs = this.params.plotPriceAs.toUpperCase ();
		//Check for valid values
		if (this.params.plotPriceAs != "CANDLESTICK" && this.params.plotPriceAs != "LINE" && this.params.plotPriceAs != "BAR")
		{
			//Set default to candle-stick
			this.params.plotPriceAs = "CANDLESTICK"
		}
		//If the data is to be plotted as line, do we use closing price?
		this.params.plotClosingPrice = toBoolean (getFN (atts ["plotclosingprice"] , 1));
		//If volume data is provided, whether to show volume chart
		this.params.showVolumeChart = toBoolean (getFN (atts ["showvolumechart"] , 1));
		//Volume Chart Height Percent
		this.params.volumeHeightPercent = getFN (atts ["volumeheightpercent"] , 40);
		//Cannot be <20 or >80
		if (this.params.volumeHeightPercent < 20 || this.params.volumeHeightPercent > 80)
		{
			this.params.volumeHeightPercent = 40;
		}
		//Maximum plot width
		this.params.maxPlotWidth = getFN (atts ["maxplotwidth"] , 30);
		// ------------------------- COSMETICS -----------------------------//
		//Background properties - Gradient
		this.params.bgColor = getFV (atts ["bgcolor"] , this.defColors.get2DBgColor (this.params.palette));
		this.params.bgAlpha = getFV (atts ["bgalpha"] , this.defColors.get2DBgAlpha (this.params.palette));
		this.params.bgRatio = getFV (atts ["bgratio"] , this.defColors.get2DBgRatio (this.params.palette));
		this.params.bgAngle = getFV (atts ["bgangle"] , this.defColors.get2DBgAngle (this.params.palette));
		//Border Properties of chart
		this.params.showBorder = toBoolean (getFN (atts ["showborder"] , 1));
		this.params.borderColor = formatColor (getFV (atts ["bordercolor"] , this.defColors.get2DBorderColor (this.params.palette)));
		this.params.borderThickness = getFN (atts ["borderthickness"] , 1);
		this.params.borderAlpha = getFN (atts ["borderalpha"] , this.defColors.get2DBorderAlpha (this.params.palette));
		//Background swf
		this.params.bgSWF = getFV (atts ["bgswf"] , "");
		this.params.bgSWFAlpha = getFN (atts ["bgswfalpha"] , 100);
		//Canvas background properties - Gradient
		this.params.canvasBgColor = getFV (atts ["canvasbgcolor"] , this.defColors.get2DCanvasBgColor (this.params.palette));
		this.params.canvasBgAlpha = getFV (atts ["canvasbgalpha"] , this.defColors.get2DCanvasBgAlpha (this.params.palette));
		this.params.canvasBgRatio = getFV (atts ["canvasbgratio"] , this.defColors.get2DCanvasBgRatio (this.params.palette));
		this.params.canvasBgAngle = getFV (atts ["canvasbgangle"] , this.defColors.get2DCanvasBgAngle (this.params.palette));
		//Canvas Border properties
		this.params.canvasBorderColor = formatColor (getFV (atts ["canvasbordercolor"] , this.defColors.get2DCanvasBorderColor (this.params.palette)));
		this.params.canvasBorderThickness = getFN (atts ["canvasborderthickness"] , 1);
		this.params.canvasBorderAlpha = getFN (atts ["canvasborderalpha"] , this.defColors.get2DCanvasBorderAlpha (this.params.palette));
		//Candle stick properties.
		//Bear fill and border color - (Close lower than open)
		this.params.bearBorderColor = formatColor (getFV (atts ["bearbordercolor"] , "B90000"));
		this.params.bearFillColor = formatColor (getFV (atts ["bearfillcolor"] , "B90000"));
		//Bull fill and border color - Close higher than open
		this.params.bullBorderColor = formatColor (getFV (atts ["bullbordercolor"] , this.defColors.get2DCanvasBorderColor (this.params.palette)));
		this.params.bullFillColor = formatColor (getFV (atts ["bullfillcolor"] , "FFFFFF"));
		//Line Properties - Serves as line for bar & line and border for candle stick
		this.params.plotLineThickness = getFN (atts ["plotlinethickness"] , (this.params.plotPriceAs == "LINE" || this.params.plotPriceAs == "BAR") ?2 : 1);
		this.params.plotLineAlpha = getFN (atts ["plotlinealpha"] , 100);
		this.params.plotLineDashLen = getFN (atts ["plotlinedashlen"] , 5);
		this.params.plotLineDashGap = getFN (atts ["plotlinedashgap"] , 4);
		//VPlotBorder is border properties for the volume chart.
		this.params.showVPlotBorder = toBoolean (getFN (atts ["showvplotborder"] , 1));
		//this.params.vPlotBorderColor = formatColor(getFV(atts["vplotbordercolor"], this.defColors.get2DCanvasBorderColor(this.params.palette)));
		this.params.vPlotBorderThickness = getFN (atts ["vplotborderthickness"] , 1);
		this.params.vPlotBorderAlpha = getFN (atts ["vplotborderalpha"] , (this.params.showVPlotBorder == true) ?100 : 0);
		//Trend-sets default properties
		this.params.trendSetColor = formatColor (getFV (atts ["trendsetcolor"] , "666666"));
		this.params.trendSetAlpha = getFN (atts ["trendsetalpha"] , 100);
		this.params.trendSetThickness = getFN (atts ["trendsetthickness"] , 2);
		this.params.trendSetDashed = getFN (atts ["trendsetdashed"] , 0);
		this.params.trendSetDashLen = getFN (atts ["trendsetdashlen"] , 4);
		this.params.trendSetDashGap = getFN (atts ["trendsetdashgap"] , 4);
		//Roll-over band properties
		this.params.rollOverBandColor = formatColor (getFV (atts ["rolloverbandcolor"] , this.defColors.get2DAltHGridColor (this.params.palette)));
		this.params.rollOverBandAlpha = getFN (atts ["rolloverbandalpha"] , this.defColors.get2DAltHGridAlpha (this.params.palette));
		//Legend properties
		this.params.showLegend = toBoolean (getFN (atts ["showlegend"] , 1));
		this.params.legendBorderColor = formatColor (getFV (atts ["legendbordercolor"] , this.defColors.get2DLegendBorderColor (this.params.palette)));
		this.params.legendCaption = getFV(atts ["legendcaption"] , "");
		this.params.legendMarkerCircle = toBoolean(getFN(atts ["legendmarkercircle"] , 0));
		this.params.legendBorderThickness = getFN (atts ["legendborderthickness"] , 1);
		this.params.legendBorderAlpha = getFN (atts ["legendborderalpha"] , 100);
		this.params.legendBgColor = getFV (atts ["legendbgcolor"] , this.defColors.get2DLegendBgColor (this.params.palette));
		this.params.legendBgAlpha = getFN (atts ["legendbgalpha"] , 100);
		this.params.legendShadow = toBoolean (getFN (atts ["legendshadow"] , 1));
		this.params.legendAllowDrag = toBoolean (getFN (atts ["legendallowdrag"] , 0));
		this.params.legendScrollBgColor = formatColor (getFV (atts ["legendscrollbgcolor"] , "CCCCCC"));
		this.params.legendScrollBarColor = formatColor (getFV (atts ["legendscrollbarcolor"] , this.params.legendBorderColor));
		this.params.legendScrollBtnColor = formatColor (getFV (atts ["legendscrollbtncolor"] , this.params.legendBorderColor));
		//Horizontal grid division Lines
		//Necessarily need a default value for numPDivLines.
		this.params.numPDivLines = getFN (atts ["numpdivlines"] , 4);
		this.params.numVDivLines = getFN (atts ["numvdivlines"] , 4);
		//Horizontal grid division Lines - color, thickness & alpha
		this.params.divLineColor = formatColor (getFV (atts ["divlinecolor"] , this.defColors.get2DDivLineColor (this.params.palette)));
		this.params.divLineThickness = getFN (atts ["divlinethickness"] , 1);
		this.params.divLineAlpha = getFN (atts ["divlinealpha"] , this.defColors.get2DDivLineAlpha (this.params.palette));
		this.params.divLineIsDashed = toBoolean (getFN (atts ["divlineisdashed"] , 1));
		this.params.divLineDashLen = getFN (atts ["divlinedashlen"] , 4);
		this.params.divLineDashGap = getFN (atts ["divlinedashgap"] , 2);
		//Alternating grid colors
		this.params.showAlternateHGridColor = toBoolean (getFN (atts ["showalternatehgridcolor"] , 1));
		this.params.alternateHGridColor = formatColor (getFV (atts ["alternatehgridcolor"] , this.defColors.get2DAltHGridColor (this.params.palette)));
		this.params.alternateHGridAlpha = getFN (atts ["alternatehgridalpha"] , this.defColors.get2DAltHGridAlpha (this.params.palette));
		this.params.showAlternateVGridColor = toBoolean (getFN (atts ["showalternatevgridcolor"] , 0));
		this.params.alternateVGridColor = formatColor (getFV (atts ["alternatevgridcolor"] , this.defColors.get2DAltVGridColor (this.params.palette)));
		this.params.alternateVGridAlpha = getFN (atts ["alternatevgridalpha"] , this.defColors.get2DAltVGridAlpha (this.params.palette));
		//Shadow properties
		this.params.showShadow = toBoolean (getFN (atts ["showshadow"] , 1));
		//Anchor Properties
		this.params.drawAnchors = toBoolean (getFN (atts ["drawanchors"] , atts ["showanchors"] , 1));
		this.params.anchorSides = getFN (atts ["anchorsides"] , 10);
		this.params.anchorRadius = getFN (atts ["anchorradius"] , 3);
		this.params.anchorBorderColor = atts ["anchorbordercolor"];
		this.params.anchorBorderThickness = getFN (atts ["anchorborderthickness"] , 1);
		this.params.anchorBgColor = formatColor (getFV (atts ["anchorbgcolor"] , this.defColors.get2DAnchorBgColor (this.params.palette)));
		this.params.anchorAlpha = getFN (atts ["anchoralpha"] , 0);
		this.params.anchorBgAlpha = getFN (atts ["anchorbgalpha"] , this.params.anchorAlpha);
		//Tool Tip - Show/Hide, Background Color, Border Color, Separator Character
		this.params.showToolTip = toBoolean (getFN (atts ["showtooltip"] , atts ["showhovercap"] , 1));
		this.params.toolTipBgColor = formatColor (getFV (atts ["tooltipbgcolor"] , atts ["hovercapbgcolor"] , atts ["hovercapbg"] , this.defColors.get2DToolTipBgColor (this.params.palette)));
		this.params.toolTipBorderColor = formatColor (getFV (atts ["tooltipbordercolor"] , atts ["hovercapbordercolor"] , atts ["hovercapborder"] , this.defColors.get2DToolTipBorderColor (this.params.palette)));
		this.params.toolTipSepChar = getFV (atts ["tooltipsepchar"] , atts ["hovercapsepchar"] , ", ");
		//Font Properties
		this.params.baseFont = getFV (atts ["basefont"] , "Verdana");
		this.params.baseFontSize = getFN (atts ["basefontsize"] , 10);
		this.params.baseFontColor = formatColor (getFV (atts ["basefontcolor"] , this.defColors.get2DBaseFontColor (this.params.palette)));
		this.params.outCnvBaseFont = getFV (atts ["outcnvbasefont"] , this.params.baseFont);
		this.params.outCnvBaseFontSize = getFN (atts ["outcnvbasefontsize"] , this.params.baseFontSize);
		this.params.outCnvBaseFontColor = formatColor (getFV (atts ["outcnvbasefontcolor"] , this.params.baseFontColor));
		// ------------------------- NUMBER FORMATTING ---------------------------- //
		// ---------------- Common ------------------ //
		//Decimal Separator Character
		this.params.decimalSeparator = getFV (atts ["decimalseparator"] , ".");
		//Thousand Separator Character
		this.params.thousandSeparator = getFV (atts ["thousandseparator"] , ",");
		//Input decimal separator and thousand separator. In some european countries,
		//commas are used as decimal separators and dots as thousand separators. In XML,
		//if the user specifies such values, it will give a error while converting to
		//number. So, we accept the input decimal and thousand separator from user, so that
		//we can covert it accordingly into the required format.
		this.params.inDecimalSeparator = getFV (atts ["indecimalseparator"] , "");
		this.params.inThousandSeparator = getFV (atts ["inthousandseparator"] , "");
		//y-Axis values decimals
		this.params.yAxisValueDecimals = getFV (atts ["yaxisvaluedecimals"] , atts ["yaxisvaluesdecimals"] , atts ["divlinedecimalprecision"] , atts ["limitsdecimalprecision"]);
		//Force Decimal Padding
		this.params.forceDecimals = toBoolean (getFN (atts ["forcedecimals"] , 0));
		// -------------------------- For Price ------------------------------//
		//Option whether the format the number (using Commas)
		this.params.formatNumber = toBoolean (getFN (atts ["formatnumber"] , 1));
		//Option to format number scale
		this.params.formatNumberScale = toBoolean (getFN (atts ["formatnumberscale"] , 0));
		//Number Scales
		this.params.defaultNumberScale = getFV (atts ["defaultnumberscale"] , "");
		this.params.numberScaleUnit = getFV (atts ["numberscaleunit"] , "K,M");
		this.params.numberScaleValue = getFV (atts ["numberscalevalue"] , "1000,1000");
		//Number prefix and suffix
		this.params.numberPrefix = getFV (atts ["numberprefix"] , "");
		this.params.numberSuffix = getFV (atts ["numbersuffix"] , "");
		//Decimal Precision (number of decimal places to be rounded to)
		this.params.decimals = getFV (atts ["decimals"] , atts ["decimalprecision"] , 2);
		// -------------------- For Volume -----------------------//
		//Option whether the format the number (using Commas)
		this.params.vFormatNumber = toBoolean (getFN (atts ["vformatnumber"] , 1));
		//Option to format number scale
		this.params.vFormatNumberScale = toBoolean (getFN (atts ["vformatnumberscale"] , 1));
		//Number Scales
		this.params.vDefaultNumberScale = getFV (atts ["vdefaultnumberscale"] , "");
		this.params.vNumberScaleUnit = getFV (atts ["vnumberscaleunit"] , "K,M");
		this.params.vNumberScaleValue = getFV (atts ["vnumberscalevalue"] , "1000,1000");
		//Number prefix and suffix
		this.params.vNumberPrefix = getFV (atts ["vnumberprefix"] , "");
		this.params.vNumberSuffix = getFV (atts ["vnumbersuffix"] , "");
		//Decimal Precision (number of decimal places to be rounded to)
		this.params.vDecimals = getFV (atts ["vdecimals"]);
		// ---------------------- Image Saving ------------------------------//
		this.params.imageSave = toBoolean (getFN (atts ["imagesave"] , 0));
		this.params.imageSaveURL = getFV (atts ["imagesaveurl"] , "");
		this.params.imageSaveDialogColor = formatColor (getFV (atts ["imagesavedialogcolor"] , "E2E2E2"));
		this.params.imageSaveDialogFontColor = formatColor (getFV (atts ["imagesavedialogfontcolor"] , "666666"));
	}
	/**
	* parseHTrendLineXML method parses the XML node containing horizontal trend line nodes
	* and then stores it in local objects.
	*	@param		arrTrendLineNodes		Array containing Trend LINE nodes.
	*	@return							Nothing.
	*/
	private function parseHTrendLineXML (arrTrendLineNodes : Array) : Void 
	{
		//Define variables for local use
		var startValue : Number, endValue : Number, displayValue : String;
		var color : String, thickness : Number, alpha : Number;
		var isTrendZone : Boolean, showOnTop : Boolean, isDashed : Boolean;
		var dashLen : Number, dashGap : Number
		//Loop variable
		var i : Number;
		//Iterate through all nodes in array
		for (i = 0; i <= arrTrendLineNodes.length; i ++)
		{
			//Check if LINE node
			if (arrTrendLineNodes [i].nodeName.toUpperCase () == "LINE")
			{
				//Update count
				numTrendLines ++;
				//Store the node reference
				var lineNode : XMLNode = arrTrendLineNodes [i];
				//Get attributes array
				var lineAttr : Array = this.getAttributesArray (lineNode);
				//Extract and store attributes
				startValue = getFN (this.getSetValue(lineAttr ["startvalue"]) , this.getSetValue(lineAttr ["value"]));
				endValue = getFN (this.getSetValue(lineAttr ["endvalue"]) , startValue);
				displayValue = lineAttr ["displayvalue"];
				color = String (formatColor (getFV (lineAttr ["color"] , "333333")));
				thickness = getFN (lineAttr ["thickness"] , 1);
				isTrendZone = toBoolean (Number (getFV (lineAttr ["istrendzone"] , 0)));
				alpha = getFN (lineAttr ["alpha"] , (isTrendZone == true) ? 40 : 99);
				showOnTop = toBoolean (getFN (lineAttr ["showontop"] , 0));
				isDashed = toBoolean (getFN (lineAttr ["dashed"] , 0));
				dashLen = getFN (lineAttr ["dashlen"] , 5);
				dashGap = getFN (lineAttr ["dashgap"] , 2);
				//Create trend line object
				this.trendLines [numTrendLines] = returnDataAsTrendObj (startValue, endValue, displayValue, color, thickness, alpha, isTrendZone, showOnTop, isDashed, dashLen, dashGap);
				//Update numTrendLinesBelow
				numTrendLinesBelow = (showOnTop == false) ? ( ++ numTrendLinesBelow) : numTrendLinesBelow;
			}
		}
	}
	/**
	* parseVTrendLineXML method parses the XML node containing vertical trend line nodes
	* and then stores it in local objects.
	*	@param		arrTrendLineNodes		Array containing Trend LINE nodes.
	*	@return							Nothing.
	*/
	private function parseVTrendLineXML (arrTrendLineNodes : Array) : Void 
	{
		//Define variables for local use
		var startValue : Number, endValue : Number, displayValue : String;
		var color : String, thickness : Number, alpha : Number;
		var isTrendZone : Boolean, showOnTop : Boolean, isDashed : Boolean;
		var dashLen : Number, dashGap : Number
		//Loop variable
		var i : Number;
		//Iterate through all nodes in array
		for (i = 0; i <= arrTrendLineNodes.length; i ++)
		{
			//Check if LINE node
			if (arrTrendLineNodes [i].nodeName.toUpperCase () == "LINE")
			{
				//Update count
				numVTrendLines ++;
				//Store the node reference
				var lineNode : XMLNode = arrTrendLineNodes [i];
				//Get attributes array
				var lineAttr : Array = this.getAttributesArray (lineNode);
				//Extract and store attributes
				startValue = getFN (this.getSetValue(lineAttr ["startvalue"]) , this.getSetValue(lineAttr ["value"]));
				endValue = getFN (this.getSetValue(lineAttr ["endvalue"]) , startValue);
				displayValue = lineAttr ["displayvalue"];
				color = String (formatColor (getFV (lineAttr ["color"] , "333333")));
				thickness = getFN (lineAttr ["thickness"] , 1);
				isTrendZone = toBoolean (Number (getFV (lineAttr ["istrendzone"] , 1)));
				alpha = getFN (lineAttr ["alpha"] , (isTrendZone == true) ? 40 : 99);
				showOnTop = false;
				isDashed = toBoolean (getFN (lineAttr ["dashed"] , 0));
				dashLen = getFN (lineAttr ["dashlen"] , 5);
				dashGap = getFN (lineAttr ["dashgap"] , 2);
				//Create trend line object
				this.vTrendLines [numVTrendLines] = returnDataAsTrendObj (startValue, endValue, displayValue, color, thickness, alpha, isTrendZone, showOnTop, isDashed, dashLen, dashGap);
			}
		}
	}
	/**
	* OVER-RIDING Chart Class's detectNumberScales method.
	* detectNumberScales method detects whether we've been provided
	* with number scales. If yes, we parse them. This method needs to
	* called before calculatePoints, as calculatePoint methods calls
	* formatNumber, which in turn uses number scales.
	* Here, we also adjust the numberPrefix and numberSuffix if they're
	* still present in encoded form. Like, if the user has specified encoded
	* numberPrefix and Suffix in dataURL mode, it will show the direct value.
	* Therefore, we need to change them into proper characters.
	*	@return	Nothing.
	*/
	private function detectNumberScales () : Void
	{
		var i : Number;
		//We set this.config.numberScaleDefined to true. The condition satisfies
		//every time. But, we keep formatNumberScale (Primary and secondary) to reflect
		//actual value, and we'll pass that only to formatNumber function - as flag to
		//whether to format number scale or not for that value.
		this.config.numberScaleDefined = true;
		//Check if either has been defined
		if ( ! (this.params.numberScaleValue.length == 0 || this.params.numberScaleUnit.length == 0 || this.params.formatNumberScale == false))
		{
			//Set flag to true
			this.params.formatNumberScale = true;
			//Split the data into arrays
			this.config.nsv = new Array ();
			this.config.nsu = new Array ();
			//Parse the number scale value
			this.config.nsv = this.params.numberScaleValue.split (",");
			//Convert all number scale values to numbers as they're
			//currently in string format.
			for (i = 0; i < this.config.nsv.length; i ++)
			{
				this.config.nsv [i] = Number (this.config.nsv [i]);
				//If any of numbers are NaN, set defined to false
				if (isNaN (this.config.nsv [i]))
				{
					this.params.formatNumberScale = false;
				}
			}
			//Parse the number scale unit
			this.config.nsu = this.params.numberScaleUnit.split (",");
			//If the length of two arrays do not match, set defined to false.
			if (this.config.nsu.length != this.config.nsv.length)
			{
				this.params.formatNumberScale = false;
			}
		}
		//Do the same for secondary axis
		if ( ! (this.params.vNumberScaleValue.length == 0 || this.params.vNumberScaleUnit.length == 0 || this.params.vFormatNumberScale == false))
		{
			//Set flag to true
			this.params.vFormatNumberScale = true;
			//Split the data into arrays
			this.config.vnsv = new Array ();
			this.config.vnsu = new Array ();
			//Parse the number scale value
			this.config.vnsv = this.params.vNumberScaleValue.split (",");
			//Convert all number scale values to numbers as they're
			//currently in string format.
			for (i = 0; i < this.config.vnsv.length; i ++)
			{
				this.config.vnsv [i] = Number (this.config.vnsv [i]);
				//If any of numbers are NaN, set defined to false
				if (isNaN (this.config.vnsv [i]))
				{
					this.params.vFormatNumberScale = false;
				}
			}
			//Parse the number scale unit
			this.config.vnsu = this.params.vNumberScaleUnit.split (",");
			//If the length of two arrays do not match, set defined to false.
			if (this.config.vnsu.length != this.config.vnsv.length)
			{
				this.params.vFormatNumberScale = false;
			}
		}
		//Convert numberPrefix and numberSuffix now.
		this.params.numberPrefix = super.unescapeChar (this.params.numberPrefix);
		this.params.numberSuffix = super.unescapeChar (this.params.numberSuffix);
		this.params.vNumberPrefix = super.unescapeChar (this.params.vNumberPrefix);
		this.params.vNumberSuffix = super.unescapeChar (this.params.vNumberSuffix);
		//Always keep to a decimal precision of minimum 2 if the number
		//scale is defined, as we've just checked for decimal precision of numbers
		//and not the numbers against number scale. So, even if they do not need yield a
		//decimal, we keep 2, as we do not force decimals on numbers.
		if (this.params.formatNumberScale == true || this.params.vFormatNumberScale == true)
		{
			maxDecimals = (maxDecimals > 2) ?maxDecimals : 2;
		}
		//Get proper value for decimals
		this.params.decimals = Number (getFV (this.params.decimals, maxDecimals));
		this.params.vDecimals = Number (getFV (this.params.vDecimals, maxDecimals));
		//Decimal Precision cannot be less than 0 - so adjust it
		if (this.params.decimals < 0)
		{
			this.params.decimals = 0;
		}
		if (this.params.vDecimals < 0)
		{
			this.params.vDecimals = 0;
		}
	}
	/**
	* getAxisPosition method gets the pixel position of a particular
	* point on the axis based on its value.
	*	@param	value			Numerical value for which we need pixel axis position
	*	@param	upperLimit		Numerical upper limit for that axis
	*	@param	lowerLimit		Numerical lower limit for that axis
	*	@param	startAxisPos	Pixel start position for that axis
	*	@param	endAxisPos		Pixel end position for that axis
	*	@param	isYAxis			Flag indicating whether it's y axis
	*	@param	xPadding		Padding at left and right sides in case of a x-axis
	*	@return				The pixel position of the value on the given axis.
	*/
	private function getAxisPosition (value : Number, upperLimit : Number, lowerLimit : Number, startAxisPos : Number, endAxisPos : Number, isYAxis : Boolean, xPadding : Number) : Number 
	{
		//Define variables to be used locally
		var numericalInterval : Number;
		var axisLength : Number;
		var relativePosition : Number;
		var absolutePosition : Number;
		//Get the numerical difference between the limits
		numericalInterval = (upperLimit - lowerLimit);
		numericalInterval = (numericalInterval==0)?1:numericalInterval;
		if (isYAxis)
		{
			//If it's y axis, the co-ordinates are opposite in Flash
			axisLength = (endAxisPos - startAxisPos);
			relativePosition = (axisLength / numericalInterval) * (value - lowerLimit);
			//If it's a y axis co-ordinate then go according to Flash's co-ordinate system
			//(y decreases as we go upwards)
			absolutePosition = endAxisPos - relativePosition;
		} else 
		{
			axisLength = (endAxisPos - startAxisPos) - (2 * xPadding);
			relativePosition = (axisLength / numericalInterval) * (value - lowerLimit);
			//The normal x-axis rule - increases as we go right
			absolutePosition = startAxisPos + xPadding + relativePosition;
		}
		return absolutePosition;
	}
	/**
	* getMaxXDataValue method gets the maximum x-axis data value present
	* in the data. We check both data and categories.
	*	@return	The maximum value present in the data provided.
	*/
	private function getMaxXDataValue () : Number 
	{
		var maxValue : Number;
		var i : Number, j : Number;
		//Initialize maxValue to that of first data
		maxValue = this.data [1].xv;
		for (i = 1; i <= this.num; i ++)
		{
			maxValue = Math.max (maxValue, this.data [i].xv);
		}
		//Now, check in categories
		for (i = 1; i <= this.numCat; i ++)
		{
			maxValue = Math.max (maxValue, this.categories [i].xv);
		}
		return maxValue;
	}
	/**
	* getMinXDataValue method gets the minimum x-axis data value present
	* in the data. We check both data and categories.
	*	@return	The minimum value present in the data provided.
	*/
	private function getMinXDataValue () : Number 
	{
		var minValue : Number;
		var i : Number, j : Number;
		//Initialize minValue to that of first data
		minValue = this.data [1].xv;
		for (i = 1; i <= this.num; i ++)
		{
			minValue = Math.min (minValue, this.data [i].xv);
		}
		//Now, check in categories
		for (i = 1; i <= this.numCat; i ++)
		{
			minValue = Math.min (minValue, this.categories [i].xv);
		}
		return minValue;
	}
	/**
	* getMaxPrice method gets the maximum price data value present
	* in the data. We iterate through each data <set> and trend <set>
	*	@return	The maximum price present in the data provided.
	*/
	private function getMaxPrice () : Number 
	{
		var maxValue : Number;
		var currentMax : Number;
		var i : Number, j : Number;
		//Initially set max value to that of first data's open
		maxValue = this.data [1].open;
		for (i = 1; i <= this.num; i ++)
		{
			currentMax = Math.max (Math.max (this.data [i].open, this.data [i].close) , Math.max (this.data [i].high, this.data [i].low));
			maxValue = (currentMax > maxValue) ?currentMax : maxValue;
		}
		//Now, iterate through trend sets and find.
		for (i = 1; i <= this.numTS; i ++)
		{
			for (j = 1; j <= this.trendset [i].num; j ++)
			{
				maxValue = (this.trendset [i].data [j].value > maxValue) ?this.trendset [i].data [j].value : maxValue;
			}
		}
		//Finally we've the max value - so return it.
		return maxValue;
	}
	/**
	* getMinPrice method gets the minimum price data value present
	* in the data. We iterate through each data <set> and trend <set>
	*	@return	The maximum price present in the data provided.
	*/
	private function getMinPrice () : Number 
	{
		var minValue : Number;
		var i : Number, j : Number;
		//Initially set min value to first non -1 data
		for (i = 1; i <= this.num; i ++)
		{
			//Check if open is not -1
			if (this.data [i].open != - 1)
			{
				minValue = this.data [i].open;
				break;
			}
			//Check if close is not -1
			if (this.data [i].close != - 1)
			{
				minValue = this.data [i].close;
				break;
			}
			//Check if high is not -1
			if (this.data [i].high != - 1)
			{
				minValue = this.data [i].high;
				break;
			}
			//Check if low is not -1
			if (this.data [i].low != - 1)
			{
				minValue = this.data [i].low;
				break;
			}
		}
		//Now, iterate through rest of data and compare
		for (i = 1; i <= this.num; i ++)
		{
			//Check if open is not -1 and less
			if (this.data [i].open != - 1)
			{
				minValue = Math.min (minValue, this.data [i].open);
			}
			//Check if close is not -1 and less
			if (this.data [i].close != - 1)
			{
				minValue = Math.min (minValue, this.data [i].close);
			}
			//Check if high is not -1 and less
			if (this.data [i].high != - 1)
			{
				minValue = Math.min (minValue, this.data [i].high);
			}
			//Check if low is not -1 and less
			if (this.data [i].low != - 1)
			{
				minValue = Math.min (minValue, this.data [i].low);
			}
		}
		//Now, iterate through trend sets and find.
		for (i = 1; i <= this.numTS; i ++)
		{
			for (j = 1; j <= this.trendset [i].num; j ++)
			{
				minValue = (this.trendset [i].data [j].value < minValue) ?this.trendset [i].data [j].value : minValue;
			}
		}
		//Finally we've the max value - so return it.
		return minValue;
	}
	/**
	* getMaxVolume method gets the maximum volume on the chart.
	*	@return	Maximum volume present in data.
	*/
	private function getMaxVolume () : Number
	{
		var i : Number, maxVol : Number;
		//Initialize to 0
		maxVol = 0;
		for (i = 1; i <= this.num; i ++)
		{
			maxVol = Math.max (this.data [i].volume, maxVol);
		}
		//Return
		return maxVol;
	}
	/**
	* getXAxisLimits method helps calculate the X-axis limits based
	* on the given maximum and minimum value.
	* @param	maxValue		Maximum numerical value (X) present in data
	*	@param	minValue		Minimum numerical value (X) present in data
	*/
	private function getXAxisLimits (maxValue : Number, minValue : Number) : Void 
	{
		//If he has provided it and it is valid, we leave it as the upper limit
		//Else, we enforced the value calculate by us as the upper limit.
		if (this.params.xAxisMaxValue == null || this.params.xAxisMaxValue == undefined || this.params.xAxisMaxValue == "" || Number (this.params.xAxisMaxValue) == NaN || Number (this.params.xAxisMaxValue) < maxValue)
		{
			this.config.xMax = maxValue;
		} else 
		{
			this.config.xMax = Number (this.params.xAxisMaxValue);
		}
		//Now, we do the same for x-axis lower limit
		if (this.params.xAxisMinValue == null || this.params.xAxisMinValue == undefined || this.params.xAxisMinValue == "" || Number (this.params.xAxisMinValue) == NaN || Number (this.params.xAxisMinValue) > minValue)
		{
			this.config.xMin = minValue;
		} else 
		{
			this.config.xMin = Number (this.params.xAxisMinValue);
		}
	}
	/**
	* getPYAxisLimits method helps calculate the Price Y-axis limits based
	* on the given maximum and minimum value.
	* @param	maxValue		Maximum price present in data
	*	@param	minValue		Minimum price present in data
	*	@param	setMinAsZero	Whether to set the lower limit as 0 or a greater
	*							appropriate value (when dealing with positive numbers)
	*/
	private function getPYAxisLimits (maxValue : Number, minValue : Number, setMinAsZero : Boolean) : Void 
	{
		//First check if both maxValue and minValue are proper numbers.
		//Else, set defaults as 90,0
		maxValue = (isNaN (maxValue) == true || maxValue == undefined) ? 90 : maxValue;
		minValue = (isNaN (minValue) == true || minValue == undefined) ? 0 : minValue;
		//Or, if only 0 data is supplied
		if ((maxValue == minValue) && (maxValue == 0))
		{
			maxValue = 90;
		}
		//Both values need to be positive - We're dealing with price quanities
		maxValue = Math.abs (maxValue);
		minValue = Math.abs (minValue);
		//Default for setMinAsZero
		setMinAsZero = getFV (setMinAsZero, true);
		//Get the maximum power of 10 that is applicable to maxvalue
		//The Number = 10 to the power maxPowerOfTen + x (where x is another number)
		//For e.g., in 99 the maxPowerOfTen will be 1 = 10^1 + 89
		//And for 102, it will be 2 = 10^2 + 2
		var maxPowerOfTen : Number = Math.floor (Math.log (maxValue) / Math.LN10);
		//Get the minimum power of 10 that is applicable to maxvalue
		var minPowerOfTen : Number = Math.floor (Math.log (minValue) / Math.LN10);
		//Find which powerOfTen (the max power or the min power) is bigger
		//It is this which will be multiplied to get the y-interval
		var powerOfTen : Number = Math.max (minPowerOfTen, maxPowerOfTen);
		var y_interval : Number = Math.pow (10, powerOfTen);
		//For accomodating smaller range values (so that scale doesn't represent too large an interval
		if (Math.abs (maxValue) / y_interval < 2 && Math.abs (minValue) / y_interval < 2)
		{
			powerOfTen --;
			y_interval = Math.pow (10, powerOfTen);
		}
		//If the y_interval of min and max is way more than that of range.
		//We need to reset the y-interval as per range
		var rangePowerOfTen : Number = Math.floor (Math.log (maxValue - minValue) / Math.LN10);
		var rangeInterval : Number = Math.pow (10, rangePowerOfTen);
		//Now, if rangeInterval is 10 times less than y_interval, we need to re-set
		//the limits, as the range is too less to adjust the axis for max,min.
		//We do this only if range is greater than 0 (in case of 1 data on chart).
		if (((maxValue - minValue) > 0) && ((y_interval / rangeInterval) >= 10))
		{
			y_interval = rangeInterval;
			powerOfTen = rangePowerOfTen;
		}
		//Calculate the y-axis upper limit
		var y_topBound : Number = (Math.floor (maxValue / y_interval) + 1) * y_interval;
		//Calculate the y-axis lower limit
		var y_lowerBound : Number;
		if (setMinAsZero)
		{
			y_lowerBound = 0;
		} else 
		{
			y_lowerBound = Math.floor (Math.abs (minValue / y_interval) - 1) * y_interval;
		}
		//Now, we need to make a check as to whether the user has provided an upper limit
		//and lower limit.
		if (this.params.PYAxisMaxValue == null || this.params.PYAxisMaxValue == undefined || this.params.PYAxisMaxValue == "")
		{
			this.config.PYMaxGiven = false;
		} else 
		{
			this.config.PYMaxGiven = true;
		}
		if (this.params.PYAxisMinValue == null || this.params.PYAxisMinValue == undefined || this.params.PYAxisMinValue == "" || Number (this.params.PYAxisMinValue) == NaN)
		{
			this.config.PYMinGiven = false;
		} else 
		{
			this.config.PYMinGiven = true;
		}
		//If he has provided it and it is valid, we leave it as the upper limit
		//Else, we enforced the value calculate by us as the upper limit.
		if (this.config.PYMaxGiven == false || (this.config.PYMaxGiven == true && Number (this.params.PYAxisMaxValue) < maxValue))
		{
			this.config.PYMax = y_topBound;
		} else 
		{
			this.config.PYMax = Number (this.params.PYAxisMaxValue);
		}
		//Now, we do the same for y-axis lower limit
		if (this.config.PYMinGiven == false || (this.config.PYMinGiven == true && Number (this.params.PYAxisMinValue) > minValue))
		{
			this.config.PYMin = y_lowerBound;
		} else 
		{
			this.config.PYMin = Number (this.params.PYAxisMinValue);
		}
		//Store axis range
		this.config.PRange = Math.abs (this.config.PYMax - this.config.PYMin);
		//Store interval
		this.config.PInterval = y_interval;
	}
	/**
	* getVYAxisLimits method helps calculate the volume y-axis limits based
	* on the given maximum and minimum volume.
	* @param	maxValue		Maximum volume present in data
	*	@param	minValue		Minimum volume present in data
	*/
	private function getVYAxisLimits (maxValue : Number, minValue : Number) : Void 
	{
		//First check if both maxValue and minValue are proper numbers.
		//Else, set defaults as 90,0
		maxValue = (isNaN (maxValue) == true || maxValue == undefined) ? 90 : maxValue;
		minValue = (isNaN (minValue) == true || minValue == undefined) ? 0 : minValue;
		//Or, if only 0 data is supplied
		if ((maxValue == minValue) && (maxValue == 0))
		{
			maxValue = 90;
		}
		//Both values need to be positive - We're dealing with price quanities
		maxValue = Math.abs (maxValue);
		minValue = Math.abs (minValue);
		//Get the maximum power of 10 that is applicable to maxvalue
		//The Number = 10 to the power maxPowerOfTen + x (where x is another number)
		//For e.g., in 99 the maxPowerOfTen will be 1 = 10^1 + 89
		//And for 102, it will be 2 = 10^2 + 2
		var maxPowerOfTen : Number = Math.floor (Math.log (maxValue) / Math.LN10);
		//Get the minimum power of 10 that is applicable to maxvalue
		var minPowerOfTen : Number = Math.floor (Math.log (minValue) / Math.LN10);
		//Find which powerOfTen (the max power or the min power) is bigger
		//It is this which will be multiplied to get the y-interval
		var powerOfTen : Number = Math.max (minPowerOfTen, maxPowerOfTen);
		var y_interval : Number = Math.pow (10, powerOfTen);
		//For accomodating smaller range values (so that scale doesn't represent too large an interval
		if (Math.abs (maxValue) / y_interval < 2 && Math.abs (minValue) / y_interval < 2)
		{
			powerOfTen --;
			y_interval = Math.pow (10, powerOfTen);
		}
		//If the y_interval of min and max is way more than that of range.
		//We need to reset the y-interval as per range
		var rangePowerOfTen : Number = Math.floor (Math.log (maxValue - minValue) / Math.LN10);
		var rangeInterval : Number = Math.pow (10, rangePowerOfTen);
		//Now, if rangeInterval is 10 times less than y_interval, we need to re-set
		//the limits, as the range is too less to adjust the axis for max,min.
		//We do this only if range is greater than 0 (in case of 1 data on chart).
		if (((maxValue - minValue) > 0) && ((y_interval / rangeInterval) >= 10))
		{
			y_interval = rangeInterval;
			powerOfTen = rangePowerOfTen;
		}
		//Calculate the y-axis upper limit
		var y_topBound : Number = (Math.floor (maxValue / y_interval) + 1) * y_interval;
		//Now, we need to make a check as to whether the user has provided an upper limit
		//and lower limit.
		if (this.params.VYAxisMaxValue == null || this.params.VYAxisMaxValue == undefined || this.params.VYAxisMaxValue == "")
		{
			this.config.VYMaxGiven = false;
		} else 
		{
			this.config.VYMaxGiven = true;
		}
		if (this.params.VYAxisMinValue == 0)
		{
			this.config.VYMinGiven = false;
		} else 
		{
			this.config.VYMinGiven = true;
		}
		//If he has provided it and it is valid, we leave it as the upper limit
		//Else, we enforced the value calculate by us as the upper limit.
		if (this.config.VYMaxGiven == false || (this.config.VYMaxGiven == true && Number (this.params.VYAxisMaxValue) < maxValue))
		{
			this.config.VYMax = y_topBound;
		} else 
		{
			this.config.VYMax = Number (this.params.VYAxisMaxValue);
		}
		//Now, we do the same for volume y-axis lower limit
		if (this.config.VYMinGiven == false || (this.config.VYMinGiven == true && Number (this.params.VYAxisMinValue) < 0))
		{
			this.config.VYMin = 0;
		} else 
		{
			this.config.VYMin = Number (this.params.VYAxisMinValue);
		}
		//Store axis range
		this.config.VRange = Math.abs (this.config.VYMax - this.config.VYMin);
		//Store interval
		this.config.VInterval = y_interval;
	}
	/**
	* calculateAxisLimits method sets the axis limits for the chart.
	* It gets the minimum and maximum value specified in data and
	* based on that it calls super.getAxisLimits();
	*/
	private function calculateAxisLimits () : Void 
	{
		//Calculate for x-axis
		this.getXAxisLimits (this.getMaxXDataValue () , this.getMinXDataValue ());
		//Get Price Axis limits
		this.getPYAxisLimits (this.getMaxPrice () , this.getMinPrice () , ! this.params.setAdaptiveYMin);
		if (this.config.showVolume)
		{
			//Volume Axis Limits
			this.getVYAxisLimits (this.getMaxVolume () , this.params.VYAxisMinValue);
		}
	}
	/**
	* calcPDivs method calculates the best div line interval for the given/calculated
	* Price yMin, yMax, specified numPDivLines and adjustDiv.
	* In this function whenever we refer to yMin, yMax, we're referring to PYMin and PYMax,
	* unless otherwise specified.
	* We re-set the PRICE y axis min and max value, if both were calculated by our
	* us, so that we get a best value according to numPDivLines. The idea is to have equal
	* intervals on the axis, based on numPDivLines specified. We do so, only if both yMin and
	* yMax have been calculated as per our values. Else, we adjust the numDiv Lines.
	*/
	private function calcPDivs () : Void 
	{
		/**
		* There can be four cases of Primary yMin, yMax.
		* 1. User doesn't specify either. (our program calculates it).
		* 2. User specifies both in XML. (which our program still validates)
		* 3. User specifies only yMin. (we provide missing data)
		* 4. User specifies only yMax. (we provide missing data)
		*
		* Apart from this, the user can specify numPDivLines (which if not specified takes a
		* default value of 4). Also, the user can specify adjustDiv (which can be 1 or 0).
		* adjustDiv works in all four cases (1,2,3,4).
		* Case 1 is modified to occur as under now: User doesn't specify either yMin or yMax
		* and adjustDiv is set to true (by default). If the user doesn't specify either yMin or
		* yMax, but adjustDiv is set to false, it doesn't appear as Case 1. However, if adjustDiv
		* is set to true and yMin,yMax is automatically calculated by FusionCharts, we adjust the
		* calculated yMin,yMax so that the given number of div lines can be well adjusted within.
		*
		* In case 2,3,4, we adjust numPDivLines so that they space up equally based on the interval
		* and decimals required.
		*
		* So, the difference between Case 1 and Case 2,3,4 is that in Case 1, we adjust limits
		* to accomodate specified number of div lines. In Case 2,3,4, we adjust numPDivLines to
		* accomodate within the given limits (y-axis range).
		*
		* numPDivLines is always our primary focus when calculating them in all cases. In Case 1,
		* it's kept constant as center of calculation. In Case 2, it's modified to get a best
		* value.
		*
		* We just need to adjust the range between two positive
		* numbers such that the range can be equally divided into (numPDivLines+1)
		* division.
		* Note that, we adjust the auto-calculated yMax and yMin
		* to get best div line value. We do NOT adjust numPDivLines here.
		*/
		//Check condition for case 1 first - limits not specified and adjustDiv is true
		if (this.config.PYMinGiven == false && this.config.PYMaxGiven == false && this.params.adjustDiv == true)
		{
			//Means neither chart max value nor min value has been specified and adjustDiv is true
			//Set flag that we do not have to format div (y-axis values) decimals
			this.config.formatPDivDecimals = false;
			/**
			* We first get apt divisible range based on yMin, yMax,
			* numPDivLines and the calculated interval. Thereby, get the difference
			* between original range and new range and store as delta.
			*/
			//Get the adjusted divisible range
			var adjRange : Number = getDivisibleRange (this.config.PYMin, this.config.PYMax, this.params.numPDivLines, this.config.PInterval, true);
			//Get delta (Calculated range minus original range)
			var deltaRange : Number = adjRange - this.config.PRange;
			//Update global range storage
			this.config.PRange = adjRange;
			//Now, add the change in range to yMax
			this.config.PYMax = this.config.PYMax + deltaRange;
		} else 
		{
			/**
			* Here, we've to handle the following cases
			* 2. User specifies both yMin, yMax in XML. (which our program still validates)
			* 3. User specifies only yMin. (we provide yMax)
			* 4. User specifies only yMax. (we provide yMin)
			* Now, for each of these, there can be two cases. If the user has opted to
			* adjust div lines or not. If he has opted to adjustDiv, we calculate the best
			* possible number of div lines for the given range. If not, we simply divide
			* the given (or semi-calculated) axis limits by the number of div lines.
			*/
			if (this.params.adjustDiv == true)
			{
				//We iterate from given numPDivLines to 0,
				//Count helps us keep a counter of how many div lines we've checked
				//For the sake of optimization, we check only 25 div lines values
				//From (numPDivLines to 0) and (numPDivLines to (25-numPDivLines))
				//We do it in a yoyo order - i.e., if numPDivLines is set as 5,
				//we first check 6 and then 4. Next would be (8,3), (9,2), (10,1),
				//(11, (no value here, as we do not check for 0), 12, 13, 14, 15, 16,
				//17,18,19,20. So, in this way, we check for 25 possible numPDivLines and
				//see if any one them fit in. If yes, we store that value. Else, we set it
				//as 0 (indicating no div line feasible for the given value).
				//Perform only if this.params.numPDivLines>0
				if (this.params.numPDivLines > 0)
				{
					var counter : Number = 0;
					var multiplyFactor : Number = 1;
					var numPDivLines : Number;
					while (1 == 1)
					{
						//Increment,Decrement numPDivLines
						numPDivLines = this.params.numPDivLines + (counter * multiplyFactor);
						//Cannot be 0
						numPDivLines = (numPDivLines == 0) ? 1 : numPDivLines;
						//Check whether this number of numPDivLines satisfy our requirement
						if (isRangeDivisible (this.config.PRange, numPDivLines, this.config.PInterval))
						{
							//Exit loop
							break;
						}
						//Each counter comes twice: one for + count, one for - count
						counter = (multiplyFactor == - 1 || (counter > this.params.numPDivLines)) ? ( ++ counter) : (counter);
						if (counter > 25)
						{
							//We do not go beyond 25 count to optimize.
							//If the loop comes here, it means that divlines
							//counter is not able to achieve the target.
							//So, we assume no div lines are possible and exit.
							numPDivLines = 0;
							break;
						}
						//Switch to increment/decrement mode. If counter
						multiplyFactor = (counter <= this.params.numPDivLines) ? (multiplyFactor * - 1) : (1);
					}
					//Store the value in params
					this.params.numPDivLines = numPDivLines;
					//Set flag that we do not have to format div (y-axis values) decimals
					this.config.formatPDivDecimals = false;
				}
			} else 
			{
				//We need to set flag that div lines intevals need to formatted
				//to the given precision.
				//Set flag that we have to format div (y-axis values) decimals
				this.config.formatPDivDecimals = true;
			}
		}
		//Div interval
		this.config.PDivInterval = (this.config.PYMax - this.config.PYMin) / (this.params.numPDivLines + 1);
		//We now need to store all the div line segments in the array this.pDivLines
		//We include yMin and yMax too in div lines to render in a single loop
		var PDivLineValue : Number = this.config.PYMin - this.config.PDivInterval;
		//Keeping a count of div lines
		var count : Number = 0;
		while (count <= (this.params.numPDivLines + 1))
		{
			//Converting to string and back to number to avoid Flash's rounding problems.
			PDivLineValue = Number (String (PDivLineValue + this.config.PDivInterval));
			//Add the div line to this.pDivLines
			this.pDivLines [count] = this.returnDataAsPDivLine (PDivLineValue);
			//Based on yAxisValueStep, we need to hide required div line values
			if (count % this.params.yAxisValuesStep == 0)
			{
				this.pDivLines [count].showValue = true;
			} else 
			{
				this.pDivLines [count].showValue = false;
			}
			if (this.params.showYAxisValues == false)
			{
				this.pDivLines [count].showValue = false;
			}
			//Increment counter
			count ++;
		}
		//Now, sort on value
		this.pDivLines.sortOn ("value", Array.NUMERIC);
		//We finally have the sorted div lines in this.pDivLines
		
	}
	/**
	* isRangeDivisible method helps us judge whether the given range is
	* perfectly divisible for specified y-interval, numPDivLines, yMin and yMax.
	* To check that, we divide the given range into (numPDivLines+1) section.
	* If the decimal places of this division value is <= that of interval,
	* that means, this range fits in our purpose. We return a boolean value
	* accordingly.
	*	@param	range		Range of y-axis (Max - Min). Absolute value
	*	@param	numPDivLines	Number of div lines to be plotted.
	*	@param	interval	Y-axis Interval (power of ten).
	*	@return			Boolean value indicating whether this range is divisible
	*						by the given number of div lines.
	*/
	private function isRangeDivisible (range : Number, numPDivLines : Number, interval : Number) : Boolean 
	{
		//Get range division
		var rangeDiv : Number = range / (numPDivLines + 1);
		//Now, if the decimal places of rangeDiv and interval do not match,
		//it's not divisible, else it's divisible
		if (MathExt.numDecimals (rangeDiv) > MathExt.numDecimals (interval))
		{
			return false;
		} else 
		{
			return true;
		}
	}
	/**
	* getDivisibleRange method calculates a perfectly divisible range based
	* on y-interval, numPDivLines, yMin and yMax specified.
	* We first get the range division for the existing range
	* and user specified number of div lines. Now, if that division satisfies
	* our needs (decimal places of division and interval is equal), we do NOT
	* change anything. Else, we round up the division to the next higher value {big delta
	* in case of smaller values i.e., interval <1 and small delta in case of bigger values >1).
	* We multiply this range division by number of div lines required and calculate
	* the new range.
	*	@param	yMin			Min value of y-axis
	*	@param	yMax			Max value of y-axis
	*	@param	numPDivLines		Number of div lines to be plotted.
	*	@param	interval		Y-axis Interval (power of ten).
	*	@param	interceptRange	Boolean value indicating whether we've to change the range
	*							by altering interval (based on it's own value).
	*	@return				A range that is perfectly divisible into given number of sections.
	*/
	private function getDivisibleRange (yMin : Number, yMax : Number, numPDivLines : Number, interval : Number, interceptRange : Boolean) : Number 
	{
		//Get the range division for current yMin, yMax and numPDivLines
		var range = Math.abs (yMax - yMin);
		var rangeDiv : Number = range / (numPDivLines + 1);
		//Now, the range is not divisible
		if ( ! isRangeDivisible (range, numPDivLines, interval))
		{
			//We need to get new rangeDiv which can be equally distributed.
			//If intercept range is set to true
			if (interceptRange)
			{
				//Re-adjust interval so that gap is not much (conditional)
				//Condition check limit based on value
				var checkLimit : Number = (interval > 1) ? 2 : 0.5;
				if ((Number (rangeDiv) / Number (interval)) < checkLimit)
				{
					//Decrease power of ten to get closer rounding
					interval = interval / 10;
				}
			}
			//Adjust range division based on new interval
			rangeDiv = (Math.floor (rangeDiv / interval) + 1) * interval;
			//Get new range
			range = rangeDiv * (numPDivLines + 1);
		}
		//Return range
		return range;
	}
	/**
	* calcVDivs method calculates the best div line interval for the given/calculated
	* Volume yMin, yMax, specified numVDivLines and adjustDiv.
	* In this function whenever we refer to yMin, yMax, we're referring to PYMin and PYMax,
	* unless otherwise specified.
	* We re-set the Volume y axis min and max value, if both were calculated by our
	* us, so that we get a best value according to numVDivLines. The idea is to have equal
	* intervals on the axis, based on numVDivLines specified. We do so, only if both yMin and
	* yMax have been calculated as per our values. Else, we adjust the numDiv Lines.
	*/
	private function calcVDivs () : Void 
	{
		/**
		* There can be four cases of Volume yMin, yMax.
		* 1. User doesn't specify either. (our program calculates it).
		* 2. User specifies both in XML. (which our program still validates)
		* 3. User specifies only yMin. (we provide missing data)
		* 4. User specifies only yMax. (we provide missing data)
		*
		* Apart from this, the user can specify numVDivLines (which if not specified takes a
		* default value of 4). Also, the user can specify adjustDiv (which can be 1 or 0).
		* adjustDiv works in all four cases (1,2,3,4).
		* Case 1 is modified to occur as under now: User doesn't specify either yMin or yMax
		* and adjustDiv is set to true (by default). If the user doesn't specify either yMin or
		* yMax, but adjustDiv is set to false, it doesn't appear as Case 1. However, if adjustDiv
		* is set to true and yMin,yMax is automatically calculated by FusionCharts, we adjust the
		* calculated yMin,yMax so that the given number of div lines can be well adjusted within.
		*
		* In case 2,3,4, we adjust numVDivLines so that they space up equally based on the interval
		* and decimals required.
		*
		* So, the difference between Case 1 and Case 2,3,4 is that in Case 1, we adjust limits
		* to accomodate specified number of div lines. In Case 2,3,4, we adjust numVDivLines to
		* accomodate within the given limits (y-axis range).
		*
		* numVDivLines is always our primary focus when calculating them in all cases. In Case 1,
		* it's kept constant as center of calculation. In Case 2, it's modified to get a best
		* value.
		*
		* We just need to adjust the range between two positive
		* numbers such that the range can be equally divided into (numVDivLines+1)
		* division.
		* Note that, we adjust the auto-calculated yMax and yMin
		* to get best div line value. We do NOT adjust numVDivLines here.
		*/
		//Check condition for case 1 first - limits not specified and adjustDiv is true
		if (this.config.VYMinGiven == false && this.config.VYMaxGiven == false && this.params.adjustDiv == true)
		{
			//Means neither chart max value nor min value has been specified and adjustDiv is true
			//Set flag that we do not have to format div (y-axis values) decimals
			this.config.formatVDivDecimals = false;
			/**
			* We first get apt divisible range based on yMin, yMax,
			* numVDivLines and the calculated interval. Thereby, get the difference
			* between original range and new range and store as delta.
			*/
			//Get the adjusted divisible range
			var adjRange : Number = getDivisibleRange (this.config.VYMin, this.config.VYMax, this.params.numVDivLines, this.config.VInterval, true);
			//Get delta (Calculated range minus original range)
			var deltaRange : Number = adjRange - this.config.VRange;
			//Update global range storage
			this.config.VRange = adjRange;
			//Now, add the change in range to yMax
			this.config.VYMax = this.config.VYMax + deltaRange;
		} else 
		{
			/**
			* Here, we've to handle the following cases
			* 2. User specifies both yMin, yMax in XML. (which our program still validates)
			* 3. User specifies only yMin. (we provide yMax)
			* 4. User specifies only yMax. (we provide yMin)
			* Now, for each of these, there can be two cases. If the user has opted to
			* adjust div lines or not. If he has opted to adjustDiv, we calculate the best
			* possible number of div lines for the given range. If not, we simply divide
			* the given (or semi-calculated) axis limits by the number of div lines.
			*/
			if (this.params.adjustDiv == true)
			{
				//We iterate from given numVDivLines to 0,
				//Count helps us keep a counter of how many div lines we've checked
				//For the sake of optimization, we check only 25 div lines values
				//From (numVDivLines to 0) and (numVDivLines to (25-numVDivLines))
				//We do it in a yoyo order - i.e., if numVDivLines is set as 5,
				//we first check 6 and then 4. Next would be (8,3), (9,2), (10,1),
				//(11, (no value here, as we do not check for 0), 12, 13, 14, 15, 16,
				//17,18,19,20. So, in this way, we check for 25 possible numVDivLines and
				//see if any one them fit in. If yes, we store that value. Else, we set it
				//as 0 (indicating no div line feasible for the given value).
				//Perform only if this.params.numVDivLines>0
				if (this.params.numVDivLines > 0)
				{
					var counter : Number = 0;
					var multiplyFactor : Number = 1;
					var numVDivLines : Number;
					while (1 == 1)
					{
						//Increment,Decrement numVDivLines
						numVDivLines = this.params.numVDivLines + (counter * multiplyFactor);
						//Cannot be 0
						numVDivLines = (numVDivLines == 0) ? 1 : numVDivLines;
						//Check whether this number of numVDivLines satisfy our requirement
						if (isRangeDivisible (this.config.VRange, numVDivLines, this.config.VInterval))
						{
							//Exit loop
							break;
						}
						//Each counter comes twice: one for + count, one for - count
						counter = (multiplyFactor == - 1 || (counter > this.params.numVDivLines)) ? ( ++ counter) : (counter);
						if (counter > 25)
						{
							//We do not go beyond 25 count to optimize.
							//If the loop comes here, it means that divlines
							//counter is not able to achieve the target.
							//So, we assume no div lines are possible and exit.
							numVDivLines = 0;
							break;
						}
						//Switch to increment/decrement mode. If counter
						multiplyFactor = (counter <= this.params.numVDivLines) ? (multiplyFactor * - 1) : (1);
					}
					//Store the value in params
					this.params.numVDivLines = numVDivLines;
					//Set flag that we do not have to format div (y-axis values) decimals
					this.config.formatVDivDecimals = false;
				}
			} else 
			{
				//We need to set flag that div lines intevals need to formatted
				//to the given precision.
				//Set flag that we have to format div (y-axis values) decimals
				this.config.formatVDivDecimals = true;
			}
		}
		//Div interval
		this.config.VDivInterval = (this.config.VYMax - this.config.VYMin) / (this.params.numVDivLines + 1);
		//We now need to store all the div line segments in the array this.vDivLines
		//We include yMin and yMax too in div lines to render in a single loop
		var VDivLineValue : Number = this.config.VYMin - this.config.VDivInterval;
		//Keeping a count of div lines
		var count : Number = 0;
		while (count <= (this.params.numVDivLines + 1))
		{
			//Converting to string and back to number to avoid Flash's rounding problems.
			VDivLineValue = Number (String (VDivLineValue + this.config.VDivInterval));
			//Add the div line to this.vDivLines
			this.vDivLines [count] = this.returnDataAsVDivLine (VDivLineValue);
			//Based on yAxisValueStep, we need to hide required div line values
			if (count % this.params.yAxisValuesStep == 0)
			{
				this.vDivLines [count].showValue = true;
			} else 
			{
				this.vDivLines [count].showValue = false;
			}
			if (this.params.showYAxisValues == false)
			{
				this.vDivLines [count].showValue = false;
			}
			//Increment counter
			count ++;
		}
		//Now, sort on value
		this.vDivLines.sortOn ("value", Array.NUMERIC);
		//We finally have the sorted div lines in this.vDivLines
		
	}
	/**
	* validateTrendLines method helps us validate the different trend line
	* points entered by user in XML. Some trend points may fall out of
	* chart range (yMin,yMax - xMin,xMax) and we need to invalidate them. Also, we
	* need to check if displayValue has been specified. Else, we specify
	* formatted number as displayValue.
	*	@return		Nothing
	*/
	private function validateTrendLines ()
	{
		//Sequentially do the following.
		//- Check if start value and end value are numbers. If not,
		//  invalidate them
		//- Check range of each trend line against chart yMin,yMax and
		//  devalidate wrong ones.
		//- Resolve displayValue conflict.
		//- Calculate and store y position of start and end position.
		//Loop variable
		var i : Number;
		for (i = 0; i <= this.numTrendLines; i ++)
		{
			//If the trend line start/end value is NaN or out of range
			if (isNaN (this.trendLines [i].startValue) || (this.trendLines [i].startValue < this.config.PYMin) || (this.trendLines [i].startValue > this.config.PYMax) || isNaN (this.trendLines [i].endValue) || (this.trendLines [i].endValue < this.config.PYMin) || (this.trendLines [i].endValue > this.config.PYMax))
			{
				//Invalidate it
				this.trendLines [i].isValid = false;
			} else 
			{
				//We resolve displayValue conflict
				this.trendLines [i].displayValue = getFV (this.trendLines [i].displayValue, this.formatNumber (this.trendLines [i].startValue, this.params.formatNumber, this.params.yAxisValueDecimals, false, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix));
			}
		}
		//Do the same for vertical trend lines too
		for (i = 0; i <= this.numVTrendLines; i ++)
		{
			//If the trend line start/end value is NaN or out of range
			if (isNaN (this.vTrendLines [i].startValue) || (this.vTrendLines [i].startValue < this.config.xMin) || (this.vTrendLines [i].startValue > this.config.xMax) || isNaN (this.vTrendLines [i].endValue) || (this.vTrendLines [i].endValue < this.config.xMin) || (this.vTrendLines [i].endValue > this.config.xMax))
			{
				//Invalidate it
				this.vTrendLines [i].isValid = false;
			} else 
			{
				//We resolve displayValue conflict
				this.vTrendLines [i].displayValue = getFV (this.vTrendLines [i].displayValue, "");
			}
		}
	}
	/**
	* setStyleDefaults method sets the default values for styles or
	* extracts information from the attributes and stores them into
	* style objects.
	*/
	private function setStyleDefaults () : Void 
	{
		//Default font object for Caption
		//-----------------------------------------------------------------//
		var captionFont = new StyleObject ();
		captionFont.name = "_SdCaptionFont";
		captionFont.align = "center";
		captionFont.valign = "top";
		captionFont.bold = "1";
		captionFont.font = this.params.outCnvBaseFont;
		captionFont.size = this.params.outCnvBaseFontSize;
		captionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.CAPTION, captionFont, this.styleM.TYPE.FONT, null);
		delete captionFont;
		//-----------------------------------------------------------------//
		//Default font object for SubCaption
		//-----------------------------------------------------------------//
		var subCaptionFont = new StyleObject ();
		subCaptionFont.name = "_SdSubCaptionFont";
		subCaptionFont.align = "center";
		subCaptionFont.valign = "top";
		subCaptionFont.bold = "1";
		subCaptionFont.font = this.params.outCnvBaseFont;
		subCaptionFont.size = this.params.outCnvBaseFontSize;
		subCaptionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.SUBCAPTION, subCaptionFont, this.styleM.TYPE.FONT, null);
		delete subCaptionFont;
		//-----------------------------------------------------------------//
		//Default font object for YAxisName
		//-----------------------------------------------------------------//
		var yAxisNameFont = new StyleObject ();
		yAxisNameFont.name = "_SdYAxisNameFont";
		yAxisNameFont.align = "center";
		yAxisNameFont.valign = "middle";
		yAxisNameFont.bold = "1";
		yAxisNameFont.font = this.params.outCnvBaseFont;
		yAxisNameFont.size = this.params.outCnvBaseFontSize;
		yAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.PYAXISNAME, yAxisNameFont, this.styleM.TYPE.FONT, null);
		this.styleM.overrideStyle (this.objects.VYAXISNAME, yAxisNameFont, this.styleM.TYPE.FONT, null);
		delete yAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for XAxisName
		//-----------------------------------------------------------------//
		var xAxisNameFont = new StyleObject ();
		xAxisNameFont.name = "_SdXAxisNameFont";
		xAxisNameFont.align = "center";
		xAxisNameFont.valign = "middle";
		xAxisNameFont.bold = "1";
		xAxisNameFont.font = this.params.outCnvBaseFont;
		xAxisNameFont.size = this.params.outCnvBaseFontSize;
		xAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.XAXISNAME, xAxisNameFont, this.styleM.TYPE.FONT, null);
		delete xAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for trend lines
		//-----------------------------------------------------------------//
		var trendFont = new StyleObject ();
		trendFont.name = "_SdTrendFontFont";
		trendFont.font = this.params.outCnvBaseFont;
		trendFont.size = this.params.outCnvBaseFontSize;
		trendFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.TRENDVALUES, trendFont, this.styleM.TYPE.FONT, null);
		this.styleM.overrideStyle (this.objects.VTRENDVALUES, trendFont, this.styleM.TYPE.FONT, null);
		delete trendFont;
		//-----------------------------------------------------------------//
		//Default font object for yAxisValues
		//-----------------------------------------------------------------//
		var yAxisValuesFont = new StyleObject ();
		yAxisValuesFont.name = "_SdYAxisValuesFont";
		yAxisValuesFont.align = "right";
		yAxisValuesFont.valign = "middle";
		yAxisValuesFont.font = this.params.outCnvBaseFont;
		yAxisValuesFont.size = this.params.outCnvBaseFontSize;
		yAxisValuesFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.YAXISVALUES, yAxisValuesFont, this.styleM.TYPE.FONT, null);
		delete yAxisValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for DataLabels
		//-----------------------------------------------------------------//
		var dataLabelsFont = new StyleObject ();
		dataLabelsFont.name = "_SdDataLabelsFont";
		dataLabelsFont.align = "center";
		dataLabelsFont.valign = "bottom";
		dataLabelsFont.font = this.params.catFont;
		dataLabelsFont.size = this.params.catFontSize;
		dataLabelsFont.color = this.params.catFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.DATALABELS, dataLabelsFont, this.styleM.TYPE.FONT, null);
		delete dataLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for Legend
		//-----------------------------------------------------------------//
		var legendFont = new StyleObject ();
		legendFont.name = "_SdLegendFont";
		legendFont.font = this.params.outCnvBaseFont;
		legendFont.size = this.params.outCnvBaseFontSize;
		legendFont.color = this.params.outCnvBaseFontColor;
		legendFont.ishtml = 1;
		legendFont.leftmargin = 3;
		//Over-ride
		this.styleM.overrideStyle (this.objects.LEGEND, legendFont, this.styleM.TYPE.FONT, null);
		delete legendFont;
		//-----------------------------------------------------------------//
		//Default font object for DataValues
		//-----------------------------------------------------------------//
		var dataValuesFont = new StyleObject ();
		dataValuesFont.name = "_SdDataValuesFont";
		dataValuesFont.align = "center";
		dataValuesFont.valign = "middle";
		dataValuesFont.bgcolor = this.params.canvasBgColor;
		dataValuesFont.bordercolor = this.params.canvasBorderColor;
		dataValuesFont.font = this.params.baseFont;
		dataValuesFont.size = this.params.baseFontSize;
		dataValuesFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.DATAVALUES, dataValuesFont, this.styleM.TYPE.FONT, null);
		delete dataValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for ToolTip
		//-----------------------------------------------------------------//
		var toolTipFont = new StyleObject ();
		toolTipFont.name = "_SdToolTipFont";
		toolTipFont.font = this.params.baseFont;
		toolTipFont.size = this.params.baseFontSize;
		toolTipFont.color = this.params.baseFontColor;
		toolTipFont.bgcolor = this.params.toolTipBgColor;
		toolTipFont.bordercolor = this.params.toolTipBorderColor;
		toolTipFont.ishtml = "1";
		//Over-ride
		this.styleM.overrideStyle (this.objects.TOOLTIP, toolTipFont, this.styleM.TYPE.FONT, null);
		delete toolTipFont;
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for DataPlot
		//-----------------------------------------------------------------//
		if (this.params.showShadow)
		{
			var dataPlotShadow = new StyleObject ();
			dataPlotShadow.name = "_SdDataPlotShadow";
			dataPlotShadow.angle = 45;
			//Over-ride
			this.styleM.overrideStyle (this.objects.PRICEPLOT, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			this.styleM.overrideStyle (this.objects.VOLUMEPLOT, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			this.styleM.overrideStyle (this.objects.TRENDSETS, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			delete dataPlotShadow;
		}
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for Legend
		//-----------------------------------------------------------------//
		if (this.params.legendShadow)
		{
			var legendShadow = new StyleObject ();
			legendShadow.name = "_SdLegendShadow";
			legendShadow.distance = 2;
			legendShadow.alpha = 90;
			legendShadow.angle = 45;
			//Over-ride
			this.styleM.overrideStyle (this.objects.LEGEND, legendShadow, this.styleM.TYPE.SHADOW, null);
			delete legendShadow;
		}
		//-----------------------------------------------------------------//
		//Default Animation object for DataPlot (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation)
		{
			//Animation for Volume Plot
			var volumePlotAnim = new StyleObject ();
			volumePlotAnim.name = "_SdVolumePlotAnim";
			volumePlotAnim.param = "_yscale";
			volumePlotAnim.easing = "regular";
			volumePlotAnim.wait = 0;
			volumePlotAnim.start = 0;
			volumePlotAnim.duration = 1;
			//Over-ride
			this.styleM.overrideStyle (this.objects.VOLUMEPLOT, volumePlotAnim, this.styleM.TYPE.ANIMATION, "_yscale");
			delete volumePlotAnim;
			//Now, based on what the PRICE is to be rendered as, we define the animation
			if (this.params.plotPriceAs == "LINE")
			{
				//If it's line plot, we define animation for line and anchors.
				//1. XScale for data plot
				var dataPlotAnim = new StyleObject ();
				dataPlotAnim.name = "_SdDataPlotAnimXScale";
				dataPlotAnim.param = "_xscale";
				dataPlotAnim.easing = "regular";
				dataPlotAnim.wait = 0;
				dataPlotAnim.start = 0;
				dataPlotAnim.duration = 0.7;
				//Over-ride
				this.styleM.overrideStyle (this.objects.PRICEPLOT, dataPlotAnim, this.styleM.TYPE.ANIMATION, "_xscale");
				delete dataPlotAnim;
				//2. YScale for data plot
				var dataPlotAnimY = new StyleObject ();
				dataPlotAnimY.name = "_SdDataPlotAnimYScale";
				dataPlotAnimY.param = "_yscale";
				dataPlotAnimY.easing = "regular";
				dataPlotAnimY.wait = 0.7;
				dataPlotAnimY.start = 0.1;
				dataPlotAnimY.duration = 0.7;
				//Over-ride
				this.styleM.overrideStyle (this.objects.PRICEPLOT, dataPlotAnimY, this.styleM.TYPE.ANIMATION, "_yscale");
				delete dataPlotAnimY;
				//3. Alpha effect for anchors
				var anchorsAnim = new StyleObject ();
				anchorsAnim.name = "_SdDataAnchorAnim";
				anchorsAnim.param = "_alpha";
				anchorsAnim.easing = "regular";
				anchorsAnim.wait = 0;
				anchorsAnim.start = 0;
				anchorsAnim.duration = 0.5;
				//Over-ride
				this.styleM.overrideStyle (this.objects.ANCHORS, anchorsAnim, this.styleM.TYPE.ANIMATION, "_alpha");
				delete anchorsAnim;
			}
			else
			{
				//If it's candle-stick or bar plot
				var pricePlotAnim = new StyleObject ();
				pricePlotAnim.name = "_SdDataPlotAnimYScale";
				pricePlotAnim.param = "_yscale";
				pricePlotAnim.easing = "regular";
				pricePlotAnim.wait = 0;
				pricePlotAnim.start = 0;
				pricePlotAnim.duration = 1;
				this.styleM.overrideStyle (this.objects.PRICEPLOT, pricePlotAnim, this.styleM.TYPE.ANIMATION, "_yscale");
				delete pricePlotAnim;
			}
			//Animation for trend sets
			//1. XScale for trend sets
			var tsPlotAnimX = new StyleObject ();
			tsPlotAnimX.name = "_SdTSPlotAnimXScale";
			tsPlotAnimX.param = "_xscale";
			tsPlotAnimX.easing = "regular";
			tsPlotAnimX.wait = 0;
			tsPlotAnimX.start = 0;
			tsPlotAnimX.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle (this.objects.TRENDSETS, tsPlotAnimX, this.styleM.TYPE.ANIMATION, "_xscale");
			delete tsPlotAnimX;
			//2. YScale for trend sets
			var tsPlotAnimY = new StyleObject ();
			tsPlotAnimY.name = "_SdTSPlotAnimYScale";
			tsPlotAnimY.param = "_yscale";
			tsPlotAnimY.easing = "regular";
			tsPlotAnimY.wait = 0.7;
			tsPlotAnimY.start = 0.1;
			tsPlotAnimY.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle (this.objects.TRENDSETS, tsPlotAnimY, this.styleM.TYPE.ANIMATION, "_yscale");
			delete tsPlotAnimY;
		}
		//-----------------------------------------------------------------//
		
	}
	/**
	* allotDepths method allots the depths for various chart objects
	* to be rendered. We do this before hand, so that we can later just
	* go on rendering chart objects, without swapping.
	*/
	private function allotDepths () : Void 
	{
		//Background
		this.dm.reserveDepths ("BACKGROUND", 1);
		//Click URL Handler
		this.dm.reserveDepths ("CLICKURLHANDLER", 1);
		//Background SWF
		this.dm.reserveDepths ("BGSWF", 1);
		//Canvas
		this.dm.reserveDepths ("PCANVAS", 1);
		this.dm.reserveDepths ("VCANVAS", 1);
		//If horizontal grid is to be shown
		if (this.params.showAlternateHGridColor)
		{
			this.dm.reserveDepths ("PHGRID", Math.ceil ((this.pDivLines.length + 1) / 2));
		}
		//Div Lines and their labels
		this.dm.reserveDepths ("PDIVLINES", (this.pDivLines.length * 2));
		//Volume Horizontal grid
		if (this.params.showAlternateHGridColor)
		{
			this.dm.reserveDepths ("VHGRID", Math.ceil ((this.vDivLines.length + 1) / 2));
		}
		//Div Lines and their labels
		this.dm.reserveDepths ("VDIVLINES", (this.vDivLines.length * 2));
		//Vertical lines
		this.dm.reserveDepths ("VLINES", this.numCat * 2);
		//Caption
		this.dm.reserveDepths ("CAPTION", 1);
		//Sub-caption
		this.dm.reserveDepths ("SUBCAPTION", 1);
		//Y-Axis Name
		this.dm.reserveDepths ("PYAXISNAME", 1);
		this.dm.reserveDepths ("VYAXISNAME", 1);
		//Vertical trend lines
		this.dm.reserveDepths ("VTRENDLINES", this.numVTrendLines * 2);
		this.dm.reserveDepths ("VTRENDVALUES", this.numVTrendLines);
		//Horizontal Trend lines below plot
		this.dm.reserveDepths ("TRENDLINESBELOW", this.numTrendLinesBelow);
		this.dm.reserveDepths ("TRENDVALUESBELOW", this.numTrendLinesBelow);
		//Data Labels
		this.dm.reserveDepths ("DATALABELS", this.numCat);
		//Line Chart
		this.dm.reserveDepths ("PRICEPLOT", this.num);
		this.dm.reserveDepths ("VOLUMEPLOT", this.num);
		//Trend sets
		this.dm.reserveDepths ("TRENDSETS", this.numTS);
		//Canvas Borders
		this.dm.reserveDepths ("PCANVASBORDER", 1);
		this.dm.reserveDepths ("VCANVASBORDER", 1);
		//Anchors
		this.dm.reserveDepths ("ANCHORS", this.num);
		//Horizontal Trend lines below plot (lines and their labels)
		this.dm.reserveDepths ("TRENDLINESABOVE", (this.numTrendLines - this.numTrendLinesBelow));
		this.dm.reserveDepths ("TRENDVALUESABOVE", (this.numTrendLines - this.numTrendLinesBelow));
		//Data Values
		this.dm.reserveDepths ("DATAVALUES", this.num);
		//Roll over Color band
		this.dm.reserveDepths ("ROLLOVERBAND", 1);
		//Legend
		this.dm.reserveDepths ("LEGEND", 1);
	}
	/**
	* calcCanvasCoords method calculates the co-ordinates of the canvas
	* taking into consideration everything that is to be drawn on the chart.
	* It finally stores the canvas as an object.
	*/
	private function calcCanvasCoords ()
	{
		//Loop variable
		var i : Number;
		//Update config. We show volume chart only if volume data is present and user
		//has opted to show it.
		this.config.showVolume = toBoolean (this.config.showVolume & this.params.showVolumeChart);
		//Update showLegend - check if we've anything to show in legend?
		this.params.showLegend = (this.numLegendItems > 0) ?this.params.showLegend : false;
		//Based on label step, set showLabel of each data point as required.
		//Visible label count
		var visibleCount : Number = 0;
		var finalVisibleCount : Number = 0;
		for (i = 1; i <= this.numCat; i ++)
		{
			//Now, the label can be preset to be hidden (set via XML)
			if (this.categories [i].showLabel)
			{
				visibleCount ++;
				//If label step is defined, we need to set showLabel of those
				//labels which fall on step as false.
				if ((i - 1) % this.params.labelStep == 0)
				{
					this.categories [i].showLabel = true;
				} else 
				{
					this.categories [i].showLabel = false;
				}
			}
			//Update counter
			finalVisibleCount = (this.categories [i].showLabel) ? (finalVisibleCount + 1) : (finalVisibleCount);
		}
		//We now need to calculate the available Width on the canvas.
		//Available width = total Chart width minus the list below
		// - Left and Right Margin
		// - PYAxisName (if to be shown) (+ yAxisNamePadding)
		// - VYAxisName (if to be shown) (+ yAxisNamePadding)
		// - Horizontal Trend Values (+ yAxisValuesPadding)
		// - Price Div Line Values (+ yAxisValuesPadding)
		// - Volume Div Line Values (+ yAxisValuesPadding)
		var canvasWidth : Number = this.width - (this.params.chartLeftMargin + this.params.chartRightMargin);
		//Set canvas startX
		var canvasStartX : Number = this.params.chartLeftMargin;
		//Variables to store the maximum width of both the y-axis names
		var PYAxisNameWidth : Number = 0;
		var VYAxisNameWidth : Number = 0;
		//If Price y-axis name is to be shown, simulate it and get the width
		if (this.params.PYAxisName != "")
		{
			//Get style object
			var yAxisNameStyle : Object = this.styleM.getTextStyle (this.objects.PYAXISNAME);
			if (this.params.rotateYAxisName)
			{
				//Set embedded font - as we need to rotate
				yAxisNameStyle.font = _embeddedFont;
				//Un-bold and un-italicize
				yAxisNameStyle.bold = false;
				yAxisNameStyle.italic = false;
				//Create text field to get width
				var yAxisNameObj : Object = createText (true, this.params.PYAxisName, this.tfTestMC, 1, testTFX, testTFY, 90, yAxisNameStyle, false, 0, 0);
				//Store y-axis name width
				PYAxisNameWidth = yAxisNameObj.width;
			} else 
			{
				//If the y-axis name is not to be rotated
				//Calculate the width of the text if in full horizontal mode
				//Create text field to get width
				var yAxisNameObj : Object = createText (true, this.params.PYAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, yAxisNameStyle, false, 0, 0);
				//Store y-axis name width
				PYAxisNameWidth = yAxisNameObj.width;
			}
			delete yAxisNameStyle;
			delete yAxisNameObj;
		}
		//If Price y-axis name is to be shown, simulate it and get the width
		if (this.params.VYAxisName != "")
		{
			//Get style object
			var yAxisNameStyle : Object = this.styleM.getTextStyle (this.objects.VYAXISNAME);
			if (this.params.rotateYAxisName)
			{
				//Set embedded font - as we need to rotate
				yAxisNameStyle.font = _embeddedFont;
				//Un-bold and un-italicize
				yAxisNameStyle.bold = false;
				yAxisNameStyle.italic = false;
				//Create text field to get width
				var yAxisNameObj : Object = createText (true, this.params.VYAxisName, this.tfTestMC, 1, testTFX, testTFY, 90, yAxisNameStyle, false, 0, 0);
				//Store y-axis name width
				VYAxisNameWidth = yAxisNameObj.width;
			} else 
			{
				//If the y-axis name is not to be rotated
				//Calculate the width of the text if in full horizontal mode
				//Create text field to get width
				var yAxisNameObj : Object = createText (true, this.params.VYAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, yAxisNameStyle, false, 0, 0);
				//Store y-axis name width
				VYAxisNameWidth = yAxisNameObj.width;
			}
			delete yAxisNameStyle;
			delete yAxisNameObj;
		}
		//Now, accomodated width if either of the labels are to be shown
		if ((this.params.VYAxisName != "") || (this.params.VYAxisName != ""))
		{
			//If not to be shown in rotated form
			if ( ! this.params.rotateYAxisName)
			{
				//Get a value for this.params.yAxisNameWidth
				this.params.yAxisNameWidth = getFN (this.params.yAxisNameWidth, Math.max (PYAxisNameWidth, VYAxisNameWidth));
				//Get the lesser of the width (to avoid un-necessary space)
				this.params.yAxisNameWidth = Math.min (this.params.yAxisNameWidth, Math.max (PYAxisNameWidth, VYAxisNameWidth));
				//Accomodate width and padding for y-axis name
				canvasStartX = canvasStartX + this.params.yAxisNameWidth + this.params.yAxisNamePadding;
				canvasWidth = canvasWidth - this.params.yAxisNameWidth - this.params.yAxisNamePadding;
			}else
			{
				//Accomodate width and padding for y-axis name
				canvasStartX = canvasStartX + Math.max (PYAxisNameWidth, VYAxisNameWidth) + this.params.yAxisNamePadding;
				canvasWidth = canvasWidth - Math.max (PYAxisNameWidth, VYAxisNameWidth) - this.params.yAxisNamePadding;
			}
		}
		//We need to accomodate width for any trend line text (horizontal).
		//Also iterate through all trend lines whose values are to be shown on
		//left side of the canvas.
		//Get style object
		var trendStyle : Object = this.styleM.getTextStyle (this.objects.TRENDVALUES);
		var trendObj : Object;
		var trendMaxWidth : Number = 0;
		for (i = 1; i <= this.numTrendLines; i ++)
		{
			if (this.trendLines [i].isValid == true)
			{
				//If it's a valid trend line
				//Get the width of the text
				trendObj = createText (true, this.trendLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				trendMaxWidth = Math.max (trendObj.width, trendMaxWidth);
			}
		}
		//Accomodate for trend width
		if (trendMaxWidth > 0)
		{
			canvasStartX = canvasStartX + trendMaxWidth + this.params.yAxisValuesPadding;
			canvasWidth = canvasWidth - trendMaxWidth - this.params.yAxisValuesPadding;
		}
		//Accomodate width for y-axis values. Now, y-axis values can be either price
		//or volume y-values.
		var yAxisValMaxWidth : Number = 0;
		var divLineObj : Object;
		var divStyle : Object = this.styleM.getTextStyle (this.objects.YAXISVALUES);
		//Iterate through all the price div line values
		for (i = 1; i < this.pDivLines.length; i ++)
		{
			//If div line value is to be shown
			if (this.pDivLines [i].showValue)
			{
				//Get the width of the text
				divLineObj = createText (true, this.pDivLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
				//Accomodate
				yAxisValMaxWidth = Math.max (divLineObj.width, yAxisValMaxWidth);
			}
		}
		//Iterate through all the volume div line values
		for (i = 1; i < this.vDivLines.length; i ++)
		{
			//If div line value is to be shown
			if (this.vDivLines [i].showValue)
			{
				//Get the width of the text
				divLineObj = createText (true, this.vDivLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
				//Accomodate
				yAxisValMaxWidth = Math.max (divLineObj.width, yAxisValMaxWidth);
			}
		}
		delete divLineObj;
		//Accomodate trend right text width
		if (yAxisValMaxWidth > 0)
		{
			canvasWidth = canvasWidth - yAxisValMaxWidth - this.params.yAxisValuesPadding;
		}
		//Round them off finally to avoid distorted pixels
		canvasStartX = int (canvasStartX);
		canvasWidth = int (canvasWidth);
		//We finally have canvas Width and canvas Start X
		//-----------------------------------------------------------------------------------//
		//Now, we need to calculate the available Height on the canvas.
		//Available height = total Chart height minus the list below
		// - Chart Top and Bottom Margins
		// - Space for Caption, Sub Caption and caption padding
		// - Height of data labels
		// - Vertical trend line values
		// - Legend (If to be shown at bottom position)
		//Initialize canvasHeight to total height minus margins
		var canvasHeight : Number = this.height - (this.params.chartTopMargin + this.params.chartBottomMargin);
		//Set canvasStartY
		var canvasStartY : Number = this.params.chartTopMargin;
		//Now, if we've to show caption
		if (this.params.caption != "")
		{
			//Create text field to get height
			var captionObj : Object = createText (true, this.params.caption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle (this.objects.CAPTION) , false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY + captionObj.height;
			canvasHeight = canvasHeight - captionObj.height;
			//Create element for caption - to store width & height
			this.elements.caption = returnDataAsElement (0, 0, captionObj.width, captionObj.height);
			delete captionObj;
		}
		//Now, if we've to show sub-caption
		if (this.params.subCaption != "")
		{
			//Create text field to get height
			var subCaptionObj : Object = createText (true, this.params.subCaption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle (this.objects.SUBCAPTION) , false, 0, 0);
			//Store the height
			canvasStartY = canvasStartY + subCaptionObj.height;
			canvasHeight = canvasHeight - subCaptionObj.height;
			//Create element for sub caption - to store height
			this.elements.subCaption = returnDataAsElement (0, 0, subCaptionObj.width, subCaptionObj.height);
			delete subCaptionObj;
		}
		//Now, if either caption or sub-caption was shown, we also need to adjust caption padding
		if (this.params.caption != "" || this.params.subCaption != "")
		{
			//Account for padding
			canvasStartY = canvasStartY + this.params.captionPadding;
			canvasHeight = canvasHeight - this.params.captionPadding;
		}
		//Now, if data labels are to be shown, we need to account for their heights
		//Data labels can be rendered in 3 ways:
		//1. Normal - no staggering - no wrapping - no rotation
		//2. Wrapped - no staggering - no rotation
		//3. Staggered - no wrapping - no rotation
		//4. Rotated - no staggering - no wrapping
		//Placeholder to store max height
		this.config.maxLabelHeight = 0;
		this.config.labelAreaHeight = 0;
		var labelObj : Object;
		var labelStyleObj : Object = this.styleM.getTextStyle (this.objects.DATALABELS);
		if (this.params.labelDisplay == "ROTATE")
		{
			//Case 4: If the labels are rotated, we iterate through all the string labels
			//provided to us and get the height and store max.
			for (i = 1; i <= this.numCat; i ++)
			{
				//If the label is to be shown
				if (this.categories [i].showLabel)
				{
					//Set style bold/italic to false and font to embedded font
					labelStyleObj.font = _embeddedFont;
					labelStyleObj.bold = false;
					labelStyleObj.italic = false;
					//Create text box and get height
					labelObj = createText (true, this.categories [i].label, this.tfTestMC, 1, testTFX, testTFY, this.config.labelAngle, labelStyleObj, false, 0, 0);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height > this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else if (this.params.labelDisplay == "WRAP")
		{
			//Case 2 (WRAP): Create all the labels on the chart. Set width as
			//totalAvailableWidth/finalVisibleCount.
			//Set max height as 50% of available canvas height at this point of time. Find all
			//and select the max one.
			var maxLabelWidth : Number = (canvasWidth / finalVisibleCount);
			var maxLabelHeight : Number = (canvasHeight / 2);
			//Store it in config for later usage
			this.config.wrapLabelWidth = maxLabelWidth;
			this.config.wrapLabelHeight = maxLabelHeight;
			for (i = 1; i <= this.numCat; i ++)
			{
				//If the label is to be shown
				if (this.categories [i].showLabel)
				{
					//Create text box and get height
					labelObj = createText (true, this.categories [i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, true, maxLabelWidth, maxLabelHeight);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height > this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else 
		{
			//Case 1,3: Normal or Staggered Label
			//We iterate through all the labels, and if any of them has &lt or < (HTML marker)
			//embedded in them, we add them to the array, as for them, we'll need to individually
			//create and see the text height. Also, the first element in the array - we set as
			//ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=....
			//Create array to store labels.
			var strLabels : Array = new Array ();
			strLabels.push ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=/*-+~`");
			//Now, iterate through all the labels and for those visible labels, whcih have < sign,
			//add it to array.
			for (i = 1; i <= this.numCat; i ++)
			{
				//If the label is to be shown
				if (this.categories [i].showLabel)
				{
					if ((this.categories [i].label.indexOf ("&lt;") > - 1) || (this.categories [i].label.indexOf ("<") > - 1))
					{
						strLabels.push (this.categories [i].label);
					}
				}
			}
			//Now, we've the array for which we've to check height (for each element).
			for (i = 0; i < strLabels.length; i ++)
			{
				//Create text box and get height
				labelObj = createText (true, this.categories [i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, false, 0, 0);
				//Store the larger
				this.config.maxLabelHeight = (labelObj.height > this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
			}
			//We now have the max label height. If it's staggered, then store accordingly, else
			//simple mode
			if (this.params.labelDisplay == "STAGGER")
			{
				//Multiply max label height by stagger lines.
				this.config.labelAreaHeight = this.params.staggerLines * this.config.maxLabelHeight;
			} else 
			{
				this.config.labelAreaHeight = this.config.maxLabelHeight;
			}
		}
		if (this.config.labelAreaHeight > 0)
		{
			//Deduct the calculated label height from canvas height
			//labelPadding twice - top and bottom
			canvasHeight = canvasHeight - this.config.labelAreaHeight - 2 * this.params.labelPadding;
		}
		//Delete objects
		delete labelObj;
		delete labelStyleObj;
		//If any vertical trend line values are to be shown
		var trendObj : Object;
		var trendStyle : Object = this.styleM.getTextStyle (this.objects.VTRENDVALUES);
		var trendHeight : Number = 0;
		//Now, also check for trend line values that fall on right
		this.config.vTrendHeight = 0;
		for (i = 1; i <= this.numVTrendLines; i ++)
		{
			if (this.vTrendLines [i].isValid == true)
			{
				//If it's a valid trend line
				//Get the height of the text
				trendObj = createText (true, this.vTrendLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				trendHeight = (trendObj.height > trendHeight) ? (trendObj.height) : (trendHeight);
			}
		}
		delete trendObj;
		//Accomodate
		if (trendHeight > 0)
		{
			canvasHeight = canvasHeight - trendHeight;
			//Store vertical trend line text height - will be used later to adjust x-axis name.
			this.config.vTrendHeight = trendHeight;
		}
		//We have canvas start Y and canvas height
		//We now check whether the legend is to be drawn
		if (this.params.showLegend)
		{
			//Object to store dimensions
			var lgndDim:Object;
			//Create container movie clip for legend
			this.lgndMC = this.cMC.createEmptyMovieClip ("Legend", this.dm.getDepth ("LEGEND"));
			//Create instance of legend
			//Maximum Height - 50% of stage
			lgnd = new Legend (lgndMC, this.styleM.getTextStyle (this.objects.LEGEND) , this.params.legendPosition, canvasStartX + canvasWidth / 2, this.height / 2, canvasWidth, (this.height - (this.params.chartTopMargin + this.params.chartBottomMargin)) * 0.5, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor);
			//Feed data set series Name for legend
			for (i = 1; i <= this.numTS; i ++)
			{
				if (this.trendset [i].includeInLegend && this.trendset [i].name != "")
				{
					lgnd.addItem (this.trendset [i].name, this.trendset [i].color);
				}
			}
			//If user has defined a caption for the legend, set it
			if (this.params.legendCaption!=""){
				lgnd.setCaption(this.params.legendCaption);
			}
			//Whether to use circular marker
			lgnd.useCircleMarker(this.params.legendMarkerCircle);
			lgndDim = lgnd.getDimensions ();
			//Now deduct the height from the calculated canvas height
			canvasHeight = canvasHeight - lgndDim.height - this.params.legendPadding;
			//Re-set the legend position
			this.lgnd.resetXY (canvasStartX + canvasWidth / 2, this.height - this.params.chartBottomMargin - lgndDim.height / 2);
		}
		//Create an element to represent the canvas now.
		this.elements.canvas = returnDataAsElement (canvasStartX, canvasStartY, canvasWidth, canvasHeight);
		if (this.config.showVolume)
		{
			//Fix Price and Volume Canvas
			this.elements.PCanvas = returnDataAsElement (canvasStartX, canvasStartY, canvasWidth, canvasHeight * ((100 - this.params.volumeHeightPercent) / 100));
			this.elements.VCanvas = returnDataAsElement (canvasStartX, this.elements.PCanvas.toY + this.config.labelAreaHeight + 2 * this.params.labelPadding, canvasWidth, canvasHeight * (this.params.volumeHeightPercent / 100));
		}else
		{
			this.elements.PCanvas = returnDataAsElement (canvasStartX, canvasStartY, canvasWidth, canvasHeight);
		}
	}
	/**
	* calculatePoints method calculates the points for all data elements on the chart.
	*/
	private function calculatePoints () : Void
	{
		//Loop variable
		var i : Number, j : Number;
		//Format all the numbers on the chart and store their display values
		//We format and store here itself, so that later, whenever needed,
		//we just access displayValue instead of formatting once again.
		//Also set tool tip text values
		var toolText : String
		for (i = 1; i <= this.num; i ++)
		{
			//Format and store
			this.data [i].oDisplayValue = formatNumber (this.data [i].open, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
			this.data [i].cDisplayValue = formatNumber (this.data [i].close, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
			if (this.params.plotPriceAs == "CANDLESTICK" || this.params.plotPriceAs == "BAR")
			{
				//We format high and low values only if in candlestick or bar mode.
				this.data [i].hDisplayValue = formatNumber (this.data [i].high, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
				this.data [i].lDisplayValue = formatNumber (this.data [i].low, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix);
			}
			if (this.config.showVolume)
			{
				if (this.data [i].volume)
				{
					this.data [i].vDisplayValue = formatNumber (this.data [i].volume, this.params.vFormatNumber, this.params.vDecimals, this.params.vForceDecimals, this.params.vFormatNumberScale, this.params.vDefaultNumberScale, this.config.vnsv, this.config.vnsu, this.params.vNumberPrefix, this.params.vNumberSuffix);
				}else
				{
					this.data [i].vDisplayValue = "";
				}
			}
			//Tool tip text.
			if (this.data [i].toolText == undefined || this.data [i].toolText == "")
			{
				//If the tool tip text is not already defined
				if (this.params.plotPriceAs == "LINE")
				{
					//If in line mode
					//If Closing price
					if (this.params.plotClosingPrice)
					{
						toolText = "<B>Close: </B>" + this.data [i].cDisplayValue;
					}else
					{
						toolText = "<B>Open: </B>" + this.data [i].oDisplayValue;
					}
				}else
				{
					//Else, if in candle stick/bar mode
					toolText = "<B>Open: </B>" + this.data [i].oDisplayValue + "<BR>";
					toolText = toolText + "<B>Close: </B>" + this.data [i].cDisplayValue + "<BR>";
					toolText = toolText + "<B>High: </B>" + this.data [i].hDisplayValue + "<BR>";
					toolText = toolText + "<B>Low: </B>" + this.data [i].lDisplayValue;
				}
				//If volume is defined
				if (this.config.showVolume && this.data [i].volume != - 1)
				{
					toolText = toolText + "<BR><B>Volume: </B>" + this.data [i].vDisplayValue;
				}
				this.data [i].toolText = toolText;
			}
		}
		//Get spacing on the chart. Width of data plots
		var plotArea : Number = this.elements.PCanvas.w - 2 * this.params.canvasPadding;
		var plotSpace : Number = (this.params.plotSpacePercent / 100) * plotArea;
		var plotWidth : Number = (plotArea - plotSpace) / (this.num);
		//If plot width/2>canvasPadding and we've to show volume bars, we readjust canvasPadding
		if (this.config.showVolume && ((plotWidth/2)>this.params.canvasPadding)){
			this.params.canvasPadding = (plotWidth+this.params.canvasPadding)/2;
			//Recalculate other things
			plotArea = this.elements.PCanvas.w - 2 * this.params.canvasPadding;
			plotSpace = (this.params.plotSpacePercent / 100) * plotArea;
			plotWidth = (plotArea - plotSpace) / (this.num);
		}
		if ((this.params.plotPriceAs != "LINE") && (plotWidth>this.params.maxPlotWidth)){
			plotWidth = this.params.maxPlotWidth;
			this.params.canvasPadding = this.params.maxPlotWidth*1.5;
		}
		//Store in config
		this.config.plotWidth = plotWidth;
		//Calculate x-position of categories
		for (i = 1; i <= this.numCat; i ++)
		{
			this.categories [i].x = this.getAxisPosition (this.categories [i].xv, this.config.xMax, this.config.xMin, this.elements.PCanvas.x, this.elements.PCanvas.toX, false, this.params.canvasPadding);
		}
		//Calculate co-ordinates for price chart
		for (i = 1; i <= this.num; i ++)
		{
			//X-Position
			this.data [i].x = this.getAxisPosition (this.data [i].xv, this.config.xMax, this.config.xMin, this.elements.PCanvas.x, this.elements.PCanvas.toX, false, this.params.canvasPadding);
			//Calculate Y Positions
			if (this.params.plotPriceAs == "LINE")
			{
				//If in line mode & If Closing price to be plotted
				if (this.params.plotClosingPrice)
				{
					this.data [i].cy = this.getAxisPosition (this.data [i].close, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0)
				}else
				{
					this.data [i].oy = this.getAxisPosition (this.data [i].open, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0)
				}
				//Also set value TB's Y Position
				if (this.data [i].valueText != "")
				{
					this.data [i].valTBY = ((this.params.plotClosingPrice) ?this.data [i].cy : this.data [i].oy) - this.params.valuePadding;
				}
			}else
			{
				this.data [i].oy = this.getAxisPosition (this.data [i].open, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0)
				this.data [i].cy = this.getAxisPosition (this.data [i].close, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0)
				this.data [i].hy = this.getAxisPosition (this.data [i].high, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0)
				this.data [i].ly = this.getAxisPosition (this.data [i].low, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0)
				//Also set value TB's Y Position
				if (this.data [i].valueText != "")
				{
					this.data [i].valTBY = Math.min (Math.min (this.data [i].oy, this.data [i].cy) , Math.min (this.data [i].hy, this.data [i].ly)) - this.params.valuePadding;
				}
			}
		}
		//Calculate co-ordinates for volume chart
		if (this.config.showVolume)
		{
			var dataBase : Number = this.getAxisPosition (this.config.VYMin, this.config.VYMax, this.config.VYMin, this.elements.VCanvas.y, this.elements.VCanvas.toY, true, 0)
			var dataEndY : Number;
			//Now, store the positions of the columns
			for (i = 1; i <= this.num; i ++)
			{
				//X-Position
				this.data [i].vx = this.data [i].x;
				//Set the y position
				this.data [i].vy = dataBase;
				//Height for each column
				dataEndY = this.getAxisPosition (this.data [i].volume, this.config.VYMax, this.config.VYMin, this.elements.VCanvas.y, this.elements.VCanvas.toY, true, 0);
				//Negate to cancel Flash's reverse Y Co-ordinate system
				this.data [i].vh = - (dataEndY - dataBase);
				//Width
				this.data [i].vw = plotWidth;
			}
		}
		//Calculate positions for the trend sets
		for (i = 1; i <= this.numTS; i ++)
		{
			for (j = 1; j <= this.trendset [i].num; j ++)
			{
				//Get x-position
				this.trendset [i].data [j].x = this.getAxisPosition (this.trendset [i].data [j].xv, this.config.xMax, this.config.xMin, this.elements.PCanvas.x, this.elements.PCanvas.toX, false, this.params.canvasPadding);
				//Get y-position
				this.trendset [i].data [j].y = this.getAxisPosition (this.trendset [i].data [j].value, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0);
			}
		}
	}
	/**
	* feedMacros method feeds macros and their respective values
	* to the macro instance. This method is to be called after
	* calculatePoints, as we set the canvas and chart co-ordinates
	* in this method, which is known to us only after calculatePoints.
	*	@return	Nothing
	*/
	private function feedMacros () : Void 
	{
		//Feed macros one by one
		//Chart dimension macros
		this.macro.addMacro ("$chartStartX", this.x);
		this.macro.addMacro ("$chartStartY", this.y);
		this.macro.addMacro ("$chartWidth", this.width);
		this.macro.addMacro ("$chartHeight", this.height);
		this.macro.addMacro ("$chartEndX", this.width);
		this.macro.addMacro ("$chartEndY", this.height);
		this.macro.addMacro ("$chartCenterX", this.width / 2);
		this.macro.addMacro ("$chartCenterY", this.height / 2);
		//Price Canvas dimension macros
		this.macro.addMacro ("$canvasStartX", this.elements.PCanvas.x);
		this.macro.addMacro ("$canvasStartY", this.elements.PCanvas.y);
		this.macro.addMacro ("$canvasWidth", this.elements.PCanvas.w);
		this.macro.addMacro ("$canvasHeight", this.elements.PCanvas.h);
		this.macro.addMacro ("$canvasEndX", this.elements.PCanvas.toX);
		this.macro.addMacro ("$canvasEndY", this.elements.PCanvas.toY);
		this.macro.addMacro ("$canvasCenterX", this.elements.PCanvas.x + (this.elements.PCanvas.w / 2));
		this.macro.addMacro ("$canvasCenterY", this.elements.PCanvas.y + (this.elements.PCanvas.h / 2));
	}
	/**
	* calcTrendLinePos method helps us calculate the y-co ordinates for the
	* trend lines
	* NOTE: validateTrendLines and calcTrendLinePos could have been composed
	*			into a single method. However, in calcTrendLinePos, we need the
	*			canvas position, which is possible only after calculatePoints
	*			method has been called. But, in calculatePoints, we need the
	*			displayValue of each trend line, which is being set in
	*			validateTrendLines. So, validateTrendLines is invoked before
	*			calculatePoints method and calcTrendLinePos is invoked after.
	*	@return		Nothing
	*/
	private function calcTrendLinePos ()
	{
		//Loop variable
		var i : Number;
		//Run for horizontal trend lines
		for (i = 0; i <= this.numTrendLines; i ++)
		{
			//We proceed only if the trend line is valid
			if (this.trendLines [i].isValid == true)
			{
				//Calculate and store y-positions
				this.trendLines [i].y = this.getAxisPosition (this.trendLines [i].startValue, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0);
				//If end value is different from start value
				if (this.trendLines [i].startValue != this.trendLines [i].endValue)
				{
					//Calculate y for end value
					this.trendLines [i].toY = this.getAxisPosition (this.trendLines [i].endValue, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0);
					//Now, if it's a trend zone, we need mid value
					if (this.trendLines [i].isTrendZone)
					{
						//For textbox y position, we need mid value.
						this.trendLines [i].tbY = Math.min (this.trendLines [i].y, this.trendLines [i].toY) + (Math.abs (this.trendLines [i].y - this.trendLines [i].toY) / 2);
					} else 
					{
						this.trendLines [i].tbY = this.trendLines [i].y;
					}
					//Height
					this.trendLines [i].h = (this.trendLines [i].toY - this.trendLines [i].y);
				} else 
				{
					//Just copy
					this.trendLines [i].toY = this.trendLines [i].y;
					//Set same position for value tb
					this.trendLines [i].tbY = this.trendLines [i].y;
					//Height
					this.trendLines [i].h = 0;
				}
			}
		}
		//Run for vertical trend lines
		for (i = 0; i <= this.numVTrendLines; i ++)
		{
			//We proceed only if the trend line is valid
			if (this.vTrendLines [i].isValid == true)
			{
				//Calculate and store x-positions
				this.vTrendLines [i].x = this.getAxisPosition (this.vTrendLines [i].startValue, this.config.xMax, this.config.xMin, this.elements.PCanvas.x, this.elements.PCanvas.toX, false, this.params.canvasPadding);
				//If end value is different from start value
				if (this.vTrendLines [i].startValue != this.vTrendLines [i].endValue)
				{
					//Calculate x for end value
					this.vTrendLines [i].toX = this.getAxisPosition (this.vTrendLines [i].endValue, this.config.xMax, this.config.xMin, this.elements.PCanvas.x, this.elements.PCanvas.toX, false, this.params.canvasPadding);
					//Now, if it's a trend zone, we need mid value
					if (this.vTrendLines [i].isTrendZone)
					{
						//For textbox x position, we need mid value.
						this.vTrendLines [i].tbX = Math.min (this.vTrendLines [i].x, this.vTrendLines [i].toX) + (Math.abs (this.vTrendLines [i].x - this.vTrendLines [i].toX) / 2);
					} else 
					{
						this.vTrendLines [i].tbX = this.vTrendLines [i].toX;
					}
					//Width
					this.vTrendLines [i].w = (this.vTrendLines [i].toX - this.vTrendLines [i].x);
				} else 
				{
					//Just copy
					this.vTrendLines [i].toX = this.vTrendLines [i].x;
					//Set same position for value tb
					this.vTrendLines [i].tbX = this.vTrendLines [i].x;
					//Width
					this.vTrendLines [i].w = 0;
				}
			}
		}
	}
	// ----------------- VISUAL RENDERING METHODS ---------------- //
	/**
	* drawPCanvas method renders the price chart canvas.
	*	@return	Nothing
	*/
	private function drawPCanvas () : Void 
	{
		//Create a new movie clip container for canvas
		var canvasMC = this.cMC.createEmptyMovieClip ("PCanvas", this.dm.getDepth ("PCANVAS"));
		//Parse the color, alpha and ratio array
		var canvasColor : Array = ColorExt.parseColorList (this.params.canvasBgColor);
		var canvasAlpha : Array = ColorExt.parseAlphaList (this.params.canvasBgAlpha, canvasColor.length);
		var canvasRatio : Array = ColorExt.parseRatioList (this.params.canvasBgRatio, canvasColor.length);
		//Set border properties - not visible
		canvasMC.lineStyle ();
		//Move to (-w/2, 0);
		canvasMC.moveTo ( - (this.elements.PCanvas.w / 2) , - (this.elements.PCanvas.h / 2));
		//Create matrix object
		var matrix : Object = {
			matrixType : "box", w : this.elements.PCanvas.w, h : this.elements.PCanvas.h, x : - (this.elements.PCanvas.w / 2) , y : - (this.elements.PCanvas.h / 2) , r : MathExt.toRadians (this.params.canvasBgAngle)
		};
		//Start the fill.
		canvasMC.beginGradientFill ("linear", canvasColor, canvasAlpha, canvasRatio, matrix);
		//Draw the rectangle with center registration point
		canvasMC.lineTo (this.elements.PCanvas.w / 2, - (this.elements.PCanvas.h / 2));
		canvasMC.lineTo (this.elements.PCanvas.w / 2, this.elements.PCanvas.h / 2);
		canvasMC.lineTo ( - (this.elements.PCanvas.w / 2) , this.elements.PCanvas.h / 2);
		canvasMC.lineTo ( - (this.elements.PCanvas.w / 2) , - (this.elements.PCanvas.h / 2));
		//Set the x and y position
		canvasMC._x = this.elements.PCanvas.x + this.elements.PCanvas.w / 2;
		canvasMC._y = this.elements.PCanvas.y + this.elements.PCanvas.h / 2;
		//End Fill
		canvasMC.endFill ();
		// --------------------------- DRAW CANVAS BORDER --------------------------//
		//Canvas Border
		if (this.params.canvasBorderAlpha > 0)
		{
			//Create a new movie clip container for canvas
			var canvasBorderMC = this.cMC.createEmptyMovieClip ("CanvasBorder", this.dm.getDepth ("PCANVASBORDER"));
			//Set border properties
			canvasBorderMC.lineStyle (this.params.canvasBorderThickness, parseInt (this.params.canvasBorderColor, 16) , this.params.canvasBorderAlpha);
			//Move to (-w/2, 0);
			canvasBorderMC.moveTo ( - (this.elements.PCanvas.w / 2) , - (this.elements.PCanvas.h / 2));
			//Draw the rectangle with center registration point
			canvasBorderMC.lineTo (this.elements.PCanvas.w / 2, - (this.elements.PCanvas.h / 2));
			canvasBorderMC.lineTo (this.elements.PCanvas.w / 2, this.elements.PCanvas.h / 2);
			canvasBorderMC.lineTo ( - (this.elements.PCanvas.w / 2) , this.elements.PCanvas.h / 2);
			canvasBorderMC.lineTo ( - (this.elements.PCanvas.w / 2) , - (this.elements.PCanvas.h / 2));
			//Set the x and y position
			canvasBorderMC._x = this.elements.PCanvas.x + this.elements.PCanvas.w / 2;
			canvasBorderMC._y = this.elements.PCanvas.y + this.elements.PCanvas.h / 2;
		}
		//Apply animation
		if (this.params.animation)
		{
			this.styleM.applyAnimation (canvasBorderMC, this.objects.CANVAS, this.macro, canvasBorderMC._x, - this.elements.PCanvas.w / 2, canvasBorderMC._y, - this.elements.PCanvas.h / 2, 100, 100, 100, null);
			this.styleM.applyAnimation (canvasMC, this.objects.CANVAS, this.macro, canvasMC._x, - this.elements.PCanvas.w / 2, canvasMC._y, - this.elements.PCanvas.h / 2, 100, 100, 100, null);
		}
		//Apply filters
		this.styleM.applyFilters (canvasMC, this.objects.CANVAS);
		clearInterval (this.config.intervals.PCanvas);
	}
	/**
	* drawVCanvas method renders the price chart canvas.
	*	@return	Nothing
	*/
	private function drawVCanvas () : Void 
	{
		if (this.config.showVolume)
		{
			//Create a new movie clip container for canvas
			var canvasMC = this.cMC.createEmptyMovieClip ("VCanvas", this.dm.getDepth ("VCANVAS"));
			//Parse the color, alpha and ratio array
			var canvasColor : Array = ColorExt.parseColorList (this.params.canvasBgColor);
			var canvasAlpha : Array = ColorExt.parseAlphaList (this.params.canvasBgAlpha, canvasColor.length);
			var canvasRatio : Array = ColorExt.parseRatioList (this.params.canvasBgRatio, canvasColor.length);
			//Set border properties - not visible
			//canvasMC.lineStyle(this.params.canvasBorderThickness, parseInt(this.params.canvasBorderColor, 16), this.params.canvasBorderAlpha);
			canvasMC.lineStyle ();
			//Move to (-w/2, 0);
			canvasMC.moveTo ( - (this.elements.VCanvas.w / 2) , - (this.elements.VCanvas.h / 2));
			//Create matrix object
			var matrix : Object = {
				matrixType : "box", w : this.elements.VCanvas.w, h : this.elements.VCanvas.h, x : - (this.elements.VCanvas.w / 2) , y : - (this.elements.VCanvas.h / 2) , r : MathExt.toRadians (this.params.canvasBgAngle)
			};
			//Start the fill.
			canvasMC.beginGradientFill ("linear", canvasColor, canvasAlpha, canvasRatio, matrix);
			//Draw the rectangle with center registration point
			canvasMC.lineTo (this.elements.VCanvas.w / 2, - (this.elements.VCanvas.h / 2));
			canvasMC.lineTo (this.elements.VCanvas.w / 2, this.elements.VCanvas.h / 2);
			canvasMC.lineTo ( - (this.elements.VCanvas.w / 2) , this.elements.VCanvas.h / 2);
			canvasMC.lineTo ( - (this.elements.VCanvas.w / 2) , - (this.elements.VCanvas.h / 2));
			//Set the x and y position
			canvasMC._x = this.elements.VCanvas.x + this.elements.VCanvas.w / 2;
			canvasMC._y = this.elements.VCanvas.y + this.elements.VCanvas.h / 2;
			//End Fill
			canvasMC.endFill ();
			// --------------------------- DRAW CANVAS BORDER --------------------------//
			//Canvas Border
			if (this.params.canvasBorderAlpha > 0)
			{
				//Create a new movie clip container for canvas
				var canvasBorderMC = this.cMC.createEmptyMovieClip ("CanvasBorder", this.dm.getDepth ("VCANVASBORDER"));
				//Set border properties
				canvasBorderMC.lineStyle (this.params.canvasBorderThickness, parseInt (this.params.canvasBorderColor, 16) , this.params.canvasBorderAlpha);
				//Move to (-w/2, 0);
				canvasBorderMC.moveTo ( - (this.elements.VCanvas.w / 2) , - (this.elements.VCanvas.h / 2));
				//Draw the rectangle with center registration point
				canvasBorderMC.lineTo (this.elements.VCanvas.w / 2, - (this.elements.VCanvas.h / 2));
				canvasBorderMC.lineTo (this.elements.VCanvas.w / 2, this.elements.VCanvas.h / 2);
				canvasBorderMC.lineTo ( - (this.elements.VCanvas.w / 2) , this.elements.VCanvas.h / 2);
				canvasBorderMC.lineTo ( - (this.elements.VCanvas.w / 2) , - (this.elements.VCanvas.h / 2));
				//Set the x and y position
				canvasBorderMC._x = this.elements.VCanvas.x + this.elements.VCanvas.w / 2;
				canvasBorderMC._y = this.elements.VCanvas.y + this.elements.VCanvas.h / 2;
			}
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (canvasBorderMC, this.objects.CANVAS, this.macro, canvasBorderMC._x, - this.elements.VCanvas.w / 2, canvasBorderMC._y, - this.elements.VCanvas.h / 2, 100, 100, 100, null);
				this.styleM.applyAnimation (canvasMC, this.objects.CANVAS, this.macro, canvasMC._x, - this.elements.VCanvas.w / 2, canvasMC._y, - this.elements.VCanvas.h / 2, 100, 100, 100, null);
			}
			//Apply filters
			this.styleM.applyFilters (canvasMC, this.objects.CANVAS);
		}
		clearInterval (this.config.intervals.VCanvas);
	}
	/**
	* drawRollOverBand method draws the roll over band.
	*/
	private function drawRollOverBand () : Void
	{
		if (this.params.showToolTip)
		{
			//Create movie clip
			this.config.rollMC = this.cMC.createEmptyMovieClip ("RollOverBand", this.dm.getDepth ("ROLLOVERBAND"));
			//Move to plot position
			this.config.rollMC.moveTo (0, 0);
			//Color it up.
			this.config.rollMC.lineStyle ();
			this.config.rollMC.beginFill (parseInt (this.params.rollOverBandColor, 16) , this.params.rollOverBandAlpha);
			//Color top par
			this.config.rollMC.lineTo (this.config.plotWidth / 2, 0);
			this.config.rollMC.lineTo (this.config.plotWidth / 2, this.elements.PCanvas.h);
			this.config.rollMC.lineTo ( - this.config.plotWidth / 2, this.elements.PCanvas.h);
			this.config.rollMC.lineTo ( - this.config.plotWidth / 2, 0);
			this.config.rollMC.lineTo (0, 0);
			this.config.rollMC.endFill ();
			//Now if volume chart is to be shown, color bottom part also
			if (this.config.showVolume)
			{
				this.config.rollMC.moveTo (0, this.elements.VCanvas.y - this.elements.canvas.y);
				this.config.rollMC.beginFill (parseInt (this.params.rollOverBandColor, 16) , this.params.rollOverBandAlpha);
				this.config.rollMC.lineTo (this.config.plotWidth / 2, this.elements.VCanvas.y - this.elements.canvas.y);
				this.config.rollMC.lineTo (this.config.plotWidth / 2, this.elements.VCanvas.y - this.elements.canvas.y + this.elements.VCanvas.h);
				this.config.rollMC.lineTo ( - this.config.plotWidth / 2, this.elements.VCanvas.y - this.elements.canvas.y + this.elements.VCanvas.h);
				this.config.rollMC.lineTo ( - this.config.plotWidth / 2, this.elements.VCanvas.y - this.elements.canvas.y);
				this.config.rollMC.lineTo (0, this.elements.VCanvas.y - this.elements.canvas.y);
				this.config.rollMC.endFill ();
			}
			//Hide initially
			this.config.rollMC._x = - 2000;
			//Set Y Position
			this.config.rollMC._y = this.elements.canvas.y;
		}
	}
	/**
	* positionRollOverBand positions the roll over band over a data item.
	*/
	private function positionRollOverBand (index : Number) : Void
	{
		this.config.rollMC._x = this.data [index].x;
	}
	/**
	* hideRollOverBand hides the band
	*/
	private function hideRollOverBand () : Void
	{
		this.config.rollMC._x = - 2000;
	}
	/**
	* drawHeaders method renders the following on the chart:
	* CAPTION, SUBCAPTION, PYAXISNAME, VYAXISNAME
	*/
	private function drawHeaders ()
	{
		//Render caption
		if (this.params.caption != "")
		{
			var captionStyleObj : Object = this.styleM.getTextStyle (this.objects.CAPTION);
			captionStyleObj.align = "center";
			captionStyleObj.vAlign = "bottom";
			var captionObj : Object = createText (false, this.params.caption, this.cMC, this.dm.getDepth ("CAPTION") , this.elements.canvas.x + (this.elements.canvas.w / 2) , this.params.chartTopMargin, 0, captionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (captionObj.tf, this.objects.CAPTION, this.macro, this.elements.canvas.x + (this.elements.canvas.w / 2) - (this.elements.caption.w / 2) , 0, this.params.chartTopMargin, 0, 100, null, null, null);
			}
			//Apply filters
			this.styleM.applyFilters (captionObj.tf, this.objects.CAPTION);
			//Delete
			delete captionObj;
			delete captionStyleObj;
		}
		//Render sub caption
		if (this.params.subCaption != "")
		{
			var subCaptionStyleObj : Object = this.styleM.getTextStyle (this.objects.SUBCAPTION);
			subCaptionStyleObj.align = "center";
			subCaptionStyleObj.vAlign = "top";
			var subCaptionObj : Object = createText (false, this.params.subCaption, this.cMC, this.dm.getDepth ("SUBCAPTION") , this.elements.canvas.x + (this.elements.canvas.w / 2) , this.elements.canvas.y - this.params.captionPadding, 0, subCaptionStyleObj, false, 0, 0);
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (subCaptionObj.tf, this.objects.SUBCAPTION, this.macro, this.elements.canvas.x + (this.elements.canvas.w / 2) - (this.elements.subCaption.w / 2) , 0, this.elements.canvas.y - this.params.captionPadding - this.elements.subCaption.h, 0, 100, null, null, null);
			}
			//Apply filters
			this.styleM.applyFilters (subCaptionObj.tf, this.objects.SUBCAPTION);
			//Delete
			delete subCaptionObj;
			delete subCaptionStyleObj;
		}
		//Render y-axis name
		if (this.params.PYAxisName != "")
		{
			var yAxisNameStyleObj : Object = this.styleM.getTextStyle (this.objects.PYAXISNAME);
			//Set alignment parameters
			yAxisNameStyleObj.align = "left";
			yAxisNameStyleObj.vAlign = "middle";
			//If the name is to be rotated
			if (this.params.rotateYAxisName)
			{
				//Set font as the embedded font
				yAxisNameStyleObj.font = _embeddedFont;
				//Set bold/italic to false.
				yAxisNameStyleObj.bold = false;
				yAxisNameStyleObj.italic = false;
				var yAxisNameObj : Object = createText (false, this.params.PYAxisName, this.cMC, this.dm.getDepth ("PYAXISNAME") , this.params.chartLeftMargin, this.elements.PCanvas.y + (this.elements.PCanvas.h / 2) , 270, yAxisNameStyleObj, false, 0, 0);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (yAxisNameObj.tf, this.objects.PYAXISNAME, this.macro, yAxisNameObj.tf._x, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			} else 
			{
				//We show horizontal name
				//Adding 1 to this.params.yAxisNameWidth and then passing to avoid line breaks
				var yAxisNameObj : Object = createText (false, this.params.PYAxisName, this.cMC, this.dm.getDepth ("PYAXISNAME") , this.params.chartLeftMargin, this.elements.PCanvas.y + (this.elements.PCanvas.h / 2) , 0, yAxisNameStyleObj, true, this.params.yAxisNameWidth + 1, this.elements.PCanvas.h);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (yAxisNameObj.tf, this.objects.PYAXISNAME, this.macro, yAxisNameObj.tf._x, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}
			//Apply filters
			this.styleM.applyFilters (yAxisNameObj.tf, this.objects.PYAXISNAME);
			//Delete
			delete yAxisNameObj;
			delete yAxisNameStyleObj;
		}
		//Render Volume y-axis name
		if (this.config.showVolume && this.params.VYAxisName != "")
		{
			var yAxisNameStyleObj : Object = this.styleM.getTextStyle (this.objects.VYAXISNAME);
			//Set alignment parameters
			yAxisNameStyleObj.align = "left";
			yAxisNameStyleObj.vAlign = "middle";
			//If the name is to be rotated
			if (this.params.rotateYAxisName)
			{
				//Set font as the embedded font
				yAxisNameStyleObj.font = _embeddedFont;
				//Set bold/italic to false.
				yAxisNameStyleObj.bold = false;
				yAxisNameStyleObj.italic = false;
				var yAxisNameObj : Object = createText (false, this.params.VYAxisName, this.cMC, this.dm.getDepth ("VYAXISNAME") , this.params.chartLeftMargin, this.elements.VCanvas.y + (this.elements.VCanvas.h / 2) , 270, yAxisNameStyleObj, false, 0, 0);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (yAxisNameObj.tf, this.objects.VYAXISNAME, this.macro, yAxisNameObj.tf._x, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			} else 
			{
				//We show horizontal name
				//Adding 1 to this.params.yAxisNameWidth and then passing to avoid line breaks
				var yAxisNameObj : Object = createText (false, this.params.VYAxisName, this.cMC, this.dm.getDepth ("VYAXISNAME") , this.params.chartLeftMargin, this.elements.VCanvas.y + (this.elements.VCanvas.h / 2) , 0, yAxisNameStyleObj, true, this.params.yAxisNameWidth + 1, this.elements.VCanvas.h);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (yAxisNameObj.tf, this.objects.VYAXISNAME, this.macro, yAxisNameObj.tf._x, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}
			//Apply filters
			this.styleM.applyFilters (yAxisNameObj.tf, this.objects.VYAXISNAME);
			//Delete
			delete yAxisNameObj;
			delete yAxisNameStyleObj;
		}
		//Clear Interval
		clearInterval (this.config.intervals.headers);
	}
	/**
	* drawLabels method draws the x-axis labels based on the parameters.
	*/
	private function drawLabels ()
	{
		var labelObj : Object;
		var labelStyleObj : Object = this.styleM.getTextStyle (this.objects.DATALABELS);
		var labelYShift : Number;
		var staggerCycle : Number = 0;
		var staggerAddFn : Number = 1;
		var depth : Number = this.dm.getDepth ("DATALABELS");
		var i : Number;
		for (i = 1; i <= this.numCat; i ++)
		{
			//If the label is to be shown
			if (this.categories [i].showLabel)
			{
				if (this.params.labelDisplay == "ROTATE")
				{
					//Set style bold/italic to false and font to embedded font
					labelStyleObj.font = _embeddedFont;
					labelStyleObj.bold = false;
					labelStyleObj.italic = false;
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Create text box and get height
					labelObj = createText (false, this.categories [i].label, this.cMC, depth, this.categories [i].x, this.elements.PCanvas.toY + this.params.labelPadding, this.config.labelAngle, labelStyleObj, false, 0, 0);
				} else if (this.params.labelDisplay == "WRAP")
				{
					//Case 2 (WRAP)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText (false, this.categories [i].label, this.cMC, depth, this.categories [i].x, this.elements.PCanvas.toY + this.params.labelPadding, 0, labelStyleObj, true, this.config.wrapLabelWidth, this.config.wrapLabelHeight);
				} else if (this.params.labelDisplay == "STAGGER")
				{
					//Case 3 (Stagger)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Need to get cyclic position for staggered textboxes
					//Matrix formed is of 2*this.params.staggerLines - 2 rows
					var pos : Number = i % (2 * this.params.staggerLines - 2);
					//Last element needs to be reset
					pos = (pos == 0) ? (2 * this.params.staggerLines - 2) : pos;
					//Cyclic iteration
					pos = (pos > this.params.staggerLines) ? (this.params.staggerLines - (pos % this.params.staggerLines)) : pos;
					//Get position to 0 base
					pos --;
					//Shift accordingly
					var labelYShift : Number = this.config.maxLabelHeight * pos;
					labelObj = createText (false, this.categories [i].label, this.cMC, depth, this.categories [i].x, this.elements.PCanvas.toY + this.params.labelPadding + labelYShift, 0, labelStyleObj, false, 0, 0);
				} else 
				{
					//Render normal label
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText (false, this.categories [i].label, this.cMC, depth, this.categories [i].x, this.elements.PCanvas.toY + this.params.labelPadding, 0, labelStyleObj, false, 0, 0);
				}
				//Apply filter
				this.styleM.applyFilters (labelObj.tf, this.objects.DATALABELS);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (labelObj.tf, this.objects.DATALABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
				}
				//Increase depth
				depth ++;
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.labels);
	}
	/**
	* drawVLines method draws the vertical axis lines on the chart
	*/
	private function drawVLines () : Void 
	{
		var depth : Number = this.dm.getDepth ("VLINES");
		//Movie clip containers
		var pVLineMC : MovieClip;
		var vVLineMC : MovieClip;
		//Loop var
		var i : Number;
		//Iterate through all the v-div lines
		for (i = 1; i <= this.numCat; i ++)
		{
			if (this.categories [i].showLine == true)
			{
				//If we've to show the line, create a movie clip
				pVLineMC = this.cMC.createEmptyMovieClip ("vLineP_" + i, depth);
				//Just draw line
				pVLineMC.lineStyle (this.params.catVerticalLineThickness, parseInt (this.params.catVerticalLineColor, 16) , this.params.catVerticalLineAlpha);
				//Now, if dashed line is to be drawn
				if ( ! this.categories [i].lineDashed)
				{
					//Draw normal line line keeping 0,0 as registration point
					pVLineMC.moveTo (0, 0);
					pVLineMC.lineTo (0, - this.elements.PCanvas.h);
				} else 
				{
					//Dashed Line line
					DrawingExt.dashTo (pVLineMC, 0, 0, 0, - this.elements.PCanvas.h, this.params.catVerticalLineDashLen, this.params.catVerticalLineDashGap);
				}
				//Re-position line
				pVLineMC._x = this.categories [i].x;
				pVLineMC._y = this.elements.PCanvas.toY;
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (pVLineMC, this.objects.VLINES, this.macro, pVLineMC._x, 0, pVLineMC._y, 0, 100, null, 100, null);
				}
				//Apply filters
				this.styleM.applyFilters (pVLineMC, this.objects.VLINES);
				//Increase depth
				depth ++;
				if (this.config.showVolume)
				{
					//Now, draw the same for volume chart.
					vVLineMC = this.cMC.createEmptyMovieClip ("vLineS_" + i, depth);
					//Just draw line
					vVLineMC.lineStyle (this.params.catVerticalLineThickness, parseInt (this.params.catVerticalLineColor, 16) , this.params.catVerticalLineAlpha);
					//Now, if dashed line is to be drawn
					if ( ! this.categories [i].lineDashed)
					{
						//Draw normal line line keeping 0,0 as registration point
						vVLineMC.moveTo (0, 0);
						vVLineMC.lineTo (0, - this.elements.VCanvas.h);
					} else 
					{
						//Dashed Line line
						DrawingExt.dashTo (vVLineMC, 0, 0, 0, - this.elements.VCanvas.h, this.params.catVerticalLineDashLen, this.params.catVerticalLineDashGap);
					}
					//Re-position line
					vVLineMC._x = this.categories [i].x;
					vVLineMC._y = this.elements.VCanvas.toY;
					//Apply animation
					if (this.params.animation)
					{
						this.styleM.applyAnimation (vVLineMC, this.objects.VLINES, this.macro, vVLineMC._x, 0, vVLineMC._y, 0, 100, null, 100, null);
					}
					//Apply filters
					this.styleM.applyFilters (vVLineMC, this.objects.VLINES);
					//Increase depth
					depth ++;
				}
			}
		}
		delete pVLineMC;
		delete vVLineMC;
		//Clear interval
		clearInterval (this.config.intervals.vLine);
	}
	/**
	* drawPDivLines method draws the div lines on the chart
	*/
	private function drawPDivLines () : Void 
	{
		var divLineValueObj : Object;
		var divLineFontObj : Object;
		var yPos : Number;
		var depth : Number = this.dm.getDepth ("PDIVLINES") - 1;
		//Movie clip container
		var divLineMC : MovieClip;
		//Get div line font
		divLineFontObj = this.styleM.getTextStyle (this.objects.YAXISVALUES);
		//Set alignment
		divLineFontObj.align = "left";
		divLineFontObj.vAlign = "middle";
		//Iterate through all the div line values
		var i : Number;
		for (i = 0; i < this.pDivLines.length; i ++)
		{
			//If it's the first or last div Line (limits), and limits are to be shown
			if ((i == 0) || (i == this.pDivLines.length - 1))
			{
				if (this.pDivLines [i].showValue)
				{
					depth ++;
					//Get y position for textbox
					yPos = this.getAxisPosition (this.pDivLines [i].value, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0);
					//Create the limits text
					divLineValueObj = createText (false, this.pDivLines [i].displayValue, this.cMC, depth, this.elements.PCanvas.toX + this.params.yAxisValuesPadding, yPos, 0, divLineFontObj, false, 0, 0);
				}
			} else 
			{
				//It's a div interval - div line
				//Get y position
				yPos = this.getAxisPosition (this.pDivLines [i].value, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0);
				//Render the line
				depth ++;
				divLineMC = this.cMC.createEmptyMovieClip ("DivLine_" + i, depth);
				//Draw the line
				divLineMC.lineStyle (this.params.divLineThickness, parseInt (this.params.divLineColor, 16) , this.params.divLineAlpha);
				if (this.params.divLineIsDashed)
				{
					//Dashed line
					DrawingExt.dashTo (divLineMC, - this.elements.PCanvas.w / 2, 0, this.elements.PCanvas.w / 2, 0, this.params.divLineDashLen, this.params.divLineDashGap);
				} else 
				{
					//Draw the line keeping 0,0 as registration point
					divLineMC.moveTo ( - this.elements.PCanvas.w / 2, 0);
					//Normal line
					divLineMC.lineTo (this.elements.PCanvas.w / 2, 0);
				}
				//Re-position the div line to required place
				divLineMC._x = this.elements.PCanvas.x + this.elements.PCanvas.w / 2;
				divLineMC._y = yPos - (this.params.divLineThickness / 2);
				//Apply animation and filter effects to div line
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (divLineMC, this.objects.DIVLINES, this.macro, null, 0, divLineMC._y, 0, 100, 100, null, null);
				}
				//Apply filters
				this.styleM.applyFilters (divLineMC, this.objects.DIVLINES);
				//So, check if we've to show div line values
				if (this.pDivLines [i].showValue)
				{
					//Increase Depth
					depth ++;
					//Create the text
					divLineValueObj = createText (false, this.pDivLines [i].displayValue, this.cMC, depth, this.elements.PCanvas.toX + this.params.yAxisValuesPadding, yPos, 0, divLineFontObj, false, 0, 0);
				}
			}
			//Apply animation and filter effects to div line (y-axis) values
			if (this.pDivLines [i].showValue)
			{
				if (this.params.animation)
				{
					this.styleM.applyAnimation (divLineValueObj.tf, this.objects.YAXISVALUES, this.macro, divLineValueObj.tf._x, 0, divLineValueObj.tf._y, 0, 100, null, null, null);
				}
				//Apply filters
				this.styleM.applyFilters (divLineValueObj.tf, this.objects.YAXISVALUES);
			}
		}
		delete divLineValueObj;
		delete divLineFontObj;
		//Clear interval
		clearInterval (this.config.intervals.pDivLines);
	}
	/**
	* drawPHGrid method draws the horizontal grid background color
	*/
	private function drawPHGrid () : Void 
	{
		//If we're required to draw horizontal grid color
		//and numDivLines > 3
		if (this.params.showAlternateHGridColor && this.pDivLines.length > 3)
		{
			//Movie clip container
			var gridMC : MovieClip;
			//Loop variable
			var i : Number;
			//Get depth
			var depth : Number = this.dm.getDepth ("PHGRID");
			//Y Position
			var yPos : Number, yPosEnd : Number;
			var height : Number;
			for (i = 1; i < this.pDivLines.length - 1; i = i + 2)
			{
				//Get y position
				yPos = this.getAxisPosition (this.pDivLines [i].value, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0);
				yPosEnd = this.getAxisPosition (this.pDivLines [i + 1].value, this.config.PYMax, this.config.PYMin, this.elements.PCanvas.y, this.elements.PCanvas.toY, true, 0);
				height = yPos - yPosEnd;
				//Create the movie clip
				gridMC = this.cMC.createEmptyMovieClip ("GridBg_" + i, depth);
				//Set line style to null
				gridMC.lineStyle ();
				//Set fill color
				gridMC.moveTo ( - (this.elements.PCanvas.w / 2) , - (height / 2));
				gridMC.beginFill (parseInt (this.params.alternateHGridColor, 16) , this.params.alternateHGridAlpha);
				//Draw rectangle
				gridMC.lineTo (this.elements.PCanvas.w / 2, - (height / 2));
				gridMC.lineTo (this.elements.PCanvas.w / 2, height / 2);
				gridMC.lineTo ( - (this.elements.PCanvas.w / 2) , height / 2);
				gridMC.lineTo ( - (this.elements.PCanvas.w / 2) , - (height / 2));
				//End Fill
				gridMC.endFill ();
				//Place it in right location
				gridMC._x = this.elements.PCanvas.x + this.elements.PCanvas.w / 2;
				gridMC._y = yPos - (height) / 2;
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (gridMC, this.objects.HGRID, this.macro, null, 0, gridMC._y, 0, 100, 100, 100, null);
				}
				//Apply filters
				this.styleM.applyFilters (gridMC, this.objects.HGRID);
				//Increase depth
				depth ++;
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.pHGrid);
	}
	/**
	* drawVDivLines method draws the div lines on the volume chart
	*/
	private function drawVDivLines () : Void 
	{
		if (this.config.showVolume)
		{
			var divLineValueObj : Object;
			var divLineFontObj : Object;
			var yPos : Number;
			var depth : Number = this.dm.getDepth ("VDIVLINES") - 1;
			//Movie clip container
			var divLineMC : MovieClip;
			//Get div line font
			divLineFontObj = this.styleM.getTextStyle (this.objects.YAXISVALUES);
			//Set alignment
			divLineFontObj.align = "left";
			divLineFontObj.vAlign = "middle";
			//Iterate through all the div line values
			var i : Number;
			for (i = 0; i < this.vDivLines.length; i ++)
			{
				//If it's the first or last div Line (limits), and limits are to be shown
				if ((i == 0) || (i == this.vDivLines.length - 1))
				{
					if (this.vDivLines [i].showValue)
					{
						depth ++;
						//Get y position for textbox
						yPos = this.getAxisPosition (this.vDivLines [i].value, this.config.VYMax, this.config.VYMin, this.elements.VCanvas.y, this.elements.VCanvas.toY, true, 0);
						//Create the limits text
						divLineValueObj = createText (false, this.vDivLines [i].displayValue, this.cMC, depth, this.elements.VCanvas.toX + this.params.yAxisValuesPadding, yPos, 0, divLineFontObj, false, 0, 0);
					}
				} else 
				{
					//It's a div interval - div line
					//Get y position
					yPos = this.getAxisPosition (this.vDivLines [i].value, this.config.VYMax, this.config.VYMin, this.elements.VCanvas.y, this.elements.VCanvas.toY, true, 0);
					//Render the line
					depth ++;
					divLineMC = this.cMC.createEmptyMovieClip ("VDivLine_" + i, depth);
					//Draw the line
					divLineMC.lineStyle (this.params.divLineThickness, parseInt (this.params.divLineColor, 16) , this.params.divLineAlpha);
					if (this.params.divLineIsDashed)
					{
						//Dashed line
						DrawingExt.dashTo (divLineMC, - this.elements.VCanvas.w / 2, 0, this.elements.VCanvas.w / 2, 0, this.params.divLineDashLen, this.params.divLineDashGap);
					} else 
					{
						//Draw the line keeping 0,0 as registration point
						divLineMC.moveTo ( - this.elements.VCanvas.w / 2, 0);
						//Normal line
						divLineMC.lineTo (this.elements.VCanvas.w / 2, 0);
					}
					//Re-position the div line to required place
					divLineMC._x = this.elements.VCanvas.x + this.elements.VCanvas.w / 2;
					divLineMC._y = yPos - (this.params.divLineThickness / 2);
					//Apply animation and filter effects to div line
					//Apply animation
					if (this.params.animation)
					{
						this.styleM.applyAnimation (divLineMC, this.objects.DIVLINES, this.macro, null, 0, divLineMC._y, 0, 100, 100, null, null);
					}
					//Apply filters
					this.styleM.applyFilters (divLineMC, this.objects.DIVLINES);
					//So, check if we've to show div line values
					if (this.vDivLines [i].showValue)
					{
						//Increase Depth
						depth ++;
						//Create the text
						divLineValueObj = createText (false, this.vDivLines [i].displayValue, this.cMC, depth, this.elements.VCanvas.toX + this.params.yAxisValuesPadding, yPos, 0, divLineFontObj, false, 0, 0);
					}
				}
				//Apply animation and filter effects to div line (y-axis) values
				if (this.vDivLines [i].showValue)
				{
					if (this.params.animation)
					{
						this.styleM.applyAnimation (divLineValueObj.tf, this.objects.YAXISVALUES, this.macro, divLineValueObj.tf._x, 0, divLineValueObj.tf._y, 0, 100, null, null, null);
					}
					//Apply filters
					this.styleM.applyFilters (divLineValueObj.tf, this.objects.YAXISVALUES);
				}
			}
			delete divLineValueObj;
			delete divLineFontObj;
		}
		//Clear interval
		clearInterval (this.config.intervals.vDivLines);
	}
	/**
	* drawHGrid method draws the horizontal grid background color
	* for volume chart
	*/
	private function drawVHGrid () : Void 
	{
		if (this.config.showVolume)
		{
			//If we're required to draw horizontal grid color
			//and numDivLines > 3
			if (this.params.showAlternateHGridColor && this.vDivLines.length > 3)
			{
				//Movie clip container
				var gridMC : MovieClip;
				//Loop variable
				var i : Number;
				//Get depth
				var depth : Number = this.dm.getDepth ("VHGRID");
				//Y Position
				var yPos : Number, yPosEnd : Number;
				var height : Number;
				for (i = 1; i < this.vDivLines.length - 1; i = i + 2)
				{
					//Get y position
					yPos = this.getAxisPosition (this.vDivLines [i].value, this.config.VYMax, this.config.VYMin, this.elements.VCanvas.y, this.elements.VCanvas.toY, true, 0);
					yPosEnd = this.getAxisPosition (this.vDivLines [i + 1].value, this.config.VYMax, this.config.VYMin, this.elements.VCanvas.y, this.elements.VCanvas.toY, true, 0);
					height = yPos - yPosEnd;
					//Create the movie clip
					gridMC = this.cMC.createEmptyMovieClip ("GridBg_" + i, depth);
					//Set line style to null
					gridMC.lineStyle ();
					//Set fill color
					gridMC.moveTo ( - (this.elements.VCanvas.w / 2) , - (height / 2));
					gridMC.beginFill (parseInt (this.params.alternateHGridColor, 16) , this.params.alternateHGridAlpha);
					//Draw rectangle
					gridMC.lineTo (this.elements.VCanvas.w / 2, - (height / 2));
					gridMC.lineTo (this.elements.VCanvas.w / 2, height / 2);
					gridMC.lineTo ( - (this.elements.VCanvas.w / 2) , height / 2);
					gridMC.lineTo ( - (this.elements.VCanvas.w / 2) , - (height / 2));
					//End Fill
					gridMC.endFill ();
					//Place it in right location
					gridMC._x = this.elements.VCanvas.x + this.elements.VCanvas.w / 2;
					gridMC._y = yPos - (height) / 2;
					//Apply animation
					if (this.params.animation)
					{
						this.styleM.applyAnimation (gridMC, this.objects.HGRID, this.macro, null, 0, gridMC._y, 0, 100, 100, 100, null);
					}
					//Apply filters
					this.styleM.applyFilters (gridMC, this.objects.HGRID);
					//Increase depth
					depth ++;
				}
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.vHGrid);
	}
	/**
	* drawTrendLines method draws the vertical trend lines on the chart
	* with their respective values.
	*/
	private function drawTrendLines () : Void 
	{
		var trendFontObj : Object;
		var trendValueObj : Object;
		var lineBelowDepth : Number = this.dm.getDepth ("TRENDLINESBELOW");
		var valueBelowDepth : Number = this.dm.getDepth ("TRENDVALUESBELOW");
		var lineAboveDepth : Number = this.dm.getDepth ("TRENDLINESABOVE");
		var valueAboveDepth : Number = this.dm.getDepth ("TRENDVALUESABOVE");
		var lineDepth : Number;
		var valueDepth : Number;
		var tbAnimX : Number = 0;
		//Movie clip container
		var trendLineMC : MovieClip;
		//Get font
		trendFontObj = this.styleM.getTextStyle (this.objects.TRENDVALUES);
		//Set vertical alignment
		trendFontObj.vAlign = "middle";
		//Loop variable
		var i : Number;
		//Iterate through all the trend lines
		for (i = 1; i <= this.numTrendLines; i ++)
		{
			if (this.trendLines [i].isValid == true)
			{
				//If it's a valid trend line
				//Get the depth and update counters
				if (this.trendLines [i].showOnTop)
				{
					//If the trend line is to be shown on top.
					lineDepth = lineAboveDepth;
					valueDepth = valueAboveDepth;
					lineAboveDepth ++;
					valueAboveDepth ++;
				} else 
				{
					//If it's to be shown below columns.
					lineDepth = lineBelowDepth;
					valueDepth = valueBelowDepth;
					lineBelowDepth ++;
					valueBelowDepth ++;
				}
				trendLineMC = this.cMC.createEmptyMovieClip ("TrendLine_" + i, lineDepth);
				//Now, draw the line or trend zone
				if (this.trendLines [i].isTrendZone)
				{
					//Create rectangle
					trendLineMC.lineStyle ();
					//Absolute height value
					this.trendLines [i].h = Math.abs (this.trendLines [i].h);
					//We need to align rectangle at L,M
					trendLineMC.moveTo (0, 0);
					//Begin fill
					trendLineMC.beginFill (parseInt (this.trendLines [i].color, 16) , this.trendLines [i].alpha);
					//Draw rectangle
					trendLineMC.lineTo (0, - (this.trendLines [i].h / 2));
					trendLineMC.lineTo (this.elements.PCanvas.w, - (this.trendLines [i].h / 2));
					trendLineMC.lineTo (this.elements.PCanvas.w, (this.trendLines [i].h / 2));
					trendLineMC.lineTo (0, (this.trendLines [i].h / 2));
					trendLineMC.lineTo (0, 0);
					//Re-position
					trendLineMC._x = this.elements.PCanvas.x;
					trendLineMC._y = this.trendLines [i].tbY;
				} else 
				{
					//Just draw line
					trendLineMC.lineStyle (this.trendLines [i].thickness, parseInt (this.trendLines [i].color, 16) , this.trendLines [i].alpha);
					//Now, if dashed line is to be drawn
					if ( ! this.trendLines [i].isDashed)
					{
						//Draw normal line line keeping 0,0 as registration point
						trendLineMC.moveTo (0, 0);
						trendLineMC.lineTo (this.elements.PCanvas.w, this.trendLines [i].h);
					} else 
					{
						//Dashed Line line
						DrawingExt.dashTo (trendLineMC, 0, 0, this.elements.PCanvas.w, this.trendLines [i].h, this.trendLines [i].dashLen, this.trendLines [i].dashGap);
					}
					//Re-position line
					trendLineMC._x = this.elements.PCanvas.x;
					trendLineMC._y = this.trendLines [i].y;
				}
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (trendLineMC, this.objects.TRENDLINES, this.macro, null, 0, trendLineMC._y, 0, 100, 100, 100, null);
				}
				//Apply filters
				this.styleM.applyFilters (trendLineMC, this.objects.TRENDLINES);
				//---------------------------------------------------------------------------//
				//Set color
				trendFontObj.color = this.trendLines [i].color;
				//Now, render the trend line value, based on its position
				trendFontObj.align = "right";
				//Create text
				trendValueObj = createText (false, this.trendLines [i].displayValue, this.cMC, valueDepth, this.elements.PCanvas.x - this.params.yAxisValuesPadding, this.trendLines [i].tbY, 0, trendFontObj, false, 0, 0);
				//X-position for text box animation
				tbAnimX = this.elements.PCanvas.x - this.params.yAxisValuesPadding - trendValueObj.width;
				//Animation and filter effect
				if (this.params.animation)
				{
					this.styleM.applyAnimation (trendValueObj.tf, this.objects.TRENDVALUES, this.macro, tbAnimX, 0, this.trendLines [i].tbY - (trendValueObj.height / 2) , 0, 100, null, null, null);
				}
				//Apply filters
				this.styleM.applyFilters (trendValueObj.tf, this.objects.TRENDVALUES);
			}
		}
		delete trendLineMC;
		delete trendValueObj;
		delete trendFontObj;
		//Clear interval
		clearInterval (this.config.intervals.trend);
	}
	/**
	* drawVTrendLines method draws the vertical trend lines on the chart
	* with their respective values.
	*/
	private function drawVTrendLines () : Void 
	{
		var trendFontObj : Object;
		var trendValueObj : Object;
		var lineDepth : Number = this.dm.getDepth ("VTRENDLINES");
		var valueDepth : Number = this.dm.getDepth ("VTRENDVALUES");
		var tbAnimY : Number = 0;
		//Movie clip container
		var trendLineMC : MovieClip;
		//Get font
		trendFontObj = this.styleM.getTextStyle (this.objects.TRENDVALUES);
		//Set vertical alignment
		trendFontObj.align = "center";
		trendFontObj.vAlign = "bottom";
		//Loop variable
		var i : Number;
		//Iterate through all the trend lines
		for (i = 1; i <= this.numVTrendLines; i ++)
		{
			if (this.vTrendLines [i].isValid == true)
			{
				//If it's a valid trend line
				trendLineMC = this.cMC.createEmptyMovieClip ("VTrendLineTop_" + i, lineDepth);
				if (this.vTrendLines [i].isTrendZone)
				{
					//Create rectangle
					trendLineMC.lineStyle ();
					//Absolute width value
					this.vTrendLines [i].w = Math.abs (this.vTrendLines [i].w);
					//We need to align rectangle at C,B
					trendLineMC.moveTo (0, 0);
					//Begin fill
					trendLineMC.beginFill (parseInt (this.vTrendLines [i].color, 16) , this.vTrendLines [i].alpha);
					//Draw rectangle
					trendLineMC.lineTo ( - (this.vTrendLines [i].w / 2) , 0);
					trendLineMC.lineTo ( - (this.vTrendLines [i].w / 2) , this.elements.PCanvas.h);
					trendLineMC.lineTo (this.vTrendLines [i].w / 2, this.elements.PCanvas.h);
					trendLineMC.lineTo (this.vTrendLines [i].w / 2, 0);
					trendLineMC.lineTo ( - (this.vTrendLines [i].w / 2) , 0);
					//Re-position
					trendLineMC._x = this.vTrendLines [i].tbX;
					trendLineMC._y = this.elements.PCanvas.y;
				} else 
				{
					//Just draw line
					trendLineMC.lineStyle (this.vTrendLines [i].thickness, parseInt (this.vTrendLines [i].color, 16) , this.vTrendLines [i].alpha);
					//Now, if dashed line is to be drawn
					if ( ! this.vTrendLines [i].isDashed)
					{
						//Draw normal line line keeping 0,0 as registration point
						trendLineMC.moveTo (0, 0);
						trendLineMC.lineTo (this.vTrendLines [i].w, this.elements.PCanvas.h);
					} else 
					{
						//Dashed Line line
						DrawingExt.dashTo (trendLineMC, 0, 0, this.vTrendLines [i].w, this.elements.PCanvas.h, this.vTrendLines [i].dashLen, this.vTrendLines [i].dashGap);
					}
					//Re-position line
					trendLineMC._x = this.vTrendLines [i].x;
					trendLineMC._y = this.elements.PCanvas.y;
				}
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (trendLineMC, this.objects.VTRENDLINES, this.macro, trendLineMC._x, 0, null, 0, 100, 100, 100, null);
				}
				//Apply filters
				this.styleM.applyFilters (trendLineMC, this.objects.VTRENDLINES);
				//Increment depth
				lineDepth ++;
				//Now - draw the bottom part of it (if required)
				if (this.config.showVolume)
				{
					trendLineMC = this.cMC.createEmptyMovieClip ("VTrendLineBottom_" + i, lineDepth);
					if (this.vTrendLines [i].isTrendZone)
					{
						//Create rectangle
						trendLineMC.lineStyle ();
						//Absolute width value
						this.vTrendLines [i].w = Math.abs (this.vTrendLines [i].w);
						//We need to align rectangle at C,B
						trendLineMC.moveTo (0, 0);
						//Begin fill
						trendLineMC.beginFill (parseInt (this.vTrendLines [i].color, 16) , this.vTrendLines [i].alpha);
						//Draw rectangle
						trendLineMC.lineTo ( - (this.vTrendLines [i].w / 2) , 0);
						trendLineMC.lineTo ( - (this.vTrendLines [i].w / 2) , this.elements.VCanvas.h);
						trendLineMC.lineTo (this.vTrendLines [i].w / 2, this.elements.VCanvas.h);
						trendLineMC.lineTo (this.vTrendLines [i].w / 2, 0);
						trendLineMC.lineTo ( - (this.vTrendLines [i].w / 2) , 0);
						//Re-position
						trendLineMC._x = this.vTrendLines [i].tbX;
						trendLineMC._y = this.elements.VCanvas.y;
					} else 
					{
						//Just draw line
						trendLineMC.lineStyle (this.vTrendLines [i].thickness, parseInt (this.vTrendLines [i].color, 16) , this.vTrendLines [i].alpha);
						//Now, if dashed line is to be drawn
						if ( ! this.vTrendLines [i].isDashed)
						{
							//Draw normal line line keeping 0,0 as registration point
							trendLineMC.moveTo (0, 0);
							trendLineMC.lineTo (this.vTrendLines [i].w, this.elements.VCanvas.h);
						} else 
						{
							//Dashed Line line
							DrawingExt.dashTo (trendLineMC, 0, 0, this.vTrendLines [i].w, this.elements.VCanvas.h, this.vTrendLines [i].dashLen, this.vTrendLines [i].dashGap);
						}
						//Re-position line
						trendLineMC._x = this.vTrendLines [i].x;
						trendLineMC._y = this.elements.VCanvas.y;
					}
					//Apply animation
					if (this.params.animation)
					{
						this.styleM.applyAnimation (trendLineMC, this.objects.VTRENDLINES, this.macro, trendLineMC._x, 0, null, 0, 100, 100, 100, null);
					}
					//Apply filters
					this.styleM.applyFilters (trendLineMC, this.objects.VTRENDLINES);
				}
				//---------------------------------------------------------------------------//
				//If text is to be shown
				if (this.vTrendLines [i].displayValue != "")
				{
					//Set color
					trendFontObj.color = this.vTrendLines [i].color;
					//Now, render the trend line value
					trendFontObj.align = "center";
					//Create text
					trendValueObj = createText (false, this.vTrendLines [i].displayValue, this.cMC, valueDepth, this.vTrendLines [i].tbX, ((this.config.showVolume) ? (this.elements.VCanvas.toY) : (this.elements.PCanvas.toY + this.config.labelAreaHeight)) , 0, trendFontObj, false, 0, 0);
					//Animation and filter effect
					if (this.params.animation)
					{
						this.styleM.applyAnimation (trendValueObj.tf, this.objects.VTRENDVALUES, this.macro, trendValueObj.tf._x, 0, trendValueObj.tf._y, 0, 100, null, null, null);
					}
					//Apply filters
					this.styleM.applyFilters (trendValueObj.tf, this.objects.VTRENDVALUES);
				}
				//Increment depth
				valueDepth ++;
			}
		}
		delete trendLineMC;
		delete trendValueObj;
		delete trendFontObj;
		//Clear interval
		clearInterval (this.config.intervals.vTrend);
	}
	/**
	* drawPriceChart method draws the price plots on the chart
	*/
	private function drawPriceChart ()
	{
		//Variables
		var dataMC : MovieClip;
		var depth : Number = this.dm.getDepth ("PRICEPLOT");
		var i : Number;
		//Create function storage containers for Delegate functions
		var fnRollOver : Function, fnClick : Function;
		//If we've to render chart as Line
		if (this.params.plotPriceAs == "LINE")
		{
			//Render as line Chart
			/**
			* The movie clip structure for a line chart would be :
			* |- Holder
			* |- |- Chart
			* We create child movie clip as we need to animate xscale
			* and y scale. So, we need to position Chart Movie clip at 0,0
			* inside holder movie clip and then readjust Holder movie clip's
			* X and Y Position as per chart's canvas.
			*/
			//Create holder movie clip
			var holderMC : MovieClip = this.cMC.createEmptyMovieClip ("ChartHolder", depth);
			//Create chart movie clip inside holder movie clip
			var chartMC : MovieClip = holderMC.createEmptyMovieClip ("Chart", 1);
			//Loop variables
			var i : Number, j : Number;
			var nxt : Number;
			var y : Number, nxtY : Number;
			//Variables to store the max and min Y positions
			var maxY : Number, minY : Number;
			//Now, we draw the lines inside chart
			for (i = 1; i < this.num; i ++)
			{
				//Get next Index
				nxt = i + 1;
				y = (this.params.plotClosingPrice) ?this.data [i].cy : this.data [i].oy;
				nxtY = (this.params.plotClosingPrice) ?this.data [nxt].cy : this.data [nxt].oy;
				//Set line style
				chartMC.lineStyle (this.params.plotLineThickness, parseInt (this.data [i].borderColor, 16) , this.data [i].alpha);
				//Now, based on whether we've to draw a normal or dashed line, we draw it
				if (this.data [i].dashed)
				{
					//Draw a dashed line
					DrawingExt.dashTo (chartMC, this.data [i].x, y, this.data [nxt].x, nxtY, this.params.plotLineDashLen, this.params.plotLineDashGap);
				} else 
				{
					//Move to the point
					chartMC.moveTo (this.data [i].x, y);
					//Draw point to next line
					chartMC.lineTo (this.data [nxt].x, nxtY);
				}
				//Get maxY and minY
				maxY = (maxY == undefined || (y > maxY)) ? y : maxY;
				minY = (minY == undefined || (y < minY)) ? y : minY;
			}
			//Now, we need to adjust the chart movie clip to 0,0 position as center
			chartMC._x = - (this.elements.PCanvas.w / 2) - this.elements.PCanvas.x;
			chartMC._y = - (maxY) + ((maxY - minY) / 2);
			//Set the position of holder movie clip now
			holderMC._x = (this.elements.PCanvas.w / 2) + this.elements.PCanvas.x;
			holderMC._y = (maxY) - ((maxY - minY) / 2);
			//Apply filter
			this.styleM.applyFilters (holderMC, this.objects.PRICEPLOT);
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (holderMC, this.objects.PRICEPLOT, this.macro, holderMC._x, 0, holderMC._y, 0, 100, 100, 100, null);
			}
		} else if (this.params.plotPriceAs == "CANDLESTICK")
		{
			//Render as Candle Stick Chart
			for (i = 1; i <= this.num; i ++)
			{
				//Create the movie clip
				var candleMC : MovieClip = this.cMC.createEmptyMovieClip ("Candle_" + i, depth);
				//Create the candle inside this movie clip with 0,0 as center
				var topY : Number = Math.min (this.data [i].cy, this.data [i].oy);
				var botY : Number = Math.max (this.data [i].cy, this.data [i].oy);
				var midY : Number = topY + ((botY - topY) / 2);
				var diffY : Number = (botY - topY) / 2;
				//Set line style
				candleMC.lineStyle (this.params.plotLineThickness, parseInt (this.data [i].borderColor, 16) , this.params.plotLineAlpha)
				//If we've to plot dashed line
				if (this.data [i].dashed)
				{
					//High Line
					DrawingExt.dashTo (candleMC, 0, - diffY, 0, - diffY + (this.data [i].hy - topY) , this.params.plotLineDashLen, this.params.plotLineDashLen);
					//Low Line
					DrawingExt.dashTo (candleMC, 0, diffY, 0, this.data [i].ly - botY + diffY, this.params.plotLineDashLen, this.params.plotLineDashLen);
					//Set empty lineStyle
					candleMC.lineStyle ();
				}else
				{
					//Plot normally
					//High Line
					candleMC.moveTo (0, - diffY);
					candleMC.lineTo (0, - diffY + (this.data [i].hy - topY));
					//Low Line
					candleMC.moveTo (0, diffY);
					candleMC.lineTo (0, this.data [i].ly - botY + diffY);
				}
				//Move to center left,0
				candleMC.moveTo ( - this.config.plotWidth / 2, 0);
				//Fill Color
				candleMC.beginFill (parseInt (this.data [i].color, 16) , this.data [i].alpha);
				//Draw candle fill region
				candleMC.lineTo ( - this.config.plotWidth / 2, - diffY);
				candleMC.lineTo (this.config.plotWidth / 2, - diffY);
				candleMC.lineTo (this.config.plotWidth / 2, diffY);
				candleMC.lineTo ( - this.config.plotWidth / 2, diffY);
				candleMC.lineTo ( - this.config.plotWidth / 2, 0);
				candleMC.endFill ()
				//If we've to plot it as dash, we need to render the border again/
				if (this.data [i].dashed)
				{
					candleMC.lineStyle (this.params.plotLineThickness, parseInt (this.data [i].borderColor, 16) , this.params.plotLineAlpha)
					DrawingExt.dashTo (candleMC, - this.config.plotWidth / 2, 0, - this.config.plotWidth / 2, - diffY, this.params.plotLineDashLen, this.params.plotLineDashLen);
					DrawingExt.dashTo (candleMC, - this.config.plotWidth / 2, - diffY, this.config.plotWidth / 2, - diffY, this.params.plotLineDashLen, this.params.plotLineDashLen);
					DrawingExt.dashTo (candleMC, this.config.plotWidth / 2, - diffY, this.config.plotWidth / 2, diffY, this.params.plotLineDashLen, this.params.plotLineDashLen);
					DrawingExt.dashTo (candleMC, this.config.plotWidth / 2, diffY, - this.config.plotWidth / 2, diffY, this.params.plotLineDashLen, this.params.plotLineDashLen);
					DrawingExt.dashTo (candleMC, - this.config.plotWidth / 2, diffY, - this.config.plotWidth / 2, 0, this.params.plotLineDashLen, this.params.plotLineDashLen);
				}
				//Set X Position
				candleMC._x = this.data [i].x;
				candleMC._y = midY;
				//Event handlers for tool tip
				if (this.params.showToolTip)
				{
					//Create Delegate for roll over function dataOnRollOver
					fnRollOver = Delegate.create (this, dataOnRollOver);
					//Set the index
					fnRollOver.index = i;
					//Assing the delegates to movie clip handler
					candleMC.onRollOver = fnRollOver;
					//Set roll out and mouse move too.
					candleMC.onRollOut = candleMC.onReleaseOutside = Delegate.create (this, dataOnRollOut);
					candleMC.onMouseMove = Delegate.create (this, dataOnMouseMove);
				}
				//Click handler for links - only if link for this column has been defined and click URL
				//has not been defined.
				if (this.data [i].link != "" && this.data [i].link != undefined && this.params.clickURL == "")
				{
					//Create delegate function
					fnClick = Delegate.create (this, dataOnClick);
					//Set index
					fnClick.index = i;
					//Assign
					candleMC.onRelease = fnClick;
				}
				else
				{
					//Do not use hand cursor
					candleMC.useHandCursor = (this.params.clickURL == "") ?false : true;
				}
				//Apply filter
				this.styleM.applyFilters (candleMC, this.objects.PRICEPLOT);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (candleMC, this.objects.PRICEPLOT, this.macro, candleMC._x, 0, candleMC._y, 0, 100, 100, 100, null);
				}
				//Increase depth
				depth ++;
			}
		}else
		{
			//Render as Bar Chart
			for (i = 1; i <= this.num; i ++)
			{
				//Create the movie clip
				var barMC : MovieClip = this.cMC.createEmptyMovieClip ("Bar_" + i, depth);
				//Create the bar inside this movie clip with 0,0 as center
				var topY : Number = Math.min (this.data [i].cy, this.data [i].oy);
				var botY : Number = Math.max (this.data [i].cy, this.data [i].oy);
				var midY : Number = topY + ((botY - topY) / 2);
				var diffY : Number = (botY - topY) / 2;
				//Set line style
				barMC.lineStyle (this.params.plotLineThickness, parseInt (this.data [i].borderColor, 16) , this.params.plotLineAlpha)
				//If we've to plot dashed bar
				if (this.data [i].dashed)
				{
					//Low-High Line
					DrawingExt.dashTo (barMC, 0, this.data [i].ly - botY + diffY, 0, - diffY + (this.data [i].hy - topY) , this.params.plotLineDashLen, this.params.plotLineDashLen);
					//Set empty lineStyle
					barMC.lineStyle ();
				}else
				{
					//Plot normal bar
					//Low - High Line
					barMC.moveTo (0, this.data [i].ly - botY + diffY);
					barMC.lineTo (0, - diffY + (this.data [i].hy - topY));
					//Opening Line
					barMC.moveTo (0, this.data [i].oy - botY + diffY);
					barMC.lineTo ( - this.config.plotWidth / 2, this.data [i].oy - botY + diffY);
					//Closing line
					barMC.moveTo (0, this.data [i].cy - botY + diffY);
					barMC.lineTo (this.config.plotWidth / 2, this.data [i].cy - botY + diffY);
				}
				//Set X Position
				barMC._x = this.data [i].x;
				barMC._y = midY;
				//Event handlers for tool tip
				if (this.params.showToolTip)
				{
					//Create Delegate for roll over function dataOnRollOver
					fnRollOver = Delegate.create (this, dataOnRollOver);
					//Set the index
					fnRollOver.index = i;
					//Assing the delegates to movie clip handler
					barMC.onRollOver = fnRollOver;
					//Set roll out and mouse move too.
					barMC.onRollOut = barMC.onReleaseOutside = Delegate.create (this, dataOnRollOut);
					barMC.onMouseMove = Delegate.create (this, dataOnMouseMove);
				}
				//Click handler for links - only if link for this column has been defined and click URL
				//has not been defined.
				if (this.data [i].link != "" && this.data [i].link != undefined && this.params.clickURL == "")
				{
					//Create delegate function
					fnClick = Delegate.create (this, dataOnClick);
					//Set index
					fnClick.index = i;
					//Assign
					barMC.onRelease = fnClick;
				}
				else
				{
					//Do not use hand cursor
					barMC.useHandCursor = (this.params.clickURL == "") ?false : true;
				}
				//Apply filter
				this.styleM.applyFilters (barMC, this.objects.PRICEPLOT);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (barMC, this.objects.PRICEPLOT, this.macro, barMC._x, 0, barMC._y, 0, 100, 100, 100, null);
				}
				//Increase depth
				depth ++;
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.pricePlot);
	}
	/**
	* drawVolumeChart method draws the volume columns on the chart
	*/
	private function drawVolumeChart ()
	{
		if (this.config.showVolume)
		{
			//Variables
			var colMC : MovieClip;
			var colIns : Column2D;
			var depth : Number = this.dm.getDepth ("VOLUMEPLOT");
			var i : Number;
			//Create function storage containers for Delegate functions
			var fnRollOver : Function, fnClick : Function;
			//Iterate through all columns
			for (i = 1; i <= this.num; i ++)
			{
				if (this.data [i].volume != - 1)
				{
					//Create an empty movie clip for this column
					colMC = this.cMC.createEmptyMovieClip ("Column_" + i, depth);
					//Create column instance
					//colIns = new Column2D(colMC, this.data[i].vw, this.data[i].vh, this.params.vPlotBorderColor, this.params.vPlotBorderAlpha, this.params.vPlotBorderThickness, [parseInt(this.data[i].color,16)], [this.data[i].alpha], [255], 100, false, this.data[i].dashed, this.params.plotLineDashLen, this.params.plotLineDashGap);
					colIns = new Column2D (colMC, this.data [i].vw, this.data [i].vh, this.data [i].borderColor, this.params.vPlotBorderAlpha, this.params.vPlotBorderThickness, [parseInt (this.data [i].color, 16)] , [this.data [i].alpha] , [255] , 100, false, this.data [i].dashed, this.params.plotLineDashLen, this.params.plotLineDashGap);
					//Draw the column
					colIns.draw ();
					//Set x and y position
					colMC._x = this.data [i].vx;
					colMC._y = this.data [i].vy;
					//Set the alpha of entire column
					colMC._alpha = this.data [i].alpha;
					//Apply animation
					if (this.params.animation)
					{
						this.styleM.applyAnimation (colMC, this.objects.VOLUMEPLOT, this.macro, this.data [i].vx, 0, this.data [i].vy, 0, 100, 100, 100, null);
					}
					//Apply filters
					this.styleM.applyFilters (colMC, this.objects.VOLUMEPLOT);
					//Event handlers for tool tip
					if (this.params.showToolTip)
					{
						//Create Delegate for roll over function dataOnRollOver
						fnRollOver = Delegate.create (this, dataOnRollOver);
						//Set the index
						fnRollOver.index = i;
						//Assing the delegates to movie clip handler
						colMC.onRollOver = fnRollOver;
						//Set roll out and mouse move too.
						colMC.onRollOut = colMC.onReleaseOutside = Delegate.create (this, dataOnRollOut);
						colMC.onMouseMove = Delegate.create (this, dataOnMouseMove);
					}
					//Click handler for links - only if link for this column has been defined and click URL
					//has not been defined.
					if (this.data [i].link != "" && this.data [i].link != undefined && this.params.clickURL == "")
					{
						//Create delegate function
						fnClick = Delegate.create (this, dataOnClick);
						//Set index
						fnClick.index = i;
						//Assign
						colMC.onRelease = fnClick;
					}
					else
					{
						//Do not use hand cursor
						colMC.useHandCursor = (this.params.clickURL == "") ?false : true;
					}
					//Increase depth
					depth ++;
				}
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.volumePlot);
	}
	/**
	* drawTrendSets method draws the trend sets on the chart
	*/
	private function drawTrendSets () : Void 
	{
		/**
		* The movie clip structure for each trend set line (trendset) would be :
		* |- Holder
		* |- |- Chart
		* We create child movie clip as we need to animate xscale
		* and y scale. So, we need to position Chart Movie clip at 0,0
		* inside holder movie clip and then readjust Holder movie clip's
		* X and Y Position as per chart's canvas.
		*/
		var m : Number;
		var depth : Number = this.dm.getDepth ("TRENDSETS");
		for (m = 1; m <= this.numTS; m ++)
		{
			//Create holder movie clip
			var holderMC : MovieClip = this.cMC.createEmptyMovieClip ("TrendSetHolder_" + m, depth);
			//Create chart movie clip inside holder movie clip
			var chartMC : MovieClip = holderMC.createEmptyMovieClip ("TrendChart", 1);
			//Loop variables
			var i : Number, j : Number, nxt : Number;
			//Variables to store the max and min Y positions
			var maxY : Number, minY : Number;
			//Now, we draw the lines inside chart
			for (i = 1; i < this.trendset [m].num; i ++)
			{
				//Get next Index
				nxt = i + 1;
				//Set line style
				chartMC.lineStyle (this.trendset [m].thickness, parseInt (this.trendset [m].color, 16) , this.trendset [m].alpha);
				//Now, based on whether we've to draw a normal or dashed line, we draw it
				if (this.trendset [m].dashed)
				{
					//Draw a dashed line
					DrawingExt.dashTo (chartMC, this.trendset [m].data [i].x, this.trendset [m].data [i].y, this.trendset [m].data [nxt].x, this.trendset [m].data [nxt].y, this.trendset [m].dashLen, this.trendset [m].dashGap);
				} else 
				{
					//Move to the point
					chartMC.moveTo (this.trendset [m].data [i].x, this.trendset [m].data [i].y);
					//Draw point to next line
					chartMC.lineTo (this.trendset [m].data [nxt].x, this.trendset [m].data [nxt].y);
				}
				//Get maxY and minY
				maxY = (maxY == undefined || (this.trendset [m].data [i].y > maxY)) ? this.trendset [m].data [i].y : maxY;
				minY = (minY == undefined || (this.trendset [m].data [i].y < minY)) ? this.trendset [m].data [i].y : minY;
			}
			//Now, we need to adjust the chart movie clip to 0,0 position as center
			chartMC._x = - (this.elements.PCanvas.w / 2) - this.elements.PCanvas.x;
			chartMC._y = - (maxY) + ((maxY - minY) / 2);
			//Set the position of holder movie clip now
			holderMC._x = (this.elements.PCanvas.w / 2) + this.elements.PCanvas.x;
			holderMC._y = (maxY) - ((maxY - minY) / 2);
			//Apply filter
			this.styleM.applyFilters (holderMC, this.objects.TRENDSETS);
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (holderMC, this.objects.TRENDSETS, this.macro, holderMC._x, 0, holderMC._y, 0, 100, 100, 100, null);
			}
			//Increment depth
			depth ++;
		}
		//Clear interval
		clearInterval (this.config.intervals.trendSets);
	}
	/**
	* drawAnchors method draws the anchors on the chart
	*/
	private function drawAnchors () : Void 
	{
		//If the anchors are to be drawn & it's line chart
		if (this.params.drawAnchors && this.params.plotPriceAs == "LINE")
		{
			//Variables
			var anchorMC : MovieClip;
			var depth : Number = this.dm.getDepth ("ANCHORS");
			var i : Number;
			//Create function storage containers for Delegate functions
			var fnRollOver : Function, fnClick : Function;
			//Iterate through all columns
			for (i = 1; i <= this.num; i ++)
			{
				//Create an empty movie clip for this anchor
				anchorMC = this.cMC.createEmptyMovieClip ("Anchor_" + i, depth);
				//Set the line style and fill
				anchorMC.lineStyle (this.params.anchorBorderThickness, parseInt (this.params.anchorBorderColor, 16) , 100);
				anchorMC.beginFill (parseInt (this.params.anchorBgColor, 16) , this.params.anchorBgAlpha);
				//Draw the polygon
				DrawingExt.drawPoly (anchorMC, 0, 0, this.params.anchorSides, this.params.anchorRadius, 90);
				//Set the x and y Position
				anchorMC._x = this.data [i].x;
				anchorMC._y = (this.params.plotClosingPrice) ?this.data [i].cy : this.data [i].oy;
				//Set the alpha of entire anchor
				anchorMC._alpha = this.params.anchorAlpha;
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (anchorMC, this.objects.ANCHORS, this.macro, anchorMC._x, 0, anchorMC._y, 0, this.params.anchorAlpha, 100, 100, null);
				}
				//Apply filters
				this.styleM.applyFilters (anchorMC, this.objects.ANCHORS);
				//Event handlers for tool tip
				if (this.params.showToolTip)
				{
					//Create Delegate for roll over function columnOnRollOver
					fnRollOver = Delegate.create (this, dataOnRollOver);
					//Set the index
					fnRollOver.index = i;
					//Assing the delegates to movie clip handler
					anchorMC.onRollOver = fnRollOver;
					//Set roll out and mouse move too.
					anchorMC.onRollOut = anchorMC.onReleaseOutside = Delegate.create (this, dataOnRollOut);
				}
				//Click handler for links - only if link for this anchor has been defined and click URL
				//has not been defined.
				if (this.data [i].link != "" && this.data [i].link != undefined && this.params.clickURL == "")
				{
					//Create delegate function
					fnClick = Delegate.create (this, dataOnClick);
					//Set index
					fnClick.index = i;
					//Assign
					anchorMC.onRelease = fnClick;
				} else 
				{
					//Do not use hand cursor
					anchorMC.useHandCursor = (this.params.clickURL == "") ? false : true;
				}
				//Increase depth
				depth ++;
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.anchors);
	}
	/**
	* drawValues method draws the values on the chart.
	*/
	private function drawValues () : Void 
	{
		//Get value text style
		var valueStyleObj : Object = this.styleM.getTextStyle (this.objects.DATAVALUES);
		//Individual properties
		var isBold : Boolean = valueStyleObj.bold;
		var isItalic : Boolean = valueStyleObj.italic;
		var font : String = valueStyleObj.font;
		var angle : Number = 0;
		//Container object
		var valueObj : MovieClip;
		//Depth
		var depth : Number = this.dm.getDepth ("DATAVALUES");
		//Loop var
		var i : Number;
		var yPos : Number;
		var align : String, vAlign : String;
		////Iterate through all points
		for (i = 1; i <= this.num; i ++)
		{
			//If defined and value is to be shown
			if (this.data [i].valueText != "")
			{
				//For first point, we show the value on top
				vAlign = "top";
				yPos = this.data [i].valTBY;
				//Align position
				align = "center";
				//Convey alignment to rendering object
				valueStyleObj.align = align;
				valueStyleObj.vAlign = vAlign;
				//Now, if the labels are to be rotated
				if (this.params.rotateValues)
				{
					valueStyleObj.bold = false;
					valueStyleObj.italic = false;
					valueStyleObj.font = _embeddedFont;
					angle = 270;
				} else 
				{
					//Normal horizontal label - Store original properties
					valueStyleObj.bold = isBold;
					valueStyleObj.italic = isItalic;
					valueStyleObj.font = font;
					angle = 0;
				}
				valueObj = createText (false, this.data [i].valueText, this.cMC, depth, this.data [i].x, yPos, angle, valueStyleObj, false, 0, 0);
				//Apply filter
				this.styleM.applyFilters (valueObj.tf, this.objects.DATAVALUES);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (valueObj.tf, this.objects.DATAVALUES, this.macro, valueObj.tf._x, 0, valueObj.tf._y, 0, 100, null, null, null);
				}
				//Increase depth
				depth ++;
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.dataValues);
	}
	/**
	* drawLegend method renders the legend
	*/
	private function drawLegend () : Void
	{
		if (this.params.showLegend)
		{
			this.lgnd.render ();
			//Apply filter
			this.styleM.applyFilters (lgndMC, this.objects.LEGEND);
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (lgndMC, this.objects.LEGEND, this.macro, null, 0, null, 0, 100, null, null, null);
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.legend);
	}
	/**
	* setContextMenu method sets the context menu for the chart.
	* For this chart, the context items are "Print Chart".
	*/
	private function setContextMenu () : Void 
	{
		var chartMenu : ContextMenu = new ContextMenu ();
		chartMenu.hideBuiltInItems ();
		//Create a print chart contenxt menu item
		var printCMI : ContextMenuItem = new ContextMenuItem ("Print Chart", Delegate.create (this, printChart));
		//Push print item.
		chartMenu.customItems.push (printCMI);
		if (this.params.imageSave){
			//Add the export to image option
			chartMenu.customItems.push(super.returnImageSaveMenuItem());		
		}
		if (this.params.showFCMenuItem){
			//Push "About FusionCharts" Menu Item
			chartMenu.customItems.push(super.returnAbtMenuItem());		
		}
		//Assign the menu to cMC movie clip
		this.cMC.menu = chartMenu;
	}
	// -------------------- EVENT HANDLERS --------------------//
	/**
	* dataOnRollOver is the delegat-ed event handler method that'll
	* be invoked when the user rolls his mouse over an anchor.
	* This function is invoked, only if the tool tip is to be shown.
	* Here, we show the tool tip.
	*/
	private function dataOnRollOver () : Void 
	{
		//Index of data is stored in arguments.caller.index
		var index : Number = arguments.caller.index;
		//Set tool tip text
		this.tTip.setText (this.data [index].toolText);
		//Show the tool tip
		this.tTip.show ();
		//Position roll over band
		this.positionRollOverBand (index);
	}
	/**
	* dataOnRollOut method is invoked when the mouse rolls out
	* of anchor. We just hide the tool tip here.
	*/
	private function dataOnRollOut () : Void 
	{
		//Hide the tool tip
		this.tTip.hide ();
		//Hide roll over band
		this.hideRollOverBand ();
	}
	/*
	* dataOnMouseMove is called when the mouse position has changed
	* over data. We reposition the tool tip.
	*/
	private function dataOnMouseMove () : Void
	{
		//Reposition the tool tip only if it's in visible state
		if (this.tTip.visible ())
		{
			this.tTip.rePosition ();
		}
	}
	/**
	* dataOnClick is invoked when the user clicks on a anchor (if link
	* has been defined). We invoke the required link.
	*/
	private function dataOnClick () : Void 
	{
		//Index of column is stored in arguments.caller.index
		var index : Number = arguments.caller.index;
		//Invoke the link
		super.invokeLink (this.data [index].link);
	}
	/**
	* reInit method re-initializes the chart. This method is basically called
	* when the user changes chart data through JavaScript. In that case, we need
	* to re-initialize the chart, set new XML data and again render.
	*/
	public function reInit () : Void 
	{
		//Invoke super class's reInit
		super.reInit ();
		//Now initialize things that are pertinent to this class
		//but not defined in super class.
		//Initialize the containers for chart
		this.categories = new Array ();
		this.data = new Array ();
		this.pDivLines = new Array ();
		this.vDivLines = new Array ();
		this.trendset = new Array ();
		this.trendLines = new Array ();
		this.vTrendLines = new Array ();
		//Initialize the indexes
		this.num = 0;
		this.numCat = 0;
		this.numTS = 0;
		this.numTSData = 0;
		this.numTrendLines = 0;
		this.numTrendLinesBelow = 0;
		this.numVTrendLines = 0;
		this.numLegendItems = 0;
		//Whether to show volume part - by default false
		this.config.showVolume = false;
		//Re-set the legend
		this.lgnd.reset ();
	}
	/**
	* remove method removes the chart by clearing the chart movie clip
	* and removing any listeners.
	*/
	public function remove () : Void 
	{
		super.remove ();
		//Remove class pertinent objects
		this.lgnd.destroy ();
		lgndMC.removeMovieClip ();
	}
}
